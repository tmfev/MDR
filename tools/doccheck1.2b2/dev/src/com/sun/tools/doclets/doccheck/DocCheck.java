/*
 * @(#)DocCheck.java	1.8  03/07/10
 * 
 * Copyright 2003 Sun Microsystems, Inc. All rights reserved.
 * Use is subject to license terms.
 */

package com.sun.tools.doclets.doccheck;

import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.ConstructorDoc;
import com.sun.javadoc.Doclet;
import com.sun.javadoc.DocErrorReporter;
import com.sun.javadoc.ExecutableMemberDoc;
import com.sun.javadoc.FieldDoc;
import com.sun.javadoc.MethodDoc;
import com.sun.javadoc.PackageDoc;
import com.sun.javadoc.Parameter;
import com.sun.javadoc.ParamTag;
import com.sun.javadoc.RootDoc;
import com.sun.javadoc.SeeTag;
import com.sun.javadoc.Tag;
import com.sun.javadoc.ThrowsTag;
import com.sun.javadoc.Type;

import com.sun.tools.doclets.util.PathSpecifier;
import com.sun.tools.doclets.util.FileSpecifier;
import com.sun.tools.doclets.util.HtmlTagWriter;

import java.util.*;
import java.text.SimpleDateFormat;
import java.io.File;
import java.io.IOException;

import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.util.Hashtable;

//----------------------------
// These are used for the classfile list.
// If that goes, these can go, too.
import java.io.FileOutputStream;
import java.io.BufferedOutputStream;
import java.io.PrintWriter;
//----------------------------

/**
 * Checks API specifications contained in Java source files. <br>
 * Generates templates for missing comments.
 * <p>
 * Multiple severity levels:</p><dl>
 * <dt>sev 1</dt>
 * <dd>Package, interface, or class missing comments.</dd>
 * <dt>sev 2</dt>
 * <dd>Field, constructor, or method missing comments.</dd>
 * <dt>sev 3</dt>
 * <dd>Missing, incomplete, or extraneous tags.</dd>
 * <dt>sev 4</dt>
 * <dd>Unterminated HTML in first sentence.</dd>
 * <dd>FUTURE: invalid @see links</dd>
 * </dl>
 * Possibilities for improvement include:
 *   <ul>
 *   <li>Invalid links (sev 4): See if an option can be added to JavaDoc
 *       so the doclet can process @see and @link errors, instead of having
 *       JavaDoc automatically generate the errors.
 *   <li>Null comments (sev 4): After eliminating punctuation, words that are
 *       part of the method name, grammatical words (a, of, ...) and common
 *       technincal terms (object, value, ...), see if there is anything left
 *       in the comment. If not, generate a "null comment" warning, to identify
 *       "getFoo(): Returns foo." as basically uninformative.
 *   <li>Drive the program from a .ini file, so special tags are identified
 *       in the file, along with the text to generate for them. Boolean and
 *       int tags then become a special case of a generalized customization
 *       facility.<br>
 *       The best way to do that is to use the XML SAX parser to read a .ini
 *       file. Items to include in DEFAULTS section:<ul>
 *          <li>lineend (\n, \r, or \r\n) (newline/linefeed, carriage return)
 *              (\n, /r => "/" directory separator. \r\n => "\")
 *          <li>author tag
 *          <li>version tag
 *          </ul>
 *   </ul>
 * <p>
 * Version History:<br><pre>
 *   1.2.2 - Modified to work with 1.4 of the java platform.  Because it 
 *           still works with JDK 1.2, the main version number stays 1.2.   
 *           Corresponds to public release 1.2 Beta 2, so named 1.2b2 below. 
 *   1.2.1 - Options -author and -version changed to -authorID, -versionID,
 *           to avoid conflict with Javadoc options with same name.
 *   1.2  -- Param tags now recognize comma-separated lists.
 *           (param x,y ... | param x, y... | param x, &nbsp;y...)
 *   1.1  -- Added singleton tags &lt;hr&gt; and &lt;img&gt;, along with
 *           potential singletons &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;.
 *        -- Fixed reporting of unterminated Html tags to properly
 *           display the text that includes the tag.
 *        -- Fixed a bug that cause unclosed HTML tag errors to
 *           go unreported when extra html tags were reported.
 *        -- Fixed Html tag error reporting so that the errors
 *           are reported in the same order they occur.
 *        -- Fixed multiple prints of "Package" header in PackageErrors
 *           file when package has more than one class of error.
 *   1.0  -- Created from it's predecessor, DocCheck.
 * </pre>
 * @author Eric Armstrong
 * @version 1.2
 */
public class DocCheck extends Doclet implements DocCheckConstants
{
    /**
     * If true, tells the doclet to add a "Generated by" line
     * to the summary page.
     */
    protected static boolean docletID = false;
    protected static String  docletVersion = "1.2b2";
    
    /**
     * Configuration file. (A properties file)
     */
    protected static String configFilename = null;
    
    /** The clause used to start generated comments for constructors */
    protected static String cnr_clause = "Constructs";
    /** The clause used for object-values in constructors */
    protected static String obj_clause = "object";
    /** The clause used to start generated comments for getFoo() methods */
    protected static String get_clause = "Returns the";
    /** The clause used to start generated comments for setFoo() methods */
    protected static String set_clause = "Specifies the";
    /** The clause used to start generated comments for isFoo() methods */
    protected static String is_clause  = "Returns true if this object is";
    /** The clause used to end generated comments for non-boolean values */
    protected static String val_clause = "value";
    /** The clause used to start generated comments for boolean setFoo() methods */
    protected static String bSet_clause = "Identifies this object as";
    /** The clause used in generated comments for boolean values */
    protected static String bVal_clause = "";
    /** The clause used for generated interface comments. */
    protected static String ifc_clause = "Defines the requirements for an object that ...";
    
    /** The name of the file to create when listing classes that have errors */
    protected static String classListFile = "classErr.lst";
    
    /** HTML tags that can be safely ignored, because they need no termination */
    protected static String[] singleTag = {"p", "br", "li", "dt",
            "dd", "td", "hr", "img",
            "tr", "th", "td",
    };
    /** Name for @author tags. */
    protected static String  author = "unattributed";
    
    /** Title line for report. */
    protected static String  versionTitle = "";
    
    /** Used to point to the output directory. */
    protected static String  pathPrefix = "";
    
    /**
     * Returns the name used for @author tags.
     * The default author name = "unknown".
     *
     * @return a String containing the author name.
     */
    public  static String getAuthor() { return author; }
    /**
     * Sets the string used for @author tags.
     *
     * @param s  a String ...
     */
    public  static void   setAuthor(String s) { author = s; }
    
    /** String for @version tags. Default version string = Sun standard version-markers */
    protected static String  version = "%I" +"% %G" + "%";
    // Note: The string is broken up so SCCS doesn't interpret it when the file is checked in
    
    /**
     * Returns the version value.
     *
     * @return the String used for the @version tag.
     */
    public  static String getVersion() { return version; }
    /**
     * Set the version value.
     *
     * @param s  a String to use for the @version tag
     */
    public  static void   setVersion(String s) { version = s; }
    /**
     * Set the title string.
     *
     * @param s  a String to use for the report
     */
    public  static void   setTitle(String s) { versionTitle = s; }
    
    /**
     * Default line-terminator. Defaults to NL (=LF) rather than
     * system-specific terminator, in case it is being used over a network.
     */
    protected static String  eol = "\n";
    /**
     * Returns the EOL value.
     *
     * @return the String that ends lines.
     */
    public  static String getEOL() { return eol; }
    /**
     * Set the EOL value.
     *
     * @param s  a String to use as the line terminator
     */
    public  static void   setEOL(String s) { eol = s; }
    
    /**
     * If true, tells the doclet to generate a file containing a list
     * of classes that contain errors. (Useful for checking out files
     * from a source control system, for counting errors, or for a
     * cursory review of where the errors are found.)
     */
    protected static boolean classlist = false;
    
    /** The directory-name seprator string. */
    protected static char separator = '/';
    
    /**
     * The place where the list of error-containing classes (class.lst)
     * will be created if the -classlist option is specified.
     */
    protected static String outputDir;
    
    /** The file that gets the list of error-containing files. */
    protected static PrintWriter listFile;
    
    /** The sum of all errors. */
    protected ErrorTracker totalErrors = new ErrorTracker("All Packages", "");
    
    /**
     * The error level at which "self-evident comments are reported.
     * Self-evident comments are those that can be automatically
     * generated from the text of the method name. The default is
     * to treat them the same as other comments. That can be changed
     * with the -evident command line switch. For example, "-evident 2"
     * downgrades them to the level of a tag error, while "-evident 3"
     * downgrades them to a text error. To downgrade them to a warning,
     * use "-evident 4".
     * @see #firstLine
     */
    protected static int selfEvidentCommentLevel = SELF_EVIDENT;
    
    /** Packages to skip. */
    protected static List pkgSkipList = new LinkedList();
    
    /** Classes to skip. */
    protected static List classSkipList = new LinkedList();
    
    /**
     * The package depth for the executive summary page. Default
     * is one (java.*, javax.*). Change with the -execDepth option.
     * Set to 2 for use on the Java platform, to give summaries for
     * java.applet.*, java.awt.*, etc.
     */
    protected static int execDepth = 1;
    
    // File names
    protected static String mainFile    = "index.html";
    protected static String execSummary = "ExecutiveSummary.html";
    protected static String pkgSummary  = "PackageSummary.html";
    protected static String statsFile   = "PackageStatistics.html";
    protected static String errorFile   = "PackageErrors.html";
    
    /**
     * Initialize the list of packages to skip.
     *
     * @param s  a list of package-patterns separated by the
     *           current system's path separator (":" for Unix,
     *           ";" for DOS), where each pattern is a fully-qualified
     *           path separated by "." characters.
     *
     * @see PathSpecifier
     */
    public static void setPkgSkipList(String s) {
        boolean trace = false;
        String entrySeparator = System.getProperty("path.separator");
        StringTokenizer lt = new StringTokenizer(s, entrySeparator);
        while (lt.hasMoreTokens()) {
            String listEntry = lt.nextToken();
            if (trace) System.out.println("Adding pckg "+listEntry);
            PathSpecifier p = new PathSpecifier(listEntry, ".");
            pkgSkipList.add(p);
            if (trace) System.out.println("Added pckg "+p);
        }
    }
    
    /**
     * Initialize the list of classes to skip.
     *
     * @param s  a list of classname-patterns separated by the
     *           current system's path separator (":" for Unix,
     *           ";" for DOS), where each pattern is a fully-qualified
     *           classname, as described in {@link FileSpecifier}
     */
    public static void setClassSkipList(String s) {
        boolean trace = false;
        String entrySeparator = System.getProperty("path.separator");
        StringTokenizer lt = new StringTokenizer(s, entrySeparator);
        while (lt.hasMoreTokens()) {
            String listEntry = lt.nextToken();
            if (trace) System.out.println("Adding class "+listEntry);
            FileSpecifier f = new FileSpecifier(listEntry, ".");
            classSkipList.add(f);
            if (trace) System.out.println("Added class "+f);
        }
    }
    
    
    //==================================================================
    // CODE
    //==================================================================
    
    /**
     * DocLet-mandated start method. Everything begins here.
     *
     * @param root  a RootDoc object passed by JavaDoc
     * @return true if document generation succeeds
     */
    public static boolean start(RootDoc root)
    {
        // Set directory-separator to backslash for Windows systems
        if (eol.equals("\r\n")) separator = '\\';
        if (outputDir != "") {
            pathPrefix = outputDir + separator;
        }
        
        if (classlist) {
            // Create the PrintWriter object for listing error-containing classes
            String outputFile = classListFile;
            if (outputDir != null) {
                // Create the pathname for the file.
                // First, determine the proper separator.
                outputFile  = outputDir + separator + outputFile;
            }
            // Create the printWriter object
            try {
                File dir = new File(outputDir);
                if (!dir.exists()) dir.createNewFile();
                
                FileOutputStream fos = new FileOutputStream(outputFile);
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                listFile = new PrintWriter(bos);
            }
            catch (IOException e) {
                //System.out.println("IO ERROR OCCURRED");
                System.err.println("IO Error while attempting to create "+outputFile);
                System.err.println("Error: "+ e.getMessage());
                System.exit(1);
            }
        }
        (new DocCheck()).startGeneration(root);
        if (classlist) {
            listFile.flush();
            listFile.close();   // needed to write!
        }
        return true;
    }
    
    /**
     * Find errors and generate error messages for each
     * package and class specified on the command line.
     *
     * @param root  the RootDoc object passed by JavaDoc
     */
    protected void startGeneration(RootDoc root)
    {
        boolean trace = false;
        if (trace) System.out.println("#pkgs="+root.specifiedPackages().length);
        if (root.specifiedPackages().length != 0) {
            processPackages(root.specifiedPackages());
        }
        if (trace) System.out.println("#classes="+root.specifiedClasses().length);
        if (root.specifiedClasses().length != 0) {
            PkgTracker anon = new PkgTracker("(anonymous)");
            processClasses(root.specifiedClasses(), false, anon);
            totalErrors.addSub(anon);
        }
        printErrorPages();
    }
    
    protected List groupList = new LinkedList();
    protected List majorErrs = new LinkedList();
    protected List minorErrs = new LinkedList();
    protected List noErrs    = new LinkedList();
    protected String windowTitle = "";
    
    public void printErrorPages() {
        boolean trace = false;
        
        // Adjust title strings
        if (versionTitle != "") {
            windowTitle = versionTitle + " ";
            versionTitle = "<br>for " + versionTitle;
        }
        
        // Set up package groups
        ListIterator pkgs = totalErrors.subIterator();
        PKGLOOP:
        while (pkgs.hasNext()) {
            PkgTracker pkg = (PkgTracker) pkgs.next();
            if (trace) System.out.println("pkg="+pkg.name);
            // Check to see if it belongs to an existing group
            // Check from back to front, since packages are usually
            // ordered, which makes a match most likely in the
            // the last group added
            ListIterator glt = groupList.listIterator();
            //        while (glt.hasPrevious()) {
            while (glt.hasNext()) {
                //           PkgGroupTracker g  = (PkgGroupTracker) glt.previous();
                PkgGroupTracker g  = (PkgGroupTracker) glt.next();
                if (trace) System.out.println("Group="+g.name
                                                  +", pkg="+pkg.name
                                                  +", match="+g.match(pkg.name));
                if (g.match(pkg.name)) {
                    g.addSub(pkg);
                    continue PKGLOOP;
                }
            }
            // Construct a new group tracker, where the group name
            // pattern is up to -execDepth packages long.
            String groupName = groupName(pkg.name);
            PkgGroupTracker groupTracker = new PkgGroupTracker(groupName,
                                                               pkgSummary);
            if (trace) System.out.println("--new grouptracker: " + groupTracker.name);
            
            // Add the package to the new group tracker
            // and add the new tracker to the group list
            groupTracker.addSub(pkg);
            groupList.add(groupTracker);
            if (trace) System.out.println("--groupList size=" + groupList.size());
        }
        
        // Set up major/minor/no error lists
        ListIterator groups = groupList.listIterator();
        while (groups.hasNext()) {
            PkgGroupTracker group = (PkgGroupTracker) groups.next();
            if (group.missingCommentErrors() > 0) {
                majorErrs.add(group);
            } else if (group.minorErrors() > 0) {
                minorErrs.add(group);
            } else {
                noErrs.add(group);
            }
        }
        
        printPackageErrors();
        printStatisticsPage();
        printPackageSummary();
        printExecutiveSummary();
        printIndexPage();
    }//printErrorPages
    
    //----------------------------------------------
    // PACKAGE ERROR PAGES
    //----------------------------------------------
    public void printPackageErrors() {
        ListIterator subs = totalErrors.subIterator();
        while (subs.hasNext()) {
            PkgTracker pet = (PkgTracker) subs.next();
            // This operation puts the package-page path in pet
            if (!pet.hasError()) continue;
            printPackagePage(pet);
        }
    }
    
    //----------------------------------------------
    // PACKAGE STATISTICS PAGE
    //----------------------------------------------
    public void printStatisticsPage() {
        HtmlTagWriter h = makeWriter(statsFile);
        startDoc("Package Statistics"+versionTitle,
                 windowTitle+"Package Statistics",
                 h);
        byline(h);
        
        ListIterator plt = totalErrors.subIterator();
        while (plt.hasNext()) {
            PkgTracker pet = (PkgTracker) plt.next();
            checkUnreportedErrors("", pet, h);
        }
        
        h.p();
        h.write("\nFor a high-level overview, see ");
        h.link(execSummary, "Executive Summary");
        h.br();
        h.write("\nFor a summary by package, see ");
        h.link(pkgSummary, "Package Summary");
        
        int pkgCount = PkgTracker.typeCount;
        int clsCount = ClassTracker.typeCount - ClassTracker.innerCount;
        int ifcCount = IfaceTracker.typeCount - IfaceTracker.innerCount;
        int typCount = clsCount + ifcCount;
        int mbrCount = ClassTracker.innerCount
            + IfaceTracker.innerCount
            + FieldTracker.typeCount
            + ConstrTracker.typeCount
            + MethodTracker.typeCount;
        
        h.h3("Items Inspected");
        h.blockquote();
        h.table(1, "94%");
        h.tr();
        h.tdAlign("Right"); h.space(); h.tdEnd();
        h.tdAlignColspan("Center", 2); h.bold("Type"); h.tdEnd();
        h.tdAlignColspan("Center", 5); h.bold("Member"); h.tdEnd();
        h.trEnd();
        h.tr();
        h.tdAlign("Right"); h.bold("Package"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Class"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Iface"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Inner<br>Class"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Inner<br>Iface"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Field"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Constr"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Method"); h.tdEnd();
        h.trEnd();
        h.tr();
        h.dat(pkgCount);
        h.dat(clsCount);
        h.dat(ifcCount);
        h.dat(ClassTracker.innerCount);
        h.dat(IfaceTracker.innerCount);
        h.dat(FieldTracker.typeCount);
        h.dat(ConstrTracker.typeCount);
        h.dat(MethodTracker.typeCount);
        h.trEnd();
        h.tableEnd();
        h.blockquoteEnd();
        
        if (!totalErrors.hasError()) {
            h.h3("No Errors Found!");
            h.blockquote();
            h.println("(Congratulations)");
            h.blockquoteEnd();
        } else {
            h.h3("Breakdown of Errors");
            h.blockquote();
            h.table(1, "94%");
            statsTableHeader("&nbsp;", h);
            // Package Errors
            int a1 = totalErrors.subErrs[PKG_ERR];
            int a3 = totalErrors.subErrs[TAG_ERR];
            int a4 = totalErrors.subErrs[TEXT_ERR];
            int a5 = totalErrors.subErrs[WARNING];
            // Class Errors
            ListIterator pkgs = totalErrors.subIterator();
            int[] classErrors = new int[ERR_CATEGORY_COUNT];
            while (pkgs.hasNext()) {
                // Total up the class errors
                ErrorTracker pet = (ErrorTracker) pkgs.next();
                for (int i=0; i<ERR_CATEGORY_COUNT; i++) {
                    classErrors[i] += pet.subErrs[i];
                }
            }
            int b1 = classErrors[MAJOR_ERR];
            int b3 = classErrors[TAG_ERR];
            int b4 = classErrors[TEXT_ERR];
            int b5 = classErrors[WARNING];
            // Member Errors
            int c2 = totalErrors.errorCount[MAJOR_ERR] // Cumulative
                - totalErrors.subErrs[MAJOR_ERR]  //  - package
                - classErrors[MAJOR_ERR];         //  - class
            int c3 = totalErrors.errorCount[TAG_ERR]   // Cumulative
                - totalErrors.subErrs[TAG_ERR]    //  - package
                - classErrors[TAG_ERR];           //  - class
            int c4 = totalErrors.errorCount[TEXT_ERR]  // Cumulative
                - totalErrors.subErrs[TEXT_ERR]   //  - package
                - classErrors[TEXT_ERR];          //  - class
            int c5 = totalErrors.errorCount[WARNING]   // Cumulative
                - totalErrors.subErrs[WARNING]    //  - package
                - classErrors[WARNING];           //  - class
            statsRow("Percent", h);
            String p1 = ErrorTracker.percentString0(a1, pkgCount);
            String p2 = ErrorTracker.percentString0(a3, pkgCount);
            String p3 = ErrorTracker.percentString0(a4, pkgCount);
            String p4 = ErrorTracker.percentString0(a5, pkgCount);
            stats4p(p1, p2, p3, p4, h);
            p1 = ErrorTracker.percentString0(b1, typCount);
            p2 = ErrorTracker.percentString0(b3, typCount);
            p3 = ErrorTracker.percentString0(b4, typCount);
            p4 = ErrorTracker.percentString0(b5, typCount);
            stats4p(p1, p2, p3, p4, h);
            p1 = ErrorTracker.percentString0(c2, mbrCount);
            p2 = ErrorTracker.percentString0(c3, mbrCount);
            p3 = ErrorTracker.percentString0(c4, mbrCount);
            p4 = ErrorTracker.percentString0(c5, mbrCount);
            stats4p(p1, p2, p3, p4, h);
            statsRowEnd(h);
            statsRow("#w/Errs", h);
            stats4(a1, a3, a4, a5, h);
            stats4(b1, b3, b4, b5, h);
            stats4(c2, c3, c4, c5, h);
            statsRowEnd(h);
            statsRow("Total#", h);
            stats4(pkgCount, h);
            stats4(typCount, h);
            stats4(mbrCount, h);
            statsRowEnd(h);
            h.tableEnd();
            h.blockquoteEnd();
            
            h.h3("Errors by Package");
            h.table(1, "100%");
            summaryTableHeader("&nbsp;", h);
            printStatsSummaryRows(h);
            ListIterator subs = totalErrors.subIterator();
            while (subs.hasNext()) {
                PkgTracker pet = (PkgTracker) subs.next();
                // This operation puts the package-page path in pet
                if (!pet.hasError()) continue;
                pet.printStatsSummaryRow(h);
            }
            h.tableEnd();
        }
        h.println();
        explainStatsPage(h);
        endDoc(h);
    }
    
    /**
     * Print a table row containing summary data.
     *
     * @param level an int specifying the error message level (1..4)
     * @param h an HtmlTagWriter object to write to
     */
    void printStatsSummaryRows(HtmlTagWriter h) {
        int pkgErrs = PkgTracker.noCmtErr;
        int typErrs = totalErrors.errorCount[0] - pkgErrs;
        int ec1 = totalErrors.errorCount[1];
        int ec2 = totalErrors.errorCount[2];
        int ec3 = totalErrors.errorCount[3];
        int ec4 = totalErrors.errorCount[4];
        String name = totalErrors.name;
        h.tr();
        h.td();              h.println(name);           h.tdEnd();
        h.tdAlign("Right");  h.println(pkgErrs);        h.tdEnd();
        h.tdAlign("Right");  h.println(typErrs);        h.tdEnd();
        h.tdAlign("Right");  h.println(ec1);  h.tdEnd();
        h.tdAlign("Right");  h.println(ec2);  h.tdEnd();
        h.tdAlign("Right");  h.println(ec3);  h.tdEnd();
        h.tdAlign("Right");  h.println(ec4);  h.tdEnd();
        h.trEnd();
        
        int pkgCount    = PkgTracker.typeCount;
        int typCount    = ClassTracker.typeCount - ClassTracker.innerCount
            + IfaceTracker.typeCount - IfaceTracker.innerCount;
        int memberCount = ClassTracker.innerCount
            + IfaceTracker.innerCount
            + FieldTracker.typeCount
            + ConstrTracker.typeCount
            + MethodTracker.typeCount;
        int totalCount = pkgCount + typCount + memberCount;
        int taggedCount   = totalCount - FieldTracker.typeCount;
    }
    
    //----------------------------------------------
    // PACKAGE SUMMARY PAGE
    //----------------------------------------------
    public void printPackageSummary() {
        HtmlTagWriter h = makeWriter(pkgSummary);
        startDoc("Package Summary"+versionTitle,
                 windowTitle+"Package Summary",
                 h);
        byline(h);
        h.p();
        h.println("For a high-level overview, see ");
        h.link(execSummary, "Executive Summary");
        h.br();
        h.println("For a statistical breakdown, see ");
        h.link(statsFile, "Package Statistics");
        if (!totalErrors.hasError()) {
            h.h3("No Errors Found!");
            h.blockquote();
            h.println("(Congratulations)");
            h.blockquoteEnd();
        } else {
            ListIterator groups = groupList.listIterator();
            while (groups.hasNext()) {
                PkgGroupTracker group = (PkgGroupTracker) groups.next();
                if (!group.hasError()) continue;
                
                String csw = "20%";    // Column spacer width
                h.anchor(group.linkName);
                h.space(); h.br();
                h.h2(group.name);
                h.table(1, "100%");
                h.tr();
                h.tdWidth(csw);      h.space();          h.tdEnd();
                h.tdAlignColspan("Center", 2);
                h.bold("Missing Comments");    h.tdEnd();
                h.tdWidth(csw);         h.space();          h.tdEnd();
                h.tdAlignColspan("Center", 2);
                h.bold("Minor Errors");        h.tdEnd();
                h.trEnd();
                h.tr();
                h.td();              h.bold("Package");  h.tdEnd();
                h.tdAlign("Right");  h.bold("Number");   h.tdEnd();
                h.tdAlign("Right");  h.bold("Percent");  h.tdEnd();
                h.tdWidth(csw);      h.space();          h.tdEnd();
                h.tdAlign("Right");  h.bold("Number");   h.tdEnd();
                h.tdAlign("Right");  h.bold("Percent");  h.tdEnd();
                h.trEnd();
                ListIterator plt = group.subIterator();
                while (plt.hasNext()) {
                    PkgTracker pkg = (PkgTracker) plt.next();
                    // Don't do this test. List packages w/no errors.
                    // if (!pkg.hasError()) continue;
                    h.tr();
                    pkg.printColFilename(h);
                    pkg.printMajorErrsCols(h);
                    h.td();   h.space();   h.tdEnd();
                    pkg.printMinorErrsCols(h);
                    h.trEnd();
                }
                h.tableEnd();
            }
        }//if totalErrors has error
        explainPkgSummary(h);
        endDoc(h);
    }
    
    //----------------------------------------------
    // EXECUTIVE SUMMARY PAGE
    //----------------------------------------------
    public void printExecutiveSummary() {
        HtmlTagWriter h = makeWriter(execSummary);
        startDoc("Executive Summary"+versionTitle,
                 windowTitle+"Executive Summary",
                 h);
        byline(h);
        h.p();
        h.println("For a summary by package, see ");
        h.link(pkgSummary, "Package Summary");
        h.br();
        h.println("For a statistical breakdown, see ");
        h.link(statsFile, "Package Statistics");
        if (!totalErrors.hasError()) {
            h.h3("No Errors Found!");
            h.blockquote();
            h.println("(Congratulations)");
            h.blockquoteEnd();
        } else {
            String colOneWidth    = "48%";
            String colSpacerWidth = "8%";
            String colTwoWidth    = "44%";
            String tblOneWidth    = "100%";
            String tblTwoWidth    = "100%";
            
            h.br(); h.space();
            h.table(0, "100%");
            h.tr();
            h.tdAlignValignWidth("Center", "Bottom", colOneWidth);
            h.bold("Missing Comments");
            h.tdEnd();
            h.tdWidth(colSpacerWidth);
            h.space();
            h.tdEnd();
            h.tdAlignValignWidth("Center", "Bottom", colTwoWidth);
            h.bold("Minor Errors Only");
            h.tdEnd();
            h.trEnd();
            h.tr();
            h.tdAlignValignWidth("Left", "Top", colOneWidth);
            h.table(1, tblOneWidth);
            h.tr();
            h.td();              h.bold("Package");  h.tdEnd();
            h.tdAlign("Right");  h.bold("Number");   h.tdEnd();
            h.tdAlign("Right");  h.bold("Percent");  h.tdEnd();
            h.trEnd();
            if (majorErrs.size() == 0) {
                h.tr();
                h.td();     h.italics("None!!");  h.tdEnd();
                h.td();     h.space();           h.tdEnd();
                h.td();     h.space();           h.tdEnd();
                h.trEnd();
            } else {
                totalErrors.printMajorErrsRow(h);
                ListIterator plt = majorErrs.listIterator();
                while (plt.hasNext()) {
                    PkgGroupTracker pgt = (PkgGroupTracker) plt.next();
                    pgt.printMajorErrsRow(h);
                }
            }
            h.tableEnd();
            h.tdEnd();
            h.tdWidth(colSpacerWidth);
            h.space();
            h.tdEnd();
            h.tdAlignValignWidth("Left", "Top", colTwoWidth);
            h.table(1, tblTwoWidth);
            h.tr();
            h.td();              h.bold("Package");  h.tdEnd();
            h.tdAlign("Right");  h.bold("Number");   h.tdEnd();
            h.tdAlign("Right");  h.bold("Percent");  h.tdEnd();
            h.trEnd();
            if (minorErrs.size() == 0) {
                h.tr();
                h.td();     h.italics("None!");  h.tdEnd();
                h.td();     h.space();           h.tdEnd();
                h.td();     h.space();           h.tdEnd();
                h.trEnd();
            } else {
                totalErrors.printMinorErrsRow(h);
                ListIterator plt = minorErrs.listIterator();
                while (plt.hasNext()) {
                    PkgGroupTracker pgt = (PkgGroupTracker) plt.next();
                    pgt.printMinorErrsRow(h);
                }
            }
            h.tableEnd();
            h.tdEnd();
            h.trEnd();
            h.tableEnd();
        }//if totalErrors has error
        
        if (noErrs.size() > 0) {
            h.h4("No Errors Found:");
            h.ul();
            ListIterator plt = noErrs.listIterator();
            while (plt.hasNext()) {
                PkgGroupTracker pgt = (PkgGroupTracker) plt.next();
                h.li();
                h.println(pgt.name);
            }
            h.ulEnd();
        }
        explainExecPage(h);
        endDoc(h);
    }
    
    //----------------------------------------------
    // INDEX PAGE
    //----------------------------------------------
    public void printIndexPage() {
        HtmlTagWriter h = makeWriter(mainFile);
        startDoc("Main Page"+versionTitle,
                 windowTitle+"Specification Errors",
                 h);
        byline(h);
        h.h4("Contents");
        h.println("This report contains the following pages:");
        h.dl();
        h.dt();
        h.link(execSummary, "Executive Summary");
        h.dd();
        h.println("Shows the number of missing comments and the percentage ");
        h.println("for package groups (e.g. java.awt.*). Also shows the ");
        h.println("number of minor errors for packages that have no major ");
        h.println("(missing comment) errors.");
        h.dt();
        h.dt();
        h.link(pkgSummary, "Package Summary");
        h.dd();
        h.println("For each package, shows the number of missing comments ");
        h.println("and the number of minor errors, along with percentages.");
        h.dt();
        h.dt();
        h.link(statsFile, "Package Statistics");
        h.dd();
        h.println("Shows the kinds of errors found in each package, ");
        h.println("the number and kind of items that were inspected ");
        h.println("(classes, methods, etc.), and provides a statistical");
        h.println("breakdown of the errors.");
        h.dt();
        h.dlEnd();
        h.h4("References");
        h.link("http://java.sun.com/products/jdk/javadoc/doccheck/DocCheckErrors.html",
               "Errors Identified by DocCheck");
        h.br();
        h.link("http://java.sun.com/products/jdk/javadoc/writingapispecs.html",
               "Requirements for Writing API Specifications");
        h.br();
        h.link("http://java.sun.com/products/jdk/javadoc/writingdoccomments.html",
               "How to Write Doc Comments for Javadoc");
        endDoc(h);
    }
    
    public void byline(HtmlTagWriter h) {
        if (docletID) {
            h.p();
            h.println("Generated by DocCheck doclet, version "
                          + docletVersion +",<br>" + today() + ".");
        }
    }
    
    /**
     * Return the name of the group that a package belongs
     * to, as governed by the -execDepth setting.
     *
     * @param packageName  the full package name
     * @return String      the package group (with no ".*")
     */
    public String groupName(String packageName) {
        StringTokenizer st = new StringTokenizer(packageName, ".");
        String name = st.nextToken();  // 1st token => name
        for (int i=1; i<execDepth; i++) {   // Loop from 2nd token
            if (! st.hasMoreTokens()) break;
            name += "." + st.nextToken();
        }
        return name;
    }
    
    public void printPackagePage(PkgTracker pet) {
        if (!pet.hasError()) return;
        String pkgName = pet.name;
        String relpath = pkgName.replace('.', separator);
        mkdir(relpath);
        relpath = relpath + separator;
        String filename = relpath + errorFile;
        HtmlTagWriter h = makeWriter(filename);
        startDoc("Errors in Package: " + pkgName,
                 "Errors in " + pkgName,
                 h);
        printPkgErrors(pet, h);
        
        // Print the class/interface table
        h.h2("Class/Interface");
        h.table(1, "100%");
        typeTableHeader("Name", h);
        ListIterator subs = pet.subIterator();
        while (subs.hasNext()) {
            ErrorTracker et = (ErrorTracker) subs.next();
            if (!et.hasError()) continue;
            String classfile = printClassPage(pkgName, relpath, et);
            et.printLinkedRow(classfile, h);
        }
        h.tableEnd();
        h.println();
        explainPkgPage(h);
        endDoc(h);
        pet.filepath = filename;  // Save filename for future use
    }
    
    public String printClassPage(String pkgName, String relpath, ErrorTracker et) {
        String filename = et.name+".html";
        HtmlTagWriter h = makeWriter(relpath+filename);
        startDoc("Errors in " + et.typeName + ": " + pkgName + "."+ et.name,
                 "Errors in " + et.name,
                 h);
        printClassErrors(et, h);
        explainClassPage(h);
        endDoc(h);
        return filename;
    }
    
    public void mkdir(String path) {
        if (path == null || path.length() == 0) return;
        File dir = new File(pathPrefix + path);
        try {
            if (dir.exists()) return;
            else {
                // Attempt to create dir, plus any parents
                if (dir.mkdirs()) return;
                else {
                    System.err.println("Unable to create directory: " + path);
                    System.err.println("Check disk space.");
                    System.exit(1);
                }
            }
        } catch (SecurityException exc) {
            System.err.println("Security exception");
            System.err.println("while creating directory: " + path);
            System.err.println("Check access controls.");
            System.exit(1);
        }
    }
    
    public String categoryAnchor(int level, HtmlTagWriter h) {
        return "<a name=err" + level + ">";
    }
    
    public String categoryHeader(int level, String type, HtmlTagWriter h) {
        String result = "";
        if (level == MAJOR_ERR) {
            result = "Category 1: " + type + " Error";
        } else if (level == MEMBER_ERR) {
            result = "Category 2: Member Error";
        } else if (level == TAG_ERR) {
            result = "Category 3: Tag Error";
        } else if (level == TEXT_ERR) {
            result = "Category 4: Text/Link Error";
        } else if (level == WARNING) {
            result = "Category 5: Warning";
        }
        return result;
    }
    
    /**
     * Print errors for a package.
     */
    public void printPkgErrors(ErrorTracker et, HtmlTagWriter h) {
        if (!et.hasError()) return;
        // Print the package-error messages by themselves
        boolean headerPrinted = false;
        for (int i=0; i<ERR_CATEGORY_COUNT; i++) {
            if (et.hasMessage(i)) {
                if (!headerPrinted) {
                    h.h2(et.typeName);
                    headerPrinted = true;
                }
                h.println(categoryAnchor(i, h));
                h.dl();
                h.dt();
                h.println(categoryHeader(i, et.typeName, h));
                h.dd();
                h.table(1, "94%");
                h.tr();
                h.td();
                et.printErrorMessages(i, h);
                h.tdEnd();
                if (et.hasForm(i)) {
                    h.td();
                    et.formPrint(i, h);
                    h.tdEnd();
                }
                h.trEnd();
                h.tableEnd();
                h.ddEnd();
                h.dlEnd();
            }//if
        }//for
    }//printPkgErrors
    
    /**
     * Print errors for a class. Process messages and the
     * sub list for category 1 errors, then category 2, etc.
     */
    public void printClassErrors(ErrorTracker et, HtmlTagWriter h) {
        boolean trace = false;
        if (!et.hasError()) return;
        try {
            if (trace) System.out.println("CLASS ERRORS: "+et.name);
            if (trace) System.out.println("subcount="+et.sub.size());
            if (trace) System.out.println("categorycount="+ERR_CATEGORY_COUNT);
            boolean[] headerPrinted = new boolean[ERR_CATEGORY_COUNT];
            for (int i=0; i<ERR_CATEGORY_COUNT; i++) {
                if (trace) System.out.println("--class messages, level "+i);
                // Print class errors
                if (et.hasMessage(i)) {
                    if (!headerPrinted[i]) {
                        // Put the anchor in its own paragraph to keep
                        // the link target from appearing at the very top
                        // line of the screen when the browser goes to it.
                        h.println(categoryAnchor(i, h)+"\n<br>");
                        h.h2(categoryHeader(i, et.typeName, h));
                        headerPrinted[i] = true;
                    }
                    h.dl();
                    h.dt();
                    h.println(et.typeName + " " + et.name);
                    h.dd();
                    h.table(1, "94%");
                    h.tr();
                    h.td();
                    et.printErrorMessages(i, h);
                    h.tdEnd();
                    if (et.hasForm(i)) {
                        h.td();
                        et.formPrint(i, h);
                        h.tdEnd();
                    }
                    h.trEnd();
                    h.tableEnd();
                    h.ddEnd();
                    h.dlEnd();
                }
                
                // Print member errors
                if (trace) System.out.println("--membr messages, level "+i);
                ListIterator subs = et.subIterator();
                while (subs.hasNext()) {
                    ErrorTracker sub = (ErrorTracker) subs.next();
                    if (!sub.hasError(i)) continue;
                    if (!headerPrinted[i]) {
                        // Put the anchor in its own paragraph to keep
                        // the link target from appearing at the very top
                        // line of the screen when the browser goes to it.
                        h.println(categoryAnchor(i, h)+"\n<br>");
                        h.h2(categoryHeader(i, et.typeName, h));
                        headerPrinted[i] = true;
                    }
                    String prefix = "";
                    printMemberErrors(i, prefix, sub, h);
                }
            }
        } catch (Exception e) {
            System.out.println("UNCAUGHT EXCEPTION");
        }
    }
    
    public void printMemberErrors(int level, String prefix,
                                  ErrorTracker et, HtmlTagWriter h)
    {
        boolean trace = false;
        if (trace) System.out.println("  "+et.name+": printMemberErrors, level "+level);
        if (!et.hasError(level)) {
            if (trace) System.out.println("  --no errors");
            return;
        }
        if (trace) System.out.println("  --printing");
        // Print error messages for this ErrorTracker object
        if (et.hasMessage(level)) {
            printMemberTable(level, prefix, et, h);
        }
        // Recurse to handle its sublist entries
        ListIterator sList = et.subIterator();
        prefix = prefix + et.name + ".";
        while (sList.hasNext()) {
            ErrorTracker sub = (ErrorTracker) sList.next();
            printMemberErrors(level, prefix, sub, h);
        }
    }
    
    boolean bugHeaderPrinted = false;
    /**
     * See if there are any error messages that have not been
     * output.
     *
     * @param h an HtmlTagWriter object to write to
     */
    void checkUnreportedErrors(String prefix, ErrorTracker et, HtmlTagWriter h) {
        for (int i=0; i<ERR_CATEGORY_COUNT; i++) {
            boolean itemHeaderPrinted = false;
            for (int j=0; j<ERR_TYPE_COUNT; j++) {
                if (et.error[i][j]) {
                    if (!bugHeaderPrinted) {
                        bugHeaderPrinted = true;
                        h.h1("DocCheck Bugs");
                        h.dl();
                    }
                    if (!itemHeaderPrinted) {
                        itemHeaderPrinted = true;
                        h.dt();
                        h.println(prefix + et.name);
                    }
                    h.dd();
                    h.println("Level "+i +": Error flag #"+j +" not reported or not cleared.");
                }
            }
        }
        ListIterator subs = et.subIterator();
        while (subs.hasNext()) {
            ErrorTracker sub = (ErrorTracker) subs.next();
            checkUnreportedErrors(prefix+et.name+".", sub, h);
        }
        if (bugHeaderPrinted) h.dlEnd();
    }
    
    public void printMemberTable(int level, String prefix,
                                 ErrorTracker et, HtmlTagWriter h)
    {
        h.dl();
        h.dt();
        h.println(prefix + et.name);
        h.dd();
        h.table(1, "94%");
        h.tr();
        h.td();
        et.printErrorMessages(level, h);
        h.tdEnd();
        h.td();
        et.formPrint(level, h);
        h.tdEnd();
        h.trEnd();
        h.tableEnd();
        h.ddEnd();
        h.dlEnd();
    }
    
    public void summaryTableHeader(String title, HtmlTagWriter h) {
        h.tr();
        h.td();                        h.space();             h.tdEnd();
        h.tdAlignColspan("Center", 3); h.bold("Missing Comments");  h.tdEnd();
        h.tdAlignColspan("Center", 3); h.bold("Minor Errors"); h.tdEnd();
        h.trEnd();
        h.tr();
        h.td();             h.bold(title);         h.tdEnd();
        h.tdAlign("Right"); h.bold("Pkg");         h.tdEnd();
        h.tdAlign("Right"); h.bold("Class/Iface"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Member");      h.tdEnd();
        h.tdAlign("Right"); h.bold("Tag");         h.tdEnd();
        h.tdAlign("Right"); h.bold("Text/Link");   h.tdEnd();
        h.tdAlign("Right"); h.bold("Warning");     h.tdEnd();
        h.trEnd();
    }
    
    public void typeTableHeader(String title, HtmlTagWriter h) {
        h.tr();
        h.td();                        h.space();             h.tdEnd();
        h.tdAlignColspan("Center", 2); h.bold("Missing Comments");  h.tdEnd();
        h.tdAlignColspan("Center", 3); h.bold("Minor Errors"); h.tdEnd();
        h.trEnd();
        h.tr();
        h.td();             h.bold(title);         h.tdEnd();
        h.tdAlign("Right"); h.bold("Class/Iface"); h.tdEnd();
        h.tdAlign("Right"); h.bold("Member");      h.tdEnd();
        h.tdAlign("Right"); h.bold("Tag");         h.tdEnd();
        h.tdAlign("Right"); h.bold("Text/Link");   h.tdEnd();
        h.tdAlign("Right"); h.bold("Warning");     h.tdEnd();
        h.trEnd();
    }
    
    /** Start a statistics row */
    public void statsRow(String s, HtmlTagWriter h) {
        h.tr();
        h.td();
        h.println(s);
        h.tdEnd();
    }
    /** Print 4 percentages (longs) */
    public void stats4p(String n1, String n2, String n3, String n4, HtmlTagWriter h) {
        h.dat(n1);
        h.dat(n2);
        h.dat(n3);
        h.dat(n4);
    }
    /** Print 4 numbers (ints) */
    public void stats4(int n1, int n2, int n3, int n4, HtmlTagWriter h) {
        h.dat(n1);
        h.dat(n2);
        h.dat(n3);
        h.dat(n4);
    }
    public void stats4(int n, HtmlTagWriter h) {
        h.tdAlignColspan("Center", 4);
        if (n==0) h.println("--");
        else h.println(""+n);
        h.tdEnd();
    }
    public void statsRowEnd(HtmlTagWriter h) {
        h.trEnd();
    }
    
    public void statsTableHeader(String title, HtmlTagWriter h) {
        h.tr();
        h.td();
        h.space();
        h.tdEnd();
        
        h.tdAlignColspan("Center", 4);
        h.bold("Pkg");
        h.tdEnd();
        
        h.tdAlignColspan("Center", 4);
        h.bold("Type");
        h.tdEnd();
        
        h.tdAlignColspan("Center", 4);
        h.bold("Member");
        h.tdEnd();
        h.trEnd();
        //-----------------------
        h.tr();
        h.td();
        h.bold(title);
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("NoCmt");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Tag");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Txt/Link");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Warn");
        h.tdEnd();
        //-------------------------
        
        h.tdAlign("Right");
        h.bold("NoCmt");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Tag");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Txt/Link");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Warn");
        h.tdEnd();
        //-------------------------
        h.tdAlign("Right");
        h.bold("NoCmt");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Tag");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Txt/Link");
        h.tdEnd();
        
        h.tdAlign("Right");
        h.bold("Warn");
        h.tdEnd();
        h.trEnd();
    }
    
    public void explainExecPage(HtmlTagWriter h) {
        h.h3("Explanation of Columns");
        h.blockquote();
        h.dl();
        h.dt();
        h.println("<i>Missing Comments</i>");
        h.dd();
        h.println("Shows the number of items that have no comment ");
        h.println("or which have tags but no text.");
        h.dt();
        h.println("<i>Missing Comments Percentage</i>");
        h.dd();
        h.println("Shows the percentage for a group of packages.<br>");
        h.println("For example, 1% for java.security means that.");
        h.println("1% of the security APIs are missing comments.");
        h.dt();
        h.println("<i>Minor Errors</i>");
        h.dd();
        h.println("Shows the number of items that have minor errors.<br>");
        h.println("For example, a method counts as one item, although");
        h.println("it could be missing multiple tags.");
        h.dt();
        h.println("<i>Minor Error Percentages</i>");
        h.dd();
        h.println("Shows the number of items that have minor errors ");
        h.println("divided by the total number of items. ");
        h.dt();
        h.println("<b>Note:</b>");
        h.dd();
        h.println("The Minor Errors table contains only package groups ");
        h.println("that have no major errors.<br>(The total line, however,");
        h.println("shows the total of all minor errors.)");
        h.dlEnd();
        h.blockquoteEnd();
    }
    
    public void explainStatsPage(HtmlTagWriter h) {
        h.h4("Explanation of Terms");
        h.dl();
        //h.dt();
        //h.println("<i>Item</i>");
        //h.dd();
        //h.println("A package, type, or member.");
        h.dt();
        h.println("<i>Type</i>");
        h.dd();
        h.println("An outer class or interface.");
        h.dt();
        h.println("<i>Member</i>");
        h.dd();
        h.println("An inner class, inner interface, field, constructor, or method.");
        h.dlEnd();
    }
    
    public void explainPkgSummary(HtmlTagWriter h) {
        h.blockquote();
        h.println("<b>Note:</b>");
        h.blockquote();
        h.println("The Minor Errors table shows the number of items that, ");
        h.println("have a minor error, rather than the number of errors.");
        h.println("(If there was one method missing 4 tags, this table would ");
        h.println("show \"1\" in the Tags column.)");
        h.blockquoteEnd();
        h.blockquoteEnd();
    }
    
    public void explainPkgPage(HtmlTagWriter h) {
        h.h4("Explanation of Terms");
        h.dl();
        h.dt();
        h.println("<i>Member</i>");
        h.dd();
        h.println("An inner class, inner interface, field, constructor, or method.");
        h.dt();
        h.bold("Note:");
        h.dd();
        h.println("This table shows total numbers for the minor errors, ");
        h.println("rather than the number of items that have such an error.");
        h.println("(If there was one method missing 4 tags, this table would ");
        h.println("show \"4\" in the Tags column.)");
        h.dlEnd();
    }
    
    public void explainClassPage(HtmlTagWriter h) {
        h.h4("Explanation of Columns");
        h.dl();
        h.dt();
        h.println("<i>Left Column</i>");
        h.dd();
        h.println("Identifies the error or warning.");
        h.dt();
        h.println("<i>Right Column</i>");
        h.dd();
        h.println("Shows the comment-text that generated the error in red.");
        h.br();
        h.println("Displays a template you can cut and paste in black.");
        h.dlEnd();
    }
    
    /**
     * Create an HtmlTagWriter using the encoding-specification
     * that JavaDoc so kindly left for us in the static
     * Configuration class.
     *
     * @param filename  a path to a file, relative to the
     *                  output directory.
     */
    public HtmlTagWriter makeWriter(String filename) {
        HtmlTagWriter h = null;
        String path = pathPrefix + filename;
        try {
            // Create an HtmlTagWriter using the default encoding
            h = new HtmlTagWriter(path, null);
        } catch (java.io.IOException e) {
            System.err.println("Error creating "+path);
            System.err.println("  --" + e.getMessage());
            System.exit(1);
        }
        return h;
    }
    
    /**
     * Get the day and date information for today.
     * Uses:<ul>
     *   <li>java.util.Calender
     *   <li>java.util.GregorianCalendar
     *   <li>java.util.TimeZone
     *  </ul>
     *
     * @return String Today.
     */
    public String today() {
        Calendar calendar = new GregorianCalendar(TimeZone.getDefault());
        Date d = calendar.getTime();
        SimpleDateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy");
        return df.format(d);
    }
    
    /**
     * Print the Html file header.
     *
     * @param windowTitle    Title of this HTML document.
     */
    public void startDoc(String pageTitle, String windowTitle, HtmlTagWriter h) {
        //println("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 " +
        //        "Transitional//EN\"" +
        //        "\"http://www.w3.org/TR/REC-html40/loose.dtd>");
        //println("<!--NewPage-->");
        h.html();
        h.head();
        h.print("<!-- Generated by DocCheck on ");
        h.print(today());
        h.println("-->");
        h.title();
        h.println(windowTitle);
        h.titleEnd();
        h.headEnd();
        h.body("white");
        h.h1("API Specification Errors<br>"+pageTitle);
    }
    
    /**
     * Finish the Html file.
     */
    public void endDoc(HtmlTagWriter h) {
        h.bodyEnd();
        h.htmlEnd();
        h.flush();
        h.close();  // needed to get written to disk!
    }
    
    /**
     * Process each package and the classes/interfaces within it.
     *
     * @param pd  an array of PackageDoc objects
     */
    public void processPackages(PackageDoc[] pd)
    {
        boolean trace = false;
        if (trace) System.out.println("PROCESSING PACKAGES, number="+pd.length);
        PKGLOOP:
        for (int i = 0; i < pd.length; i++)
        {
            String pkgName = pd[i].name();
            if (trace) System.out.println("PROCESSING PACKAGE: "+pkgName);
            
            // Check skip list
            ListIterator slt = pkgSkipList.listIterator();
            while (slt.hasNext()) {
                // Package specifications are always fully qualified.
                PathSpecifier skip = (PathSpecifier) slt.next();
                boolean skipThis = skip.match(pd[i].name(), ".");
                if (trace) System.out.println("Comparing to " + skip + ": " + skipThis);
                if (skipThis) {
                    // Skip this package
                    continue PKGLOOP;
                }
            }
            
            // Package error tracker
            ErrorTracker pet = new PkgTracker(pkgName);
            String data = pd[i].commentText();
            if ((data == null) || data.equals("")) {
                pet.addErr(PKG_ERR, NO_COMMENT);
            } else {
                boolean anyError = false;
                anyError = checkFirstSentence(data, pet);
                if (!anyError) {
                    // Rather than checking only the body, we need to
                    // recheck the entire comment. Reason: The first
                    // sentence can end with a period and end of line,
                    // with </p> on the line below. When we check the
                    // "body" by itself, the </p> is sent, which produces
                    // a bogus "extraneous tag" error. Either body()
                    // must become smarter, or we need to check the
                    // comment. (That's ok, because we only do so when
                    // there are no errors in the first sentence.)
                    //anyError = checkHTML(body(data), pet);
                    anyError = checkHTML(data, pet);
                    if (anyError) {
                        pet.addErr(TEXT_ERR, HTML_BODY);
                    }
                }
                int tagCount = pd[i].tags("since").length;
                if (tagCount <= 0) {
                    pet.addErr(TAG_ERR, NO_SINCE);
                }
            }
            List classList = new LinkedList(Arrays.asList(pd[i].allClasses()));
            
            // Filter out classes which are not public
            //TODO
            
            Collections.sort(classList);
            ClassDoc[] classes = new ClassDoc[classList.size()];
            classes = (ClassDoc[])classList.toArray(classes);
            processClasses(classes, false, pet);
            totalErrors.addSub(pet);
        }
    } // processPackages
    
    /**
     * Process classes. Listed classes are those that were listed on the
     * command line. Names of such classes are always output. Unlisted
     * classes are contained in specified packages. Names of these classes
     * are only listed if there was an error.
     * <p>
     * Ideally, we would process all members of the class in the order
     * they are specified in the file. However, we can only approximate
     * that order. JavaDoc gives us fields, constructors, methods, and
     * inner classes. Each of those groupings is in file order, and the
     * the fields/constructors/methods/innerClasses is the most
     * frequently found ordering of the groups. [Future: provide an option
     * to control ordering.]
     *
     * @param cd      an array of ClassDoc objects
     * @param inner   a boolean -- true if ...
     * @param owner   the ErrorTracker object collecting the errors
     * @return true if ...
     */
    public boolean processClasses(ClassDoc[] cd,
                                  boolean inner,
                                  ErrorTracker owner)  // owner=pkg or outer class
    {
        boolean trace = false;
        if (trace) System.out.println("PROCESSING CLASSES, number="+cd.length);
        boolean anyError = false;
        CLASSLOOP:
        for (int i = 0; i < cd.length; i++)
        {
            if (trace) System.out.println("PROCESSING CLASS/IFC: "+cd[i].name());
            int errorLevel = CLASS_ERR;
            
            // Check skip list
            ListIterator slt = classSkipList.listIterator();
            while (slt.hasNext()) {
                // Class name in skip list must be fully qualified
                FileSpecifier skip = (FileSpecifier) slt.next();
                if (skip.match(qualifiedName(cd[i]), ".") ) {
                    // Skip this class
                    continue CLASSLOOP;
                }
            }
            
            if (cd[i].containingClass() != null) {
                // This is an inner class sent by JavaDoc.
                if (!inner) {
                    // Ignore it.
                    // Inner classes and interfaces are
                    // We handle them at the end of this method
                    // when we recurse on innerClasses().
                    //System.out.println(name(cd[i])+"--IGNORING");
                    continue;
                }
                if (trace) System.out.println("--Inner class/ifc "+cd[i].name());
                errorLevel = INNER_ERR;
            }
            // This one is just to satisfy the compiler that it gets a value.
            ErrorTracker clet = new ErrorTracker("TEMP","TEMP");
            if (cd[i].isInterface()) {
                // Create a new interface item and increment the owner's subcount
                clet = new IfaceTracker(name(cd[i]), owner);
            } else {
                // Create a new class item and increment the owner's subcount
                clet = new ClassTracker(name(cd[i]), owner);
            }
            boolean noComment = false;
            boolean noText = false;
            boolean tagError = false;
            boolean printed = false;
            boolean classError = false;
            boolean s1Error = false; // First sentence html error
            String data = cd[i].getRawCommentText();
            String text = cd[i].commentText();
            if ((data == null) || data.equals("")) {
                if (trace) System.out.println("--no data for class/iface");
                classError = noComment = true;
                clet.addErr(errorLevel, NO_COMMENT);
                clet.formStart(errorLevel);
                firstLine(errorLevel, cd[i], clet);
                if (cd[i].containingClass() == null) {
                    // Add tags for outer classes
                    clet.formTag(errorLevel, " * @author " + author, CLASS_TAG);
                    clet.formTag(errorLevel, " * @version " + version, CLASS_TAG);
                }
                clet.formEnd(errorLevel);
            } else if ((text == null) || text.equals("")) {
                if (trace) System.out.println("--no text for class/iface");
                classError = noText = true;
                clet.addErr(errorLevel, NO_TEXT);
                firstLine(errorLevel, cd[i], clet);
                if (cd[i].containingClass() == null) {
                    if (!noComment && cd[i].isClass() ) {
                        // Check for class tags.
                        tagError = checkTags(TAG_ERR, cd[i], clet);
                        classError |= tagError;
                    }
                }
            } else {
                if (trace) System.out.println("--checking 1st sentence for class/iface");
                s1Error = checkFirstSentence(text, clet);
                classError |= s1Error;
            }
            if (!s1Error && !noComment && !noText) {
                if (trace) System.out.println("--checking body of comment for class/iface");
                // Check for unterminated HTML
                //boolean bodyError = checkHTML(body(cd[i].commentText()), clet);
                boolean bodyError = checkHTML(cd[i].commentText(), clet);
                classError |= bodyError;
                if (bodyError) {
                    clet.addErr(TEXT_ERR, HTML_BODY);
                }
            }
            
            // Process class members. (Treat inner classes as members.)
            boolean memberError = false;
            memberError  = processFields(cd[i].fields(), clet);
            memberError |= processConstructors(cd[i].constructors(), clet);
            memberError |= processMethods(cd[i], cd[i].methods(), clet);
            memberError |= processClasses(cd[i].innerClasses(), true, clet);
            classError  |= memberError;
            anyError |= classError;
            
            // Add outermost class to list of classes with errors
            // if the -classlist option was specified and there was an error
            if (classlist && classError && cd[i].containingClass() == null) {
                if (trace) System.out.println("--adding class/iface to listfile");
                // Add this class to the list of classes containing errors.
                // Use the specified EOL character, rather than the system-specific value.
                listFile.print(qualifiedName(cd[i]));
                listFile.print(eol);
            }
            if (trace & clet.hasError()) {
                System.out.println("--adding class/iface " + clet.name + " to " + owner.name);
                System.out.println("Errors:");
                System.out.println("  CLS: "+clet.hasError(0));
                System.out.println("  MBR: "+clet.hasError(1));
                System.out.println("  TAG: "+clet.hasError(2));
                System.out.println("  TXT: "+clet.hasError(3));
                System.out.println("  WRN: "+clet.hasError(4));
            }
            owner.addSub(clet);
        }//for
        return anyError;
        
    }//processClasses()
    
    
    /**
     * Check the first sentence for correctness.
     *
     * @param text  the text containing the first sentence
     * @param et    the ErrorTracker object collecting the errors
     */
    public boolean checkFirstSentence(String text, ErrorTracker et)
    {
        boolean trace=false;
        boolean anyError = false;
        String s1 = ""; // first sentence
        
        if (trace) {
            String echoText = text;
            if (text.length() > 40) echoText = text.substring(0,40);
            System.out.println("--text="+echoText);
        }
        int index = endOfFirstSentence(text);
        if (index == -1) {
            if (trace) System.out.println("--no period");
            s1 = text;
            et.addErr(TEXT_ERR, HTML_FIRST);
            et.addErr(TEXT_ERR, HTML_NO_PERIOD);
            et.formLine(TEXT_ERR, htmlCode(text));
            anyError = true;
        } else {
            s1 = text.substring(0, index+1);
            if (trace) System.out.println("--first sentence="+s1);
        }
        anyError |= checkHTML(s1, et);
        if (anyError) {
            et.addErr(TEXT_ERR, HTML_FIRST);
            return true;
        }
        if (trace) System.out.println("--looking for lists");
        int listIndex = s1.indexOf("<ul>");
        if (listIndex == -1) listIndex = s1.indexOf("<ol>");
        if (listIndex > -1) {
            et.addErr(TEXT_ERR, HTML_FIRST);
            et.addErr(TEXT_ERR, HTML_LIST);
            index = Math.max(0, listIndex-20);
            et.formLine(TEXT_ERR, htmlCode(text.substring(index)));
            anyError = true;
        }
        return anyError;
        
    }//checkFirstSentence
    
    
    /**
     * Returns displayable HTML code, with <'s converted to &lt;
     * and >'s converted to &gt;. Brackets the returned text
     * inside of </pre>...<pre> tags so that the HTML lines wrap,
     * instead of following the "preformatted text" arrangement
     * of other generated tags.
     */
    String htmlCode(String s) {
        StringBuffer tb = new StringBuffer(squashBlanks(s));
        int len = tb.length();
        for (int i=0; i<len; i++) {
            // Replace < with &lt;
            if (tb.charAt(i) == '<') {
                // End index of replace is exclusive
                tb.replace(i,i+1,"&lt;");
                i += 3;
                len += 3;
            }
            // Replace > with &gt;
            if (tb.charAt(i) == '>') {
                // End index of replace is exclusive
                tb.replace(i,i+1,"&gt;");
                i += 3;
                len += 3;
            }
        }
        // Turn off the preformat text at the start of html code,
        // and turn it back on again afterwards.
        tb.insert(0, "</pre><b><font color=\""+ ErrorTracker.badTextColor +"\">");
        tb.append("</font></b><pre>");
        return tb.toString();
    }
    
    /**
     * Return the index that identifies the end of the first sentence.
     * @param text  the text to check
     * @return an int pointing the end of the sentence, or -1 if end
     *         of sentence is not found.
     */
    public int endOfFirstSentence(String text)
    {
        int index = -1;  // Use the brute force approach.
        index = minIndex(index, text.indexOf("? " ));
        index = minIndex(index, text.indexOf("?\t"));
        index = minIndex(index, text.indexOf("?\n"));
        index = minIndex(index, text.indexOf("?\r"));
        index = minIndex(index, text.indexOf("?\f"));
        index = minIndex(index, text.indexOf("! " ));
        index = minIndex(index, text.indexOf("!\t"));
        index = minIndex(index, text.indexOf("!\n"));
        index = minIndex(index, text.indexOf("!\r"));
        index = minIndex(index, text.indexOf("!\f"));
        index = minIndex(index, text.indexOf(". " ));
        index = minIndex(index, text.indexOf(".\t"));
        index = minIndex(index, text.indexOf(".\n"));
        index = minIndex(index, text.indexOf(".\r"));
        index = minIndex(index, text.indexOf(".\f"));
        
        // Look for a sentence terminated by an HTML tag.
        index = minIndex(index, text.indexOf(".<"));
        if (index == -1) {
            // If period-whitespace was not found, check to see if
            // last character is a period,
            int endIndex = text.length()-1;
            if ((text.charAt(endIndex) == '.')
                ||  (text.charAt(endIndex) == '?')
                ||  (text.charAt(endIndex) == '!')) index = endIndex;
        }
        return index;
    } //endOfFirstSentence
    
    /**
     * Return the minimum of two indexes if > -1, and return -1
     * only if both indexes = -1.
     * @param i an int index
     * @param j an int index
     * @return an int equal to the minimum index > -1, or -1
     */
    public int minIndex(int i, int j) {
        if (i == -1) return j;
        if (j == -1) return i;
        return Math.min(i,j);
    }
    
    // NOT USED.
    // This function produces incorrect results for comemnts
    // like:
    //   * <p>
    //   * This is the first sentence.
    //   * </p>
    // Because the endOfFirstSentence identifies the period-EOL
    // combination as the end of the first sentence. That means
    // the </p> is the first part of the "body". If this function
    // can be improved to fix that defect, it can be reenabled.
    /**
     * Return the body of the text (all except the first sentence).
     * @param text  the text to check
     * @return the String containing all but the first sentence.
     */
    //public String body(String text) {
    //  if (text == null || text == "") return "";
    //  int index = endOfFirstSentence(text);
    //  if (index == -1) return "";              // no first sentence found
    //  if (index == text.length()-1) return ""; // first sentence = all of comment
    //  return text.substring(index+1);
    //}
    
    /**
     * Check text for incomplete html tags.
     *
     * @param text  the text to check
     * @param et    the ErrorTracker object collecting the errors
     */
    public boolean checkHTML(String text, ErrorTracker et)
    {
        boolean trace = false;
        if (trace) {
            String echoText = text;
            if (text.length() > 40) echoText = text.substring(0,40);
            System.out.println("--checkHTML: "+echoText);
        }
        //           if (trace) {   // View stack
        //              System.out.println("htmlStack 2:");
        //              for (int i=0; i<htmlStack.size(); i++) {
        //                 HtmlTag tmp = (HtmlTag) htmlStack.elementAt(i);
        //                 System.out.println("    "+tmp.id);
        //              }
        //           }
        
        SortedSet errorList = new TreeSet();
        //boolean anyError = false;
        boolean extraError = false;
        int position = 0;
        String msgText = "";
        String extraMsgText = "";
        String token = "";
        HtmlTag lastHtmlTag = null;
        java.util.Stack htmlStack = new java.util.Stack();
        StringTokenizer st = new StringTokenizer(text, " \t\n\r\f<>", true);
        while (st.hasMoreTokens()) {
            // Get next token. Keep track of current position in the string by
            // adding the length of the tokens, until an error occurs. Use the
            // saved position to output a line of text that helps to identify
            // the error.
            token = st.nextToken();
            position += token.length();
            
            if (token.equals("<")) {
                try {
                    token = st.nextToken();
                    position += token.length();
                } catch (Exception e) {
                    return reportErrors(errorList, et);
                }
                if (trace) System.out.println("--token="+token);
                if ( ((token.charAt(0) >= 'A') && (token.charAt(0) <= 'Z'))
                    ||   ((token.charAt(0) >= 'a') && (token.charAt(0) <= 'z')) )
                {
                    // If a character follows the <-sign, assume its html
                    // The non-html version is "&lt;"
                    // Point before the angle bracket
                    int startOfTag = position - token.length() - 1;
                    lastHtmlTag = new HtmlTag(token, startOfTag, text);
                    htmlStack.push(lastHtmlTag);
                    //NOTE: NEED A CHECK HERE TO IDENTIFY < or > with no other
                    //      half -- indicates a need for &lt; / & gt;
                    continue;
                }
                if (token.charAt(0) == '/') {
                    token = token.substring(1);
                    boolean extra = true;
                    for (int i=0; i<htmlStack.size(); i++) {
                        // Loop, looking for tags that are closed.
                        // The loop is needed in case there are unclosed
                        // tags on the stack. In that case, the stack would
                        // not be empty, but this tag would still be extra.
                        HtmlTag td = (HtmlTag) htmlStack.elementAt(i);
                        if (token.equalsIgnoreCase(td.id)) {
                            extra = false;
                            break;
                        }
                    }
                    if (extra) {
                        int startOfTag = position - token.length() - 2;
                        HtmlTag h = new HtmlTag("/"+token, startOfTag, text);
                        h.error = HTML_EXTRA;
                        errorList.add(h);
                        continue;
                    }
                    try {
                        Stack unclosedTags = new Stack();
                        HtmlTag lastOpenTag  = (HtmlTag) htmlStack.pop();
                        TOKEN_TEST:
                        while (!token.equalsIgnoreCase(lastOpenTag.id)) {
                            // Find unclosed elements. Put them on a stack so the
                            // output order won't be back-to-front.
                            for (int i=0; i<singleTag.length; i++) {
                                // If its a singleton tag (<p>, <br>, etc.), ignore it
                                // Can't simply not put them on the stack, since singletons
                                // like <dt> and <dd> (unhappily) may either be terminated
                                // or not terminated. Both options are legal.
                                if (lastOpenTag.id.equalsIgnoreCase(singleTag[i])) {
                                    lastOpenTag  = (HtmlTag) htmlStack.pop();
                                    continue TOKEN_TEST;
                                }
                            }
                            unclosedTags.push(lastOpenTag);
                            lastOpenTag = (HtmlTag) htmlStack.pop();
                        }// end while
                        // Output the unterminated tags, if any
                        String lastFound = "";  // Skip multiples, like <b>..<b>
                        for (int i=0; i<unclosedTags.size(); i++) {
                            lastOpenTag = (HtmlTag) unclosedTags.get(i);
                            if (lastOpenTag.id.equals(lastFound)) {
                                continue;
                            }
                            lastFound = lastOpenTag.id;
                            lastOpenTag.error = HTML_UNCLOSED;
                            errorList.add(lastOpenTag);
                            continue;
                        }//end for
                    } catch (Exception e) {
                        // EmptyStackException or some strange token like "/".
                        // Start processing the next token.
                        continue;
                    }
                }//token=="/"
            }//token=="<"
        } //end: while more tokens exist
        
        // Identify any tags left on the stack.
        String lastFound = "";  // Skip multiples, like <b>...<b>
        STACK_CHECK:
        for (int i=0; i<htmlStack.size(); i++) {
            HtmlTag htag = (HtmlTag) htmlStack.elementAt(i);
            for (int j=0; j<singleTag.length; j++) {
                // If its a singleton tag (<p>, <br>, etc.), ignore it
                // Can't simply not put them on the stack, since singletons
                // like <dt> and <dd> (unhappily) may either be terminated
                // or not terminated. Both options are legal.
                if (htag.id.equalsIgnoreCase(singleTag[j])) continue STACK_CHECK;
            }
            if (htag.id.equals(lastFound)) continue;
            lastFound = htag.id;
            htag.error = HTML_UNCLOSED;
            errorList.add(htag);
        }
        return reportErrors(errorList, et);
    } //checkHTML
    
    // Reports errors in position order.
    // Returns true if there are any errors in the error list
    // Accumulate multiple errors of same type on a single line:
    //    Unclosed Html: <ul>, <table>
    // But only do so as long as they are consecutive. Start a
    // new line when a different kind of error arises, so output
    // looks like:
    //    Unclosed Html: <ul>, <table>
    //    Extra Html: </p>, </b>
    //    Unclosed Html: <ul>
    public boolean reportErrors(SortedSet errorList, ErrorTracker et) {
        if (errorList.size() == 0) return false;
        et.addErr(TEXT_ERR, HTML_ERROR);
        et.addHtmlErrLine(TEXT_ERR, "<ul>");
        
        boolean firstUnclosedError = true;
        boolean firstExtraError   = true;
        String msgText = "";
        
        Iterator errors = errorList.iterator();
        while (errors.hasNext()) {
            HtmlTag t = (HtmlTag) errors.next();
            if (t.error == HTML_UNCLOSED) {
                if (firstUnclosedError) {
                    firstUnclosedError = false;
                    firstExtraError = true;
                    if (msgText != "") et.addHtmlErrLine(TEXT_ERR, msgText);
                    msgText = "<li>Unclosed HTML: ";
                } else {
                    msgText += ", ";
                }
                msgText += "&lt;" + t.id + "&gt;";
                et.formLine(TEXT_ERR, t.code());
            } else if (t.error == HTML_EXTRA) {
                if (firstExtraError) {
                    firstExtraError = false;
                    firstUnclosedError = true;
                    if (msgText != "") et.addHtmlErrLine(TEXT_ERR, msgText);
                    msgText = "<li>Extra HTML: ";
                } else {
                    msgText += ", ";
                }
                msgText += "&lt;" + t.id + "&gt;";
                et.formLine(TEXT_ERR, t.code() );
            } else {
                System.err.println("Unexpected error type: "+t.error);
                System.err.println("accompanying tag: "+t.id);
                System.err.println("in text: "+t.code());
                System.err.println("Please report.");
            }
        }
        if (msgText != "") {
            et.addHtmlErrLine(TEXT_ERR, msgText);
        }
        et.addHtmlErrLine(TEXT_ERR, "</ul>");
        return true;
    }
    
    /**
     * An inner class used to keep track of a tag and up to
     * 60 characters that follow it.
     */
    public class HtmlTag implements Comparable {
        String id    = "";
        int position = 0;
        String text  = "";
        int error = -1;
        
        HtmlTag(String anId, int aPosition, String theText) {
            id = anId;
            position = aPosition;
            text = theText;
        }
        
        // Return a string of up to 60 characters starting from
        // the position of this tag
        String code() {
            int startOfText = position;
            int endOfText = Math.min(startOfText + 60, text.length());
            return htmlCode(text.substring(startOfText, endOfText));
        }
        
        // Comparable interface, so a list of these objects can be sorted.
        public int compareTo(Object o) {
            HtmlTag t = (HtmlTag) o;
            if (this.position < t.position) return -1;
            if (this.position > t.position) return +1;
            return 0;
        }
    }
    
    /**
     * Compress multiple spaces down to one.
     * @param s  the string to squash
     */
    public String squashBlanks(String s)
    {
        s = s.replace('\n',' ');
        s = s.replace('\r',' ');
        s = s.replace('\f',' ');
        s = s.replace('\t',' ');
        StringBuffer sb = new StringBuffer(s);
        boolean spaceFound = false;
        for (int i=0; i<sb.length(); i++) {
            if (sb.charAt(i) == ' ') {
                if (spaceFound) sb.deleteCharAt(i);
                else spaceFound = true;
            } else {
                spaceFound = false;
            }
        }
        return sb.toString();
    }//squashBlanks
    
    /**
     * Return a string containing the non-qualified class name that uses
     * "$" to separate inner classes from outer classes instead of ".".
     *
     * @return a String containing the non-qualified name
     */
    public String name(ClassDoc cd) {
        String s = cd.name();
        return(s.replace('.','$'));
    }
    
    /**
     * Return a string containing the qualified class name that uses
     * "$" to separate inner classes from outer classes instead of ".".
     *
     * @return a String containing the qualified name
     */
    public String qualifiedName(ClassDoc cd) {
        PackageDoc pd = cd.containingPackage();
        return pd.name() + "." + name(cd);
    }
    
    /**
     * Process the fields in the class.
     *
     * @param fd      an array of FieldDoc objects
     * @param clet    the ErrorTracker object collecting the errors
     * @return true if the processing succeeded
     */
    public boolean processFields(FieldDoc[] fd, ErrorTracker clet)
    {
        boolean trace = false;
        if (trace) System.out.println("PROCESSING FIELDS, number="+fd.length);
        boolean anyError = false;
        for (int i = 0; i < fd.length; i++) {
            // Check to see if the field should be excluded
            //TODO
            
            ErrorTracker fet = new FieldTracker(fd[i].name(), clet);
            boolean noComment = false;
            boolean noText = false;
            boolean s1Error = false;
            String data = fd[i].getRawCommentText();
            if ( (data == null) || data.equals("") ) {
                noComment = true;
                fet.addErr(FIELD_ERR, NO_COMMENT);
                fet.formLine(FIELD_ERR, "/**  */");
            } else {
                data = fd[i].commentText();
                if ((data == null) || data.equals("")) {
                    noText = true;
                    fet.addErr(FIELD_ERR, NO_TEXT);
                    fet.formLine(FIELD_ERR, " * ");
                } else {
                    s1Error = checkFirstSentence(data, fet);
                }
            }
            boolean htmlError = false;
            if (!s1Error && !noComment && !noText) {
                //htmlError = checkHTML(body(fd[i].commentText()), fet);
                htmlError = checkHTML(fd[i].commentText(), fet);
                if (htmlError) {
                    fet.addErr(TEXT_ERR, HTML_BODY);
                }
            }
            anyError |= noComment || noText || s1Error || htmlError;
            clet.addSub(fet);
        }
        return anyError;
        
    }//processFields()
    
    /**
     * Process the constructors in a class.
     *
     * @param cd      an array of ConstructorDoc objects
     * @param clet    the ErrorTracker object collecting the errors
     * @return true if the processing succeeded
     */
    public boolean processConstructors(ConstructorDoc[] cd, ErrorTracker clet)
    {
        boolean trace = false;
        if (trace) System.out.println("PROCESSING CONSTRUCTORS, number="+cd.length);
        boolean anyError = false;
        for (int i = 0; i < cd.length; i++)
        {
            if (trace) System.out.println("PROCESSING CONSTRUCTOR: "+cd[i].name());
            
            // Check to see if the constructor should be excluded
            //TODO
            
            ErrorTracker cnet = new ConstrTracker(signature(cd[i]), clet);
            boolean noComment = false;
            boolean noText = false;
            boolean tagError = false;
            boolean s1Error = false;
            String data = cd[i].getRawCommentText();
            
            // Remove arguments added by the compiler. This step is
            // necessary for inner class constructors in JavaDoc 1.3.
            // In that version, JavaDoc passes on the outer-class
            // argument that is sent to the inner class. That argument
            // is what the inner class uses to access the outer-class
            // fields when "this" is referenced in the inner class.
            // Note: Create a linked list so we can use the remove operation.
            List paramList = new LinkedList(Arrays.asList(cd[i].parameters()));
            ListIterator lit = paramList.listIterator();
            while (lit.hasNext()) {
                Parameter param = (Parameter) lit.next();
                if (param.name().startsWith("this$")) lit.remove();
            }
            if ((data == null) || data.equals("")) {
                // No doc comment.
                if ((cd.length == 1) && (paramList.size() == 0)) {
                    // If there is only one constructor and it has no
                    // arguments, assume that it is the implicit constructor.
                    // That works most of the time. But to know for sure,
                    // JavaDoc needs an isImplicit() method in ConstrucorDoc.
                    cnet.addErr(CONSTR_ERR, DEFAULT_CONSTR);
                    continue;
                }
                noComment = true;
                cnet.addErr(CONSTR_ERR, NO_COMMENT);
            } else {
                data = cd[i].commentText();
                if ((data == null) || data.equals("")) {
                    noText = true;
                    cnet.addErr(CONSTR_ERR, NO_TEXT);
                    firstLine(CONSTR_ERR, cd[i], cnet);
                } else {
                    s1Error = checkFirstSentence(data, cnet);
                }
            }
            if (noComment) {
                // Add class-start line if no comment at all
                cnet.formStart(CONSTR_ERR);
                firstLine(CONSTR_ERR, cd[i], cnet);
            }
            boolean htmlError = false;
            if (!s1Error && !noComment && !noText) {
                //htmlError = checkHTML(body(cd[i].commentText()), cnet);
                htmlError = checkHTML(cd[i].commentText(), cnet);
                if (htmlError) {
                    cnet.addErr(TEXT_ERR, HTML_BODY);
                }
            }
            int tagCount = cd[i].paramTags().length;
            if (noComment) {
                // Use checkTags() to generate tags
                tagError = checkTags(CONSTR_ERR, cd[i], cnet);
            } else if (noText && tagCount == 0) {
                // If there was no text and no params, this may be a blank comment
                // In that case, generate any tags that are needed.
                tagError = checkTags(CONSTR_ERR, cd[i], cnet);
            } else {
                // Check tags when comment &/or tags exist
                tagError = checkTags(TAG_ERR, cd[i], cnet);
            }
            if (noComment) {
                // Finish the class-start line if there was no comment
                cnet.formEnd(CONSTR_ERR);
            }
            anyError |= noComment || noText || tagError || s1Error || htmlError;
            clet.addSub(cnet);
        }
        //System.out.println("FINISHED CONSTRUCTORS: anyError="+anyError);
        return anyError;
        
    }//processConstructors()
    
    /**
     * Process the methods in a class.
     *
     * @param md      an array of MethodDoc objects
     * @param clet    the ErrorTracker object collecting the errors
     * @return true if the processing succeeded
     */
    public boolean processMethods(ClassDoc cd, MethodDoc[] md, ErrorTracker clet)
    {
        boolean trace = false; //cd.name().startsWith("GoodClass");
        if (trace) System.out.println("PROCESSING " +cd.name()+" METHODS, number = "+md.length);
        boolean anyError = false;
        if (md.length == 0) return false;
        ICheck iCheck = new ICheck(cd);
        for (int i=0; i<md.length; i++)
        {
            if (trace) System.out.println("PROCESSING METHOD: "+md[i].name());
            
            // Check to see if the method should be excluded
            //TODO
            
            // Method Error Tracker
            ErrorTracker met = new MethodTracker(signature(md[i]), clet);
            boolean noComment = false;
            boolean tagError = false;
            boolean noText = false;
            boolean s1Error = false;
            int errorLevel = METHOD_ERR;
            ClassDoc od = md[i].overriddenClass();
            String implementedInterface = "";
            String data = md[i].getRawCommentText();
            int tagCount = md[i].paramTags().length;
            implementedInterface = iCheck.implementsInterface(md[i]);
            if ((data == null) || data.equals("")) {
                noComment = true;
                anyError = true;
                if (implementedInterface != null) {
                    // Method implements an interface
                    // Treat as an error, although it may not be,
                    // until the method can be checked to see if it has
                    // a "// Implements interface" comment.
                    // Unfortunately, there is no way to check for the existence
                    // of a normal comment in a doclet.
                    errorLevel = WARNING;
                    met.addErr(errorLevel, IMPLEMENTS);
                    met.formLine(errorLevel, "// Inherited from interface " + implementedInterface);
                    continue;
                } else if (od != null && tagCount == 0) {
                    // Overrides a superclass method
                    errorLevel = WARNING;
                    met.addErr(errorLevel, OVERRIDES);
                    met.formLine(errorLevel, "// Inherited from superclass " + od.name());
                    continue;
                } else if (firstLine(-1, md[i], null)) {
                    // Comment text can be generated from method name.
                    errorLevel = selfEvidentCommentLevel;
                    met.addErr(errorLevel, NO_EVIDENT);
                } else {
                    // First sentence can't be generated. First
                    // line of template will consist of "*" only.
                    errorLevel = METHOD_ERR;
                }
                met.addErr(errorLevel, NO_COMMENT);
                met.formStart(errorLevel);
                firstLine(errorLevel, md[i], met);
            } else {
                if (trace) System.out.println("--has comment");
                // Comment present. Check text.
                data = md[i].commentText();
                if ((data == null) || data.equals("")) {
                    noText = true;
                    anyError = true;
                    if (implementedInterface != null) {
                        if (trace) System.out.println("--implements");
                        // Method implements an interface
                        errorLevel = WARNING;
                        met.addErr(errorLevel, IMPLEMENTS);
                        continue;
                    } else if (od != null && tagCount == 0) {
                        if (trace) System.out.println("--overrides");
                        // Overrides a superclass method
                        errorLevel = WARNING;
                        met.addErr(errorLevel, OVERRIDES);
                        continue;
                    } else if (firstLine(-1, md[i], null)) {
                        // Comment text can be generated from method name.
                        errorLevel = selfEvidentCommentLevel;
                        met.addErr(errorLevel, NO_EVIDENT);
                    } else {
                        // First sentence can't be generated. First
                        // line of template will consist of "*" only.
                        errorLevel = METHOD_ERR;
                    }
                    met.addErr(errorLevel, NO_TEXT);
                    firstLine(errorLevel, md[i], met);
                } else {
                    if (trace) System.out.println("--checking first sentence");
                    s1Error = checkFirstSentence(data, met);
                    if (s1Error) {
                        if (trace) System.out.println("--first sentence error found");
                        errorLevel = TEXT_ERR;
                        met.addErr(errorLevel, HTML_FIRST);
                    }
                }
            }
            if (!noComment && !noText) {
                // If no comment or no text, firstLine() generated the override message
                // Otherwise, add it here, for an optional addition to the comments
                // to explain *why* there was an override. Note: If the overridden
                // method is abstract, that explanation is sufficient. But although
                // JavaDoc makes it easy to find the class, its hard to find the
                // method.
                if (trace) System.out.println("--generate override message");
                if (od != null) overrideMessage(errorLevel, md[i], met);
                //--Don't bother making interface messages. There are too many, and
                //  its like an abstract method -- the reason for implementing is that
                //  its required.
                //if ((implementedInterface != null) && interfaceComments)
                //    met.addLine(" * implements " + implementedInterface);
            }
            
            // Generate tags using checkTags() when a comment is being generated
            // where no comment existed before.
            tagCount = md[i].paramTags().length + md[i].tags("return").length;
            if (noComment) {
                // If the method does not implement an interface or override a
                // superclass method, check tags. (If it does, tags are optional.)
                // Note: Ignore exception tags in the count, since the current method
                //       might throw additional exceptions.
                if ( tagCount == 0
                    &&   implementedInterface != null
                    &&   od != null ) {
                    tagError = checkTags(errorLevel, md[i], met);
                }
            } else if (noText && tagCount == 0) {
                // If there are no tags, then check tags.
                // That does seem strange, but it goes like this:
                //   1.) If there are no tags and no text, then we must be looking
                //       at a blank comment.
                //   2.) In that case, run checkTags() to generate any tags that
                //       are needed!
                //   3.) Otherwise, if tags are present, assume they're ok, and
                tagError = checkTags(errorLevel, md[i], met);
            } else {
                // Not sure if this is being done elsewhere, or not.
                // Check tags when the method comment exists and/or
                // one or more tags exists.
                if (trace) System.out.println("--checking tags");
                tagError = checkTags(TAG_ERR, md[i], met);
            }
            boolean htmlError = false;
            if (!s1Error && !noComment && !noText) {
                if (trace) System.out.println("--checking body HTML");
                //htmlError = checkHTML(body(md[i].commentText()), met);
                htmlError = checkHTML(md[i].commentText(), met);
                if (htmlError) {
                    met.addErr(TEXT_ERR, HTML_BODY);
                }
            }
            if (noComment) {
                // Finish the comment-start line if there was no comment
                met.formEnd(errorLevel);
            }
            boolean methodError = noComment || noText || tagError || s1Error || htmlError;
            anyError |= methodError;
            if (trace) System.out.println("--adding method as sub to class");
            if (trace) {
                System.out.println("  TEXT ERR="+met.hasError(TEXT_ERR));
                System.out.println("  WARNING ="+met.hasError(WARNING));
            }
            clet.addSub(met);
        }//for
        //System.out.println("FINISHED METHODS: anyError="+anyError);
        return anyError;
        
    }//processMethods()
    
    /**
     * Adds the first line for a class comment. For an
     * interface, adds "Defines the requirements for an
     * object that ..." . For a class, adds a tag spacer (" *").
     *
     * @param d       a ClassDoc object
     * @param et    the ErrorTracker object collecting the errors
     */
    public void firstLine(int level, ClassDoc d, ErrorTracker et)
    {
        if (d.isInterface()) {
            et.formLine(level, " * " + ifc_clause);
        } else {
            et.formLine(level, " * ");
        }
    }
    
    /**
     * Adds the first line for a constructor.
     *
     * @param d     a ConstructorDoc object
     * @param et    the ErrorTracker object collecting the errors
     */
    public void firstLine(int level, ConstructorDoc d, ErrorTracker et)
    {
        String name = name(d.containingClass());
        et.formLine(level, " * " + cnr_clause + " " + article(name) + name
                        + " " + obj_clause + ".");
    }
    
    /**
     * Adds the first line for the method comment. Identifies
     * an overridden method, if there is one. For "getFoo"
     * adds "Returns the foo value." For "setFoo", adds
     * "Sets the foo value." For "isFoo", adds "Returns the
     * foo value". (These are the default phrases, which
     * can be controlled using command-line options.)
     * See DocCheck.html for details.
     *
     * @param d     a MethodDoc object
     * @param et    the ErrorTracker object collecting the errors
     */
    public boolean firstLine(int level, MethodDoc d, ErrorTracker et)
    {
        boolean trace = false;
        if (trace) System.out.println(d.name()+":");
        boolean check = false;
        if (et == null) {
            // Don't write anything. Just check to see if a good
            // first line can be generated.
            check = true;
            if (trace) System.out.println("--checking for generatable first line");
        }
        else if (trace) System.out.println("--generating first line");
        
        boolean lineWritten = false;
        ClassDoc od = d.overriddenClass();
        if (od != null) {
            if (trace) System.out.println("--method overrides a superclass");
            if (check) return true;
            if (d.name().equals("toString") && d.parameters().length == 0) {
                et.formLine(level, " * Returns a string that displays and identifies this");
                et.formLine(level, " * object's properties.");
                et.formLine(level, " *");
                et.formLine(level, " * @return a String representation of this object");
                return true;
            }
            overrideMessage(level, d, et);
            lineWritten = true;
        }
        String mName = d.name() ;
        String pName = propertyName(d);
        String startClause = "";
        String finalClause = "";
        if (pName == null || pName.equals("")) {
            if (trace) System.out.println("--property name not found");
            if (check) return false;
        } else {
            if (trace) System.out.println("--property name: "+pName);
            if (check) return true;
            if (pName.endsWith("color")
                ||  pName.endsWith("font")
                ||  pName.endsWith("location")
                ||  pName.endsWith("name")
                ||  pName.endsWith("position")
                ||  pName.endsWith("size")
                ||  pName.endsWith("text")
                ||  pName.endsWith("value") )
            {
                startClause = "this " + obj_clause + "'s";
                finalClause = ".";
            }
            if (mName.startsWith("is")) {
                startClause = is_clause;
                finalClause = " " + bVal_clause + ".";
                if (bVal_clause.equals("")) finalClause = ".";
                et.formLine(level, " * " + startClause  + " " + pName + finalClause);
            } else if (mName.startsWith("get")) {
                if (trace) System.out.println("--get method");
                if (startClause != "") startClause = "Gets " + startClause;
                else {
                    startClause = get_clause;
                    finalClause = " " + val_clause + ".";
                    if (val_clause.equals("")) finalClause = ".";
                }
                if (pName.equals("enabled")
                    ||  pName.equals("visible") )
                {
                    startClause = "Returns true if this " + obj_clause + " is ";
                    finalClause = ".";
                }
                if (trace) System.out.println("--startClause="+startClause);
                et.formLine(level, " * " + startClause + " " + pName + finalClause);
            } else if (mName.startsWith("set")) {
                if (d.flatSignature().substring(1).startsWith("boolean")) {
                    if (pName.equals("enabled")) {
                        et.formLine(level, "Enables or disables this " + obj_clause +".");
                        return true;
                    }
                    if (pName.equals("visible")) {
                        et.formLine(level, "Hides or displays this " + obj_clause +".");
                        return true;
                    }
                    startClause = bSet_clause;
                    finalClause = " " + bVal_clause + ".";
                    if (bVal_clause.equals("")) finalClause = ".";
                    et.formLine(level, " * " + startClause + " " + pName + finalClause);
                } else {
                    // Method takes no argument, or at least not a boolean one
                    if (pName.equals("enabled")) {
                        et.formLine(level, "Enables this " + obj_clause +".");
                        return true;
                    }
                    if (pName.equals("visible")) {
                        et.formLine(level, "Makes this " + obj_clause +" visible.");
                        return true;
                    }
                    if (startClause != "") startClause = "Sets " + startClause;
                    else {
                        startClause = set_clause;
                        finalClause = " " + val_clause + ".";
                        if (val_clause.equals("")) finalClause = ".";
                    }
                    et.formLine(level, " * " + startClause  + " " + pName + finalClause);
                }
            }
            lineWritten = true;
        }
        Tag[] tags = d.tags();
        if (!lineWritten && tags.length >0) {
            //NOTE: tag.name() returns "@see".
            //      But to get those tags, you use tags("see").
            if (tags[0].name().equals("@see")) {
                if (check) return true;
                String target = tags[0].text().replace('#','.');  // Change #-separator to dot
                et.formLine(level, " * Delegates to <code>" + target + "</code>.");
                lineWritten = true;
            }
            if (tags[0].name().equals("@return")) {
                if (check) return true;
                et.formLine(level, " * Returns " + tags[0].text());
                lineWritten = true;
            }
        }
        if (check) return false;
        if (!lineWritten) et.formLine(level, " *");
        return lineWritten;
        
    } //firstLine()
    
    /**
     * Adds a line identifying the overridden method
     * @param md  a MethodDoc object
     * @param et  the ErrorTracker object collecting the errors
     */
    public void overrideMessage(int level, MethodDoc md, ErrorTracker et) {
        
        ClassDoc od = md.overriddenClass();
        // TODO: When md.overriddenMethod() is available, use it to find out
        // if the method is abstract. (We could do it now, but we would have
        // to get all the methods in the class and loop to match signatures.)
        MethodDoc om;
        try {
            om = md.overriddenMethod();
        } catch (NoSuchMethodError e) {
            //Method "overriddenMethod()" is not supported by older versions of
            //the Doclet API.  We have to search for the overridden method with our
            //own utility method.
            om = findMethod(od, md);
        }
        if (om != null && om.isAbstract()) {
            et.formLine(level, " * Implements abstract method <code>" + name(od)
                            + "." + md.name() + "</code>.");
        }
        else {
            // Not an abstract method
            et.formLine(level, " * Overrides <code>" + name(od)
                            + "." + md.name() + "</code>.");
        }
        
    }
    
    /**
     * Search for the given method in the given class.
     *
     * @param  cd        Class to search into.
     * @param  method    Method to be searched.
     * @return MethodDoc Method found, null otherwise.
     */
    private static MethodDoc findMethod(ClassDoc cd, MethodDoc method) {
        MethodDoc[] methods = cd.methods();
        for (int i = 0; i < methods.length; i++) {
            if (method.name().equals(methods[i].name()) &&
                method.signature().equals(methods[i].signature())) {
                return methods[i];
            }
        }
        return null;
    }
    
    /**
     * Returns the name of the property for methods with names like
     * isFoo(), getFoo(), and setFoo(). Returns the property name with
     * a lowercase initial letter.
     *
     * @param d  a MethodDoc object
     * @return a String containing the property name, or null
     */
    public String propertyName(MethodDoc d) {
        String name = d.name();
        // Check for isXx()
        if (name.length() < 4) return null;
        if (name.startsWith("is")) {
            if (!Character.isUpperCase(name.charAt(2))) return null;
            return parse(name.substring(2));
        }
        
        // Check for getXx and setXx
        if (name.length() < 5) return null;
        if (name.startsWith("get") || name.startsWith("set")) {
            if (!Character.isUpperCase(name.charAt(3))) return null;
            return parse(name.substring(3));
        }
        return null;
    }
    
    /**
     * Breaks a string into component names. For a string like ReallyFoo, returns
     * "really foo". Does not attempt to break up strings of capital
     * letters, so AnABC() returns "an ABC" and "VeryGoodABs()" returns
     * "very good ABs". This processing will therefore break up "ALLgoodThings"
     * as "ALLgood things". Similarly, "ALLGoodThings" is returned as
     * "ALLGood things". Since there is no universal standard about how to
     * capitalize the word following a string of capitals, this parsing is
     * the best that can be achieved.
     *
     * @param s  an intercap string to break up
     * @return a String with initial lowercase names and spaces between them
     */
    public String parse(String s)
    {
        // Start with init lowercase string (if 2nd letter isn't capped).
        StringBuffer sb = new StringBuffer(uncap(s));
        final int NONE  = 0;
        final int NUM   = 1;
        final int LOWER = 2;
        final int UPPER = 3;
        int lastChar = NONE;
        int index = 0;
        INSPECTION:
        while (index < sb.length()) {
            char letter = sb.charAt(index);
            if (letter == '_') {
                if (index == 0) sb.deleteCharAt(index);
                else {
                    // Replace underscore with space
                    sb.setCharAt(index, ' ');
                    index++;
                    if (index < sb.length()) sb.replace(index, sb.length(), uncap(sb.substring(index)));
                }
                continue INSPECTION;
            }
            if (lastChar == LOWER || lastChar == NUM) {
                // At an uppercase letter following a string of lowercase letters
                // or digits, or at a lowercase character following a string of digits.
                // Add a space and increment past it. Then replace the tail of the
                // string with a properly capitalized version and continue.
                // (We don't break small letters after capitals in order to keep
                // capitlized words together. And we don't break numbers after capitals,
                // on the assumption that they are part of the name.)
                // Here's the decision table:
                //    Lower --> upper : break
                //    lower --> number: break
                //   number --> lower : break
                //   number --> upper : break
                //    upper --> lower : no break
                //    upper --> number: no break
                sb.insert(index, ' ');
                index++;
                sb.replace(index, sb.length(), uncap(sb.substring(index)));
            }
            if (letter >= '0' && letter <= '9') {
                // Move past a string of numbers
                lastChar = NUM;
                while (letter >= '0' && letter <= '9') {
                    if (++index >= sb.length()) break INSPECTION;
                    letter = sb.charAt(index);
                }
                continue INSPECTION;
            }
            if (letter >= 'A' && letter <= 'Z') {
                // Move past a string of capital letters
                lastChar = UPPER;
                while (letter >= 'A' && letter <= 'Z') {
                    if (++index >= sb.length()) break INSPECTION;
                    letter = sb.charAt(index);
                }
                continue INSPECTION;
            }
            if (letter >= 'a' && letter <= 'z') {
                // Move past a string of lowercase letters
                lastChar = LOWER;
                while (letter >= 'a' && letter <= 'z') {
                    if (++index >= sb.length()) break INSPECTION;
                    letter = sb.charAt(index);
                }
                continue INSPECTION;
            }
        }//INSPECTION
        return sb.toString();
    }//parse
    
    /**
     * Returns a properly capitalized name. Name is assumed to be
     * at least 2 characters long. Initial letter is assumed to be
     * upper case. It is converted to lower case if the second letter
     * is also lower case.
     *
     * @param name  a String containing a name
     * @return the String with the first letter capitalized properly for
     *         a property name
     */
    public String uncap(String name) {
        if (name.length() < 1) return "";
        if (name.length() == 1) return name.substring(0,1).toLowerCase();
        char firstLetter = name.charAt(0);
        char secondLetter = name.charAt(1);
        if ((firstLetter >= '0') && (firstLetter <= '9')) return name;
        if ((firstLetter >= 'a') && (firstLetter <= 'z')) return name;
        // First letter is a capital. Check second.
        if ((secondLetter >= 'A') && (secondLetter <= 'Z')) return name;
        if ((secondLetter >= '0') && (secondLetter <= '9')) return name;
        // First letter is capitalized, and second isn't. Lowercase the first letter.
        return name.substring(0,1).toLowerCase() + name.substring(1);
    }
    
    /**
     * Check the tags for a class.
     *
     * @param level an int that selects the error-reporting object
     *              that generated-tags will be added to. (Used
     *              when generating tags for class, constructor,
     *              and method templates, and only when no tags
     *              exist.)
     * @param cd    a ClassDoc object
     * @param et    the ErrorTracker object collecting the errors
     * @return true if no errors were found
     */
    public boolean checkTags(int level, ClassDoc cd, ErrorTracker et)
    {
        boolean error = false;
        Tag [] tags = cd.tags("author");
        if (tags.length == 0) {
            error = true;
            if (level == TAG_ERR) et.addErr(TAG_ERR, TAG_MISSING);
            et.formTag(level, " * @author " + author, CLASS_TAG);
        } else for (int i=0; i<tags.length; i++) {
                if (tags[i].text().equals("")) {
                    et.addErr(TAG_ERR, TAG_TEXT);
                    et.formBadTag(TAG_ERR, " ? @author " + " --????", INVALID_TAG);
                }
            }
        tags = cd.tags("version");
        if (tags.length == 0) {
            error = true;
            if (level == TAG_ERR) et.addErr(TAG_ERR, TAG_MISSING);
            et.formTag(level, " * @version " + version, CLASS_TAG);
        } else if (tags.length > 1) {
            et.addErr(TAG_ERR, TAG_MULTVER);
        } else if (tags[0].text().equals("")) {
            et.addErr(TAG_ERR, TAG_TEXT);
            et.formBadTag(TAG_ERR, " ? @version " + " --????", INVALID_TAG);
        }
        return error;
    } //checkTags(class)
    
    /**
     * Check parameter tags for methods and constructors, plus
     * then return tag for methods.
     *
     * @param level an int that selects the error-reporting object
     *              that generated-tags will be added to. (Used
     *              when generating tags for class, constructor,
     *              and method templates when no tags exist.)
     * @param emd     a ExecutableMemberDoc object
     * @param et    the ErrorTracker object collecting the errors
     * @return true if there were no errors
     */
    public boolean checkTags(int level, ExecutableMemberDoc emd, ErrorTracker et)
    {
        boolean trace = false;
        
        boolean error = false;
        List rL;    // required tags
        List eL;    // existing tags
        Parameter[] p  = emd.parameters();
        ParamTag[]  pt = emd.paramTags();
        rL = new LinkedList(Arrays.asList(p));
        eL = new LinkedList();
        // Note:
        // Modify the list of existing params.
        // Convert a single param tag with multiple items to multiple
        // items. (Ex: @param x,y coordinates... => 2 param tags.)
        // Store the relavent data in ParamTagData objects and add to list
        for (int i = 0; i < pt.length; i++) {
            // See if it is in the list of existing tags
            ParamTag eTag = pt[i];
            if (eTag.parameterName().indexOf(",") != -1) {
                String names = eTag.parameterName();
                StringTokenizer st = new StringTokenizer(names, ",");
                while (st.hasMoreTokens()) {
                    // Create new ParamTag entries. (ParamTag is an interface)
                    String name = st.nextToken().trim();
                    while (name.startsWith("&nbsp;")) {
                        name = name.substring(6).trim();
                    }
                    while (name.endsWith("&nbsp;")) {
                        name = name.substring(0, name.length()-6).trim();
                    }
                    if (name.equals("")) continue;
                    ParamTagData pData = new ParamTagData(name, eTag.parameterComment());
                    eL.add(pData);
                }
            } else {
                ParamTagData pData = new ParamTagData(eTag);
                eL.add(pData);
            }
        }
        
        // If the method overrides a superclass method, and it has
        // NO @param tags and NO @return tags, then ignore missing tags.
        // Reason:
        //   The standard doclet generates a link to the
        //   source method, and the comment may consist solely
        //   of text that explains the reason for the
        //   override. In such cases, it makes sense to leave
        //   detailed information like valid parameter ranges
        //   in the original method.
        // Note:
        //   This reasoning is also applied to methods that
        //   implement an interface, on the assumption that
        //   the comment text is simply "implements xyz interface".
        // Note:
        //   This reasoning does not apply to exception tags,
        //   since the current implementation could require
        //   additional exceptions to be thrown. Ideally, then,
        //   this method would report missing exception tags
        //   even when tags are otherwise ignored, but only if
        //   they are not required by the source method.
        boolean ignoreMissingTags = false;
        if (emd instanceof MethodDoc) {
            MethodDoc md = (MethodDoc) emd;
            ICheck iCheck = new ICheck(md);
            String iface = iCheck.implementsInterface(md);
            if ((md.overriddenClass() != null || iface != null)
                &&  (eL.size() == 0)
                &&  (md.tags("return").length == 0) ){
                ignoreMissingTags = true;
            }
        }
        
        // Remove arguments added by the compiler. This step is
        // necessary for inner class constructors in JavaDoc 1.3.
        // In that version, JavaDoc passes on the outer-class
        // argument that is sent to the inner class. That argument
        // is what the inner class uses to access the outer-class
        // fields when "this" is referenced in the inner class.
        ListIterator lit = rL.listIterator();
        while (lit.hasNext()) {
            Parameter param = (Parameter) lit.next();
            if (param.name().startsWith("this$")) lit.remove();
        }
        
        // Find length of longest name
        int maxName = 0;
        ListIterator rLit = rL.listIterator();
        while (rLit.hasNext()) {
            Parameter nextR = (Parameter) rLit.next();
            String nameR = nextR.name();
            if (nameR.length() > maxName) maxName = nameR.length();
        }
        
        // Check parameter tags
        rLit = rL.listIterator();
        RLOOP:
        while (rLit.hasNext()) {
            // For each required tag
            Parameter nextR = (Parameter) rLit.next();
            String nameR = nextR.name();
            String typeR = nextR.typeName();
            ListIterator eLit = eL.listIterator();
            while (eLit.hasNext()) {
                // See if it is in the list of existing tags
                ParamTagData nextE = (ParamTagData) eLit.next();
                if (nextE.parameterName().equals(nameR)) {
                    // Name matches. Make sure comment text exists.
                    String comment = nextE.parameterComment();
                    if ((comment == null) || squashBlanks(comment).equals("")) {
                        // Comment is blank.
                        error = true;
                        et.addErr(TAG_ERR, TAG_INVALID);
                        et.formBadTag(TAG_ERR, " ? @param " + nameR + "  "
                                          + " --MISSING TEXT", INVALID_TAG);
                    }
                    //DISABLED. No longer checking for a type specifier
                    //in the param comment. (Thank goodness.) This
                    //"requirement" was stripped, thanks to Josh.
                    //if (found(typeR, comment)) {
                    //  //Type matches. Remove from both lists.
                    //  rLit.remove();
                    //  eLit.remove();
                    //  continue RLOOP;
                    //}
                    // Name matches but not type. An invalid tag.
                    //error = true;
                    //et.addErr(TAG_ERR, TAG_INVALID);
                    //et.formBadTag(TAG_ERR, " ? @param " + nameR + "  "
                    //         + initialText(nextE.parameterComment())
                    //         + " --INVALID OR MISSING TYPE", INVALID_TAG);
                    
                    // Valid tag. Remove it from both lists and continue.
                    rLit.remove();
                    eLit.remove();
                    continue RLOOP;
                }
            }
            // No match found. The method is missing a required tag.
            if (ignoreMissingTags) {
                rLit.remove();
                continue;
            }
            // Output the param tag, with the phrase after the name lined up
            // with the longest name in the list.
            error = true;
            StringBuffer s = new StringBuffer(nameR);
            for (int i=0; i<maxName - nameR.length(); i++) s.append(' ');
            if (level == TAG_ERR) et.addErr(TAG_ERR, TAG_MISSING);
            et.formTag(level, " * @param " + s + "  " + paramPhrase( emd, typeR),
                       METHOD_TAG);
        }
        // Add any existing tags that are left over
        Iterator eLit = eL.listIterator();
        while (eLit.hasNext()) {
            error = true;
            ParamTagData nextE = (ParamTagData) eLit.next();
            et.addErr(TAG_ERR, TAG_EXTRA);
            et.formBadTag(TAG_ERR, " ? @param " + nextE.parameterName() + "  "
                              + initialText(nextE.parameterComment())
                              + " --EXTRANEOUS OR INVALID TAG",
                          INVALID_TAG);
        }
        
        // Check return tag
        if (emd instanceof MethodDoc) {
            MethodDoc md = (MethodDoc) emd;
            boolean notFound = true;
            Type  r  = md.returnType();
            String type = r.toString();
            if (type.equals("void")) notFound = false;  // no tag required
            Tag[] rtArr = emd.tags("return");
            rL = new LinkedList(Arrays.asList(rtArr));  // return tags
            rLit = rL.listIterator();
            while (rLit.hasNext()) {
                Tag  rt = (Tag) rLit.next();
                if (notFound) {
                    notFound = false;  // A tag was present, even if wrong
                    String comment = rt.text();
                    if ((comment == null) || squashBlanks(comment).equals("")) {
                        // Comment is blank.
                        error = true;
                        et.addErr(TAG_ERR, RET_INVALID);
                        et.formBadTag(TAG_ERR, " ? @return --MISSING TEXT", INVALID_TAG);
                        continue;
                    } else {
                        rLit.remove();
                        continue;
                    }
                    //if (found(type, rt.text())) {
                    //  rLit.remove();
                    //  continue;
                    //} else {
                    //  error = true;
                    //  et.addErr(TAG_ERR, RET_INVALID);
                    //  et.formBadTag(level, " ? @return " + "  "
                    //           + initialText(rt.text())
                    //           + " -- INVALID",
                    //           INVALID_TAG);
                    //  continue;
                    //}
                }
                error = true;
                et.addErr(TAG_ERR, RET_EXTRA);
                et.formBadTag(level, " ? @return " + "  "
                                  + initialText(rt.text())
                                  + " -- EXTRANEOUS",
                              INVALID_TAG);
            }//while
            if (notFound && !ignoreMissingTags) {
                // Ignore missing tags for an overridden method.
                // Otherwise, generate error.
                error = true;
                if (level == TAG_ERR) et.addErr(TAG_ERR, RET_MISSING);
                et.formTag(level, " * @return " + returnPhrase((MethodDoc) emd, type),
                           METHOD_TAG);
            }
        }//emd=MethodDoc
        
        // Check exception tags
        ClassDoc[]  e  = emd.thrownExceptions();
        ThrowsTag[] ett = emd.throwsTags();
        rL = new LinkedList(Arrays.asList(e));     // required
        eL = new LinkedList(Arrays.asList(ett));   // existing
        rLit = rL.listIterator();
        if (trace) System.out.println("  Throws tags: "+ett.length);
        ELOOP:
        while (rLit.hasNext()) {
            // Remove required tags that match an existing tag
            ClassDoc rCD = (ClassDoc) rLit.next();
            String nameR = rCD.name();
            //String qNameR = nextR.qualifiedName();
            eLit = eL.listIterator();
            //if (trace) System.out.println("  Exception required: " + nameR);
            while (eLit.hasNext()) {
                ThrowsTag nextE = (ThrowsTag) eLit.next();
                String nameE = nextE.exceptionName();
                if (trace) System.out.println("    Exception found: " + nameE);
                ClassDoc eCD = emd.containingClass().findClass(nameE);
                if (eCD != null && eCD.equals(rCD)) {
                    // Class matches. Remove from both lists.
                    rLit.remove();
                    eLit.remove();
                    continue ELOOP;
                }
            }
            // No match found
            if (ignoreMissingTags) {
                rLit.remove();
                continue;
            }
            // Generate an error
            error = true;
            if (level == TAG_ERR) et.addErr(TAG_ERR, EXC_MISSING);
            et.formTag(level, " * @throws " + simpleName(nameR) + " ...",
                       METHOD_TAG);
        }
        // DISABLED:
        // Add any existing tags that are left over...
        // REASON:
        //   An exception tag for an exception that is not
        //   declared via throws is the proper way to document
        //   an unchecked exception.
        //eLit = eL.listIterator();
        //while (eLit.hasNext()) {
        //  ThrowsTag nextE = (ThrowsTag) eLit.next();
        //  error = true;
        //  et.addErr(TAG_ERR, EXC_EXTRA);
        //  et.formBadTag(TAG_ERR, " ? @throws " + nextE.exceptionName()
        //           + " --EXTRANEOUS",
        //           INVALID_TAG);
        //}
        
        // Check to make sure that the unchecked exception is a
        // subtype of Throwable. Otherwise, it's invalid.
        eLit = eL.listIterator();
        while (eLit.hasNext()) {
            ThrowsTag nextE = (ThrowsTag) eLit.next();
            if (nextE.exception() == null) {
                // This is an "unchecked" (undeclared) exception
                String name = nextE.exceptionName();
                String comment = nextE.exceptionComment();
                if (name == null || name.equals("")
                    ||  comment == null || comment.equals("") ) {
                    error = true;
                    et.addErr(TAG_ERR, EXC_TEXT);
                    et.formBadTag(TAG_ERR, " ? @throws/@exception "
                                      + name + " -- NO TEXT",
                                  INVALID_TAG);
                }
            } else if (badExceptionClass(nextE.exception())) {
                error = true;
                et.addErr(TAG_ERR, EXC_EXTRA);
                et.formBadTag(TAG_ERR, " ? @throws/@exception "
                                  + nextE.exceptionName()
                                  + " --NOT AN EXCEPTION CLASS",
                              INVALID_TAG);
            }
        }
        
        // Check @see tags
        // These are lower level than tag errors
        //  -- they're "text" errors.
        if (emd instanceof MethodDoc) {
            SeeTag[] st = emd.seeTags();
            LinkedList sL = new LinkedList(Arrays.asList(st));
            ListIterator sLit = sL.listIterator();
            String mName = emd.name();
            boolean seeTagNeeded = false;
            // Links between getFoo() and setFoo()
            if (mName.length() > 3) {
                String pName = mName.substring(3); // Property name
                if (trace) System.out.println("  pName="+pName);
                if (mName.startsWith("get")) {
                    if (methodExists("set"+pName, emd)) {
                        if (trace) System.out.println("  Exists: set"+pName);
                        seeTagNeeded = true;
                        while (sLit.hasNext()) {
                            SeeTag nextE = (SeeTag) sLit.next();
                            //For some reason, label() started returning nulls.
                            //String seeText = nextE.label();
                            String seeText = nextE.text();
                            if (trace) System.out.println("  Comparing to: "+seeText);
                            if (seeText.startsWith("#set"+pName)) {
                                seeTagNeeded = false;
                            }
                        }
                        if (seeTagNeeded) {
                            if (level == TAG_ERR) {
                                et.addErr(TEXT_ERR, SEE_MISSING);
                                et.formTag(TEXT_ERR, " * @see #set"+pName, SEE_TAG);
                            }
                        }
                    }
                } else if (mName.startsWith("set")) {
                    if (methodExists("get"+pName,emd)) {
                        seeTagNeeded = true;
                        while (sLit.hasNext()) {
                            SeeTag nextE = (SeeTag) sLit.next();
                            //String seeText = nextE.label();
                            String seeText = nextE.text();
                            if (seeText.startsWith("#get"+pName)) seeTagNeeded = false;
                        }
                        if (seeTagNeeded) {
                            if (level == TAG_ERR) {
                                et.addErr(TEXT_ERR, SEE_MISSING);
                                et.formTag(TEXT_ERR, " * @see #get"+pName, SEE_TAG);
                            }
                        }
                    }
                }
            }
            // Links between addFooListener() and removeFooListener()
            if (mName.length() > 11 && mName.endsWith("Listener")) {
                if (mName.startsWith("add")) {
                    String pName = mName.substring(3); // Property name
                    if (methodExists("remove"+pName,emd)) {
                        seeTagNeeded = true;
                        while (sLit.hasNext()) {
                            SeeTag nextE = (SeeTag) sLit.next();
                            //String seeText = nextE.label();
                            String seeText = nextE.text();
                            if (seeText.startsWith("#remove"+pName)) seeTagNeeded = false;
                        }
                        if (seeTagNeeded) {
                            if (level == TAG_ERR) {
                                et.addErr(TEXT_ERR, SEE_MISSING);
                                et.formTag(TEXT_ERR, " * @see #remove"+pName, SEE_TAG);
                            }
                        }
                    }
                } else if (mName.startsWith("remove")) {
                    String pName = mName.substring(6); // Property name
                    if (methodExists("add"+pName,emd)) {
                        seeTagNeeded = true;
                        while (sLit.hasNext()) {
                            SeeTag nextE = (SeeTag) sLit.next();
                            //String seeText = nextE.label();
                            String seeText = nextE.text();
                            if (seeText.startsWith("#add"+pName)) seeTagNeeded = false;
                        }
                        if (seeTagNeeded) {
                            if (level == TAG_ERR) {
                                et.addErr(TEXT_ERR, SEE_MISSING);
                                et.formTag(TEXT_ERR, " * @see #add"+pName, SEE_TAG);
                            }
                        }
                    }
                }
            }
            error |= seeTagNeeded;
        }
        return error;
    } //checkTags(executableMember)
    
    /**
     * An inner class that does the work of obtaining the
     * information we need about a ParamTags.
     */
    public class ParamTagData {
        String name;
        String comment;
        
        public ParamTagData(String name, String comment) {
            this.name = name;
            this.comment = comment;
        }
        
        public ParamTagData(ParamTag paramTag) {
            name = paramTag.parameterName();
            comment = paramTag.parameterComment();
        }
        
        public String parameterName()    { return name; }
        public String parameterComment() { return comment; }
    }
    
    /**
     * @return true if the class is not a subtype of RuntimeException
     */
    boolean badExceptionClass(ClassDoc cd) {
        boolean trace = false;
        if (trace) System.out.println("Looking at "+cd.qualifiedName());
        while (cd != null) {
            if (cd.qualifiedName().equals("java.lang.Throwable")) return false;
            cd = cd.superclass();
            if (trace) System.out.println("  --Checking superclass "+cd.qualifiedName());
        }
        return true;
    }
    
    /**
     * Returns true if the containing object has a method with the given
     * name.
     *
     * @param name a String specifying the name of the method
     * @param emd  an ExecutableMemberDoc object
     * @return true if the associated method exists
     */
    public boolean methodExists(String name, ExecutableMemberDoc emd) {
        ClassDoc cd = emd.containingClass();
        MethodDoc[] mdArr = cd.methods();
        for (int i=0; i < mdArr.length; i++) {
            if (mdArr[i].name().equals(name)) return true;
        }
        return false;
    }
    
    /**
     * Returns first 20 characters of a string.
     *
     * @return a String containing first 20 characters of the
     * input string.
     */
    public String initialText(String s) {
        if (s.length() <= 20) return s;
        return s.substring(0,20);
    }
    
    /**
     * Returns true if the specified type is found in the first three
     * words of the comment. Matches first word, second word ("an int,
     * "the object", or third word ("a useful int"). All names must match
     * exact case, with some exceptions like "object" and "Object".
     * Breaks words using the standard delimiters (" \t\n\r\f") plus "["
     * and "]", for arrays, as well as "<" and ">" for HTML links.
     *
     * @param type     a String identifying a data type
     * @param comment  a String containing the comment from an @param or @return
     *                 tag
     * @return true if the type name is found in the first 5 words of the
     *              comment
     * @see #match
     */
    /*****************************************************************
     //   public boolean found(String type, String comment) {
     //     String lType = type.toLowerCase();
     //     String lComm = comment.toLowerCase();
     //     if (check(lType, lComm)) return true;
     //     if (type.indexOf('[') > -1) {
     //       // Type is an array -- check for simple name and plurals
     //       String s = simpleName(lType);
     //       if ( check(s, lComm) )     return true;
     //       if ( check(s+"s", lComm) ) return true;
     //     }
     //     return false;
     //   }
     *****************************************************************/
    
    /**
     * Returns true if the specified type is found in the first five
     * words of the comment. Matches first word, second word ("an int,
     * "the object", or third word ("a useful int"). All names must match
     * exact case, with some exceptions like "object" and "Object".
     * Breaks words using the standard delimiters (" \t\n\r\f") plus "["
     * and "]", for arrays, as well as "<" and ">" for HTML links.
     *
     * @param type     a String identifying a data type
     * @param comment  a String containing the comment from an @param or @return
     *                 tag
     * @return true if the type name is found in the first 5 words of the
     *              comment
     * @see #match
     */
    /*****************************************************************
     public boolean check(String type, String comment)
     {
     String word;
     StringTokenizer t = new StringTokenizer(comment, " \t\n\r\f[]<>");
     
     // first word (@return Foo -- an object that...)
     if (!t.hasMoreTokens()) return false;
     word = t.nextToken();
     if (match(word, type)) return true;
     
     // second word  (@return a Foo object)
     if (!t.hasMoreTokens()) return false;
     word = t.nextToken();
     if (match(word, type)) return true;
     
     // third word  (@return the real/fake/visible Foo value)
     if (!t.hasMoreTokens()) return false;
     word = t.nextToken();
     if (match(word, type)) return true;
     
     // fourth word  (@return an array of Foo objects)
     if (!t.hasMoreTokens()) return false;
     word = t.nextToken();
     if (match(word, type)) return true;
     
     // fifth word  (@return the <a href="http://strange/tag">URL</a>)
     // Tokens=              _1_  3 _________4_______________ _5_
     // Token #2 = null (between space and "<"
     if (!t.hasMoreTokens()) return false;
     word = t.nextToken();
     if (match(word, type)) return true;
     
     // not found
     return false;
     } //check
     *****************************************************************/
    
    /**
     * Returns true if the strings match. Handles these
     * special cases:
     * <ul>
     * <li>"Object" and "object"
     * <li>"Integer" and "integer"
     * <li>"boolean" and either "true" or "false"
     * <li>"int" and a number in the range -2..+2
     * </ul>
     *
     * @param word  a String a word to match
     * @param type  a String identifying a type
     * @return true if the word matches the (fully qualified) type
     *         or the simple (unqualified) version of that type
     */
    /*****************************************************************
     public boolean match(String word, String type)
     {
     // Check for a straight match
     if (word.equals(type) || word.equals(simpleName(type))) return true;
     // Check for various informal matches
     if (word.toLowerCase().equals("object")
     &&  type.toLowerCase().equals("object"))
     return true;
     if (word.toLowerCase().equals("string")
     &&  type.toLowerCase().equals("string"))
     return true;
     if (word.toLowerCase().equals("strings")
     &&  type.toLowerCase().equals("strings"))
     return true;
     if (type.toLowerCase().equals("boolean")) {
     if      (word.toLowerCase().equals("true"))  return true;
     else if (word.toLowerCase().equals("false")) return true;
     }
     if (type.toLowerCase().equals("int")) {
     if      (word.toLowerCase().equals("-2")) return true;
     else if (word.toLowerCase().equals("-1")) return true;
     else if (word.toLowerCase().equals("0"))  return true;
     else if (word.toLowerCase().equals("1"))  return true;
     else if (word.toLowerCase().equals("2"))  return true;
     }
     return false;
     } //match
     *****************************************************************/
    
    /**
     * Returns an article (a or an) plus the string, depending on
     * its intitial letter and whether or not the type is an array.
     *
     * @param type  a String identifying a type
     * @return the String containing the phrase to use for that type
     */
    public String returnPhrase(MethodDoc d, String type)
    {
        String phrase = "";
        String sType = simpleName(type);
        
        // Check for isFoo() / getFoo() methods
        int argCount = d.parameters().length;
        String propName = propertyName(d);
        if (propName != null) {
            if (d.name().startsWith("get") && argCount == 0 && !type.equals("void"))
            {
                if (type.equals("boolean")) {
                    // Special property name.
                    phrase = "true if this object is " + propName;
                    return phrase;
                }
                if (propName.equals("color")
                    ||  propName.equals("text")
                    ||  propName.equals("font")
                    ||  propName.equals("size")
                    ||  propName.equals("value")
                    ||  propName.equals("location")
                    ||  propName.equals("position") )
                {
                    // Special property name.
                    phrase = "this " + obj_clause +"'s current " + propName;
                    return phrase;
                }
                // Compare lowercase version of names, since propName has an
                // initial lowercase letter
                if (sType.toLowerCase().equals(propName.toLowerCase())) {
                    // Property name is the same as the object.
                    phrase = "the " + sType + " value";
                } else {
                    // Some other type represents the property
                    phrase = typePhrase(type);
                    phrase += " representing the " + propName + " value";
                }
                return phrase;
            }
            if (d.name().startsWith("is")
                &&  argCount == 0
                &&  type.equals("boolean")) {
                phrase = "true if this " + obj_clause + " is " + propName;
                return phrase;
            }
        }
        
        if (type.equals("boolean")) {
            phrase = "true if ...";
        } else if (type.equals("int")) {
            phrase = "an int representing the ... value";
        } else if (sType.equals("String")) {
            phrase = "a String ...";
        } else {
            phrase = typePhrase(type);
        }
        return phrase;
    } //returnPhrase
    
    /**
     * Returns true if the string starts with an uppercase letter.
     *
     * @param s  a String
     * @return true if the string starts with an upper case letter
     */
    public boolean initUpper(String s) {
        if (s.equals("") || s == null) return true;
        String first = s.substring(0,1);  // get the first character
        if (first.toUpperCase().equals(first)) return true;
        return false;
    }
    
    /**
     * Returns an article (a or an) plus the string, depending on
     * its initial letter (in the general case) or a somewhat more
     * specialized version for booleans, ints, and arrays.
     *
     * @param type  a String identifying a type
     * @return the String containing the phrase to use for that type
     */
    public String paramPhrase(ExecutableMemberDoc emd, String type)
    {
        String phrase = "";
        String sType = simpleName(type);
        
        // Check for setFoo() method
        if (emd instanceof MethodDoc) {
            MethodDoc md = (MethodDoc) emd;
            int argCount = md.parameters().length;
            String propName = propertyName(md);
            if (propName != null) {
                if (md.name().startsWith("set") && argCount == 1 && type.equals("boolean")) {
                    phrase = "true to make this " + obj_clause + " " + propName;
                    return phrase;
                }
                phrase =typePhrase(type);
                if (md.name().startsWith("set") && argCount == 1) {
                    // Compare lowercase version of names, since propName has an
                    // initial lowercase letter
                    if (propName.equals("color")
                        ||  propName.equals("text")
                        ||  propName.equals("font")
                        ||  propName.equals("size")
                        ||  propName.equals("value")
                        ||  propName.equals("location")
                        ||  propName.equals("position") )
                    {
                        // Special property name.
                        phrase = "the new " + propName + " for this object";
                        return phrase;
                    }
                    if (propName.equals("enabled")
                        ||  propName.equals("visible")) {
                        // Special property name.
                        phrase = "true to make this object " + propName;
                        return phrase;
                    }
                    if (sType.toLowerCase().equals(propName.toLowerCase())) {
                        // Property name is the same as the object.
                        phrase = "the " + sType + " value";
                        return phrase;
                    } else {
                        // Some other type represents the property
                        phrase += " specifying the " + propName + " value";
                        return phrase;
                    }
                }
                return phrase;
            }
        }
        
        // Construct phrase for other methods
        if (type.equals("boolean")) {
            phrase = "a boolean -- true if ...";
        } else if (type.equals("int")) {
            phrase = "an int specifying ...";
        } else if (sType.equals("String")) {
            phrase = "a String ...";
        } else if (sType.equals("Object")) {
            phrase = "an Object ...";
        } else {
            phrase = typePhrase(type);
        }
        return phrase;
    } //paramPhrase
    
    /**
     * Returns a plural phrase if the argument is an array, else
     * returns a singular phrase.
     *
     * @param type  a String containing a data type
     * @return a String containing the appropriate phrase for that type
     */
    public String typePhrase(String type)
    {
        String phrase = "";
        String sType = simpleName(type);
        if (type.endsWith("]")) {
            phrase = "an array of " + sType;
            if (type.charAt(type.length()-3) == ']') phrase += " array";
            else if (initUpper(sType)) {
                if (!sType.equals("String")
                    &&  !sType.equals("Object") ) phrase += " " + obj_clause;
            }
            phrase += "s";
        } else {
            if (sType.equals("String")) phrase = "a String";
            else if (sType.equals("Object")) phrase = "an Object";
            else {
                phrase = article(sType) + sType;
                if (initUpper(sType)) phrase += " " + obj_clause;
            }
        }
        return phrase;
    } //typePhrase
    
    /**
     * Returns the proper article (a or an) to go along with
     * a word, depending on its first letter, plus a space.
     */
    public String article(String s) {
        char first = s.charAt(0);
        if (first == 'U') {
            // Special case. An all caps entry like "UIDefaults" is
            // pronounced "a UIDefaults object". This is unusual for U.
            // All other pronounced vowels would use "an" -- "an ABC", etc.
            if (s.length() > 1) {
                char next = s.charAt(1);
                if (next >= 'A' && next <= 'Z') return "a ";
            }
        }
        first = s.toLowerCase().charAt(0);
        if (first == 'a' || first == 'e' || first == 'i'
            ||  first == 'o' || first == 'u') {
            return "an ";
        }
        return "a ";
    }
    
    /**
     * Remove the package prefix and array subscripts from a name.
     *
     * @param s  a String containing a fully qualified name
     * @return the String containing the name without the package
     *         qualifier or array subscripts
     */
    public String simpleName(String s) {
        // Remove package-prefix
        int lastPeriod = s.lastIndexOf('.');
        if (lastPeriod > 0) s = s.substring(lastPeriod+1);
        
        // Strip array brackets from name
        int idx = s.indexOf('[');
        if (idx > 0) s = s.substring(0,idx);
        return s;
    }
    
    /**
     * Returns the signature for a method.
     *
     * @param md  a MethodDoc object produced by JavaDoc
     * @return the String containing the method signature
     */
    public String signature(MethodDoc md) {
        //Here's the code for adding the return type to the signature.
        //--The error listing is more readable without it, though.
        //String returnType = ""+md.returnType();
        //returnType = simpleName(returnType);
        return md.name() + md.flatSignature();
    }
    
    /**
     * Returns the signature for a constructor.
     *
     * @param cd  a ConstructorDoc object produced by JavaDoc
     * @return the String containing the constructor signature
     */
    public String signature(ConstructorDoc cd) {
        return cd.name() + cd.flatSignature();
    }
    
    /**
     * Returns the "length" of a given option. If an option takes no
     * arguments, its length is one. If it takes one argument, its
     * length is two, and so on. This method is called by JavaDoc to
     * parse the options it does not recognize. It then calls
     * {@link #validOptions} to validate them.
     * <blockquote>
     * <b>Note:</b><br>
     * The options arrive as case-sensitive strings. For options that
     * are not case-sensitive, use toLowerCase() on the option string
     * before comparing it.
     * </blockquote>
     *
     * @param option  a String containing an option
     * @return an int telling how many components that option has
     */
    public static int optionLength(String option)
    {
        String opt = option.toLowerCase();
        
        // Standard options
        if (opt.equals("-authorid"))  return 2;
        if (opt.equals("-versionid")) return 2;
        if (opt.equals("-d"))         return 2;
        if (opt.equals("-classlist")) return 1;
        if (opt.equals("-title"))     return 2;
        if (opt.equals("-docletid"))  return 1;
        if (opt.equals("-evident"))   return 2;
        if (opt.equals("-skippkg"))   return 2;
        if (opt.equals("-skipclass")) return 2;
        if (opt.equals("-execdepth")) return 2;
        if (opt.equals("-config"))    return 2;
        if (opt.equals("-help"))      return 1;
        
        // Options to control generated text
        if (opt.equals("-ifctxt"))    return 2;
        if (opt.equals("-gettxt"))    return 2;
        if (opt.equals("-settxt"))    return 2;
        if (opt.equals("-istxt"))     return 2;
        if (opt.equals("-valtxt"))    return 2;
        if (opt.equals("-cnrtxt"))    return 2;
        if (opt.equals("-objtxt"))    return 2;
        if (opt.equals("-bsettxt"))   return 2;
        if (opt.equals("-bvaltxt"))   return 2;
        
        return 0;
    }//optionLength
    
    /**
     * After parsing the available options using {@link #optionLength},
     * JavaDoc invokes this method with an array of options-arrays, where
     * the first item in any array is the option, and subsequent items in
     * that array are its arguments. So, if -print is an option that takes
     * no arguments, and -copies is an option that takes 1 argument, then
     * <pre>
     *     -print -copies 3
     * </pre>
     * produces an array of arrays that looks like:
     * <pre>
     *      option[0][0] = -print
     *      option[1][0] = -copies
     *      option[1][1] = 3
     * </pre>
     * (By convention, command line switches start with a "-", but
     * they don't have to.)
     * <p>
     * <b>Note:</b><br>
     * JavaDoc passes <i>all</i>parameters to this method, not just
     * those that JavaDoc doesn't recognize. The only way to
     * identify unexpected arguments is therefore to check for every
     * JavaDoc parameter as well as doclet parameters.
     *
     * @param options   an array of String arrays, one per option
     * @param reporter  a DocErrorReporter for generating error messages
     * @return true if no errors were found, and all options are
     *         valid
     */
    public static boolean validOptions(String[][] options,
                                       DocErrorReporter reporter)
    {
        final DocErrorReporter errOut = reporter;
        
        // A nice object-oriented way of handling errors. An instance of this
        // class puts out an error message and keeps track of whether or not
        // an error was found.
        class ErrorHandler {
            boolean noErrorsFound = true;
            void msg(String msg) {
                noErrorsFound = false;
                errOut.printError(msg);
            }
        }
        
        //System.out.println("Options:");
        ErrorHandler err = new ErrorHandler();
        for (int i=0; i<options.length; i++) {
            //System.out.println("  "+options[i][0]);
            if (options[i][0].toLowerCase().equals("-authorid")) {
                if (options[i].length < 2)
                    err.msg("No name specified after -authorID option.");
                else setAuthor(options[i][1]);
                continue;
            }
            if (options[i][0].toLowerCase().equals("-versionid")) {
                if (options[i].length < 2)
                    err.msg("No version-string specified after -versionID option.");
                else setVersion(options[i][1]);
                continue;
            }
            /*
             *  // Reenable this when HtmlTagWriter allows EOL specification
             *    if (options[i][0].toLowerCase().equals("-eol")) {
             *      if (options[i].length < 2)
             *         err.msg("No end-of-line separator specified after -eol option.");
             *      else if (options[i][1].toLowerCase().equals("dos"))   setEOL("\r\n");
             *      else if (options[i][1].toLowerCase().equals("cr+lf")) setEOL("\r\n");
             *      else if (options[i][1].toLowerCase().equals("unix"))  setEOL("\n");
             *      else if (options[i][1].toLowerCase().equals("nl"))    setEOL("\n");
             *      else if (options[i][1].toLowerCase().equals("lf"))    setEOL("\n");
             *      else if (options[i][1].toLowerCase().equals("cr"))    setEOL("\r");
             *      else if (options[i][1].toLowerCase().equals("lf+cr")) setEOL("\n\r");
             *      else err.msg("End-of-line must be one of: Unix, Dos, NL, CR+LF, LF, CR, or LF+CR.");
             *      continue;
             *    }
             */
            if (options[i][0].toLowerCase().equals("-classlist")) {
                classlist = true;
                continue;
            }
            if (options[i][0].toLowerCase().equals("-title")) {
                if (options[i].length < 2)
                    err.msg("No title-string specified after -title option.");
                else setTitle(options[i][1]);
                continue;
            }
            if (options[i][0].toLowerCase().equals("-skippkg")) {
                if (options[i].length < 2)
                    err.msg("No list of qualified package patterns specified after -skipPkg option.");
                else setPkgSkipList(options[i][1]);
                continue;
            }
            if (options[i][0].toLowerCase().equals("-skipclass")) {
                if (options[i].length < 2)
                    err.msg("No list of qualified classname patterns specified after -skipPkg option.");
                else setClassSkipList(options[i][1]);
                continue;
            }
            if (options[i][0].toLowerCase().equals("-evident")) {
                if (options[i].length < 2)
                    err.msg("No error level specified after -evident option.");
                else try {
                        int n = Integer.parseInt(options[i][1]);
                        n = n - 1; // Convert 1-based error-level to 0-based
                        if ((n < 0) || (n >= ERR_CATEGORY_COUNT)) {
                            throw new Exception();
                        }
                        selfEvidentCommentLevel = n;
                    } catch (Exception e) {
                    System.err.println("Invalid error level specified after -evident option.");
                    System.err.println("  --Must be between 0 and " + (ERR_CATEGORY_COUNT - 1));
                    System.exit(1);
                }
                continue;
            }
            if (options[i][0].toLowerCase().equals("-execdepth")) {
                if (options[i].length < 2)
                    err.msg("No executive summary package-depth specified after -execDepth option.");
                else try {
                        int n = Integer.parseInt(options[i][1]);
                        if (n < 1) throw new Exception();
                        execDepth = n;
                    } catch (Exception e) {
                    System.err.println("-execDepth: Executive summary package-depth must be >= 1.");
                    System.exit(1);
                }
                continue;
            }
            if (options[i][0].toLowerCase().equals("-d")) {
                if (options[i].length < 2)
                    err.msg("No output-directory specified after -d option.");
                outputDir = options[i][1];
                File f = new File(outputDir);
                if (!f.exists()) {
                    // Check that dir exists, as a check against typos on
                    // the command line.
                    System.err.println("Error: Output directory " + outputDir);
                    System.err.println("  --Does not exist");
                    System.exit(1);
                }
                if (!f.isDirectory()) {
                    System.err.println("Error: File named " + outputDir + " exists");
                    System.err.println("  --Cannot be used as an output directory");
                    System.exit(1);
                }
                continue;
            }
            if (options[i][0].toLowerCase().equals("-docletid")) {
                docletID = true;
                continue;
            }
            if (options[i][0].toLowerCase().equals("-config")) {
                if (options[i].length < 2)
                    err.msg("Configuration file was not specified.");
                
                // Read options from the configuration file
                configFilename = options[i][1];
                try {
                    //TODO
                    File f = new File(configFilename);
                    Properties p = new Properties();
                    p.load(new FileInputStream(f));
                }
                catch (IOException ioe) {
                    System.err.println("Could not read file " + configFilename
                                           + "\nError: " + ioe.getMessage());
                }
                
                
                continue;
            }
            if (options[i][0].toLowerCase().equals("-help")) {
                System.err.println("Valid options:");
                System.err.println("  -authorID  <authorName>    (Default=\"unknown\")");
                System.err.println("  -versionID <versionString> (Default=\"%I" + "% %" + "G%\")");
                //Note: String above is broken up to prevent interpretation by SCCS
                /* Reenable this when HtmlTagWriter allows EOL specification
                 *     System.err.println("  -eol     NL, CR+LF, LF, CR, or LF+CR (Default=NL)");
                 */
                System.err.println("");
                System.err.println("  -classlist  (creates classErr.lst)");
                System.err.println("  -docletID   (identifies doclet version & indent amount)");
                System.err.println("  -title      (first line of report)");
                System.err.println("  -evident    (self-evident error level)");
                System.err.println("              (2=Tag, 3=Text, 4=Warn)");
                System.err.println("  -skipPkg    (list of fully qualified pkg name patterns)");
                System.err.println("  -skipClass  (list of fully qualified classname patterns)");
                System.err.println("  -execDepth  (executive summary package depth)");
                System.err.println("  -config     (name of file containing configuration options");
                System.err.println("               -- properties as doc'd in java.lang.properties#load");
                System.err.println("  -help       (generates this list)");
                System.err.println("");
                System.err.println("  -public     (public classes and members)");
                System.err.println("  -protected  (public and protected)");
                System.err.println("  -sourcepath (location of .java files)");
                System.err.println("  -docletpath (doclet classes)");
                System.err.println("  -classpath  (javadoc classes)");
                System.err.println("");
                System.err.println("Options to control generated text:");
                System.err.println("  -ifcTxt  -getTxt  -setTxt   -valTxt  -isTxt");
                System.err.println("  -cnrTxt  -objTxt  -bSetTxt  -bValTxt");
                System.err.println("");
                System.err.println("For more help, see DocCheck.html");
                System.exit(0);
            }
            if (options[i][0].toLowerCase().equals("-ifctxt"))    {
                ifc_clause = options[i][1];
                continue;
            }
            if (options[i][0].toLowerCase().equals("-gettxt"))    {
                get_clause = options[i][1];
                continue;
            }
            if (options[i][0].toLowerCase().equals("-settxt"))    {
                set_clause = options[i][1];
                continue;
            }
            if (options[i][0].toLowerCase().equals("-istxt"))     {
                is_clause = options[i][1];
                continue;
            }
            if (options[i][0].toLowerCase().equals("-valtxt"))    {
                val_clause = options[i][1];
                continue;
            }
            if (options[i][0].toLowerCase().equals("-cnrtxt"))    {
                cnr_clause = options[i][1];
                continue;
            }
            if (options[i][0].toLowerCase().equals("-objtxt"))    {
                obj_clause = options[i][1];
                continue;
            }
            if (options[i][0].toLowerCase().equals("-bsettxt"))   {
                bSet_clause = options[i][1];
                continue;
            }
            if (options[i][0].toLowerCase().equals("-bvaltxt"))   {
                bVal_clause = options[i][1];
                continue;
            }
        }//for
        return err.noErrorsFound;
    }// validOptions()
    
    /**
     * Inner class that checks to see if a method is implemented
     * by an interface the class declares or inherits. The list
     * of interfaces the class implements is built by the constructor
     * so that it only occurs once.
     */
    public class ICheck
    {
        private ClassDoc iClass;
        private List interfaceList = new Vector();
        
        ICheck(MethodDoc md) {
            this(md.containingClass());
        }
        
        ICheck(ClassDoc cd) {
            iClass = cd;
            while (cd != null) {
                // Collect implemented interfaces of this class and all superclasses
                ClassDoc[] iArr = cd.interfaces();
                List iList = Arrays.asList(iArr);
                interfaceList.addAll(iList);
                cd = cd.superclass();
            }
            // Look at all interfaces in the list to find interfaces they extend
            for (int i=0; i<interfaceList.size(); i++) {
                cd = (ClassDoc) interfaceList.get(i);
                ClassDoc[] iArr = cd.interfaces();
                for (int j=0; j<iArr.length; j++) {
                    // Append the extended interface to the end of the list
                    interfaceList.add(iArr[j]);
                }
            }
        }
        
        /**
         * Checks to see if the method implements an interface.
         * If so, the Standard doclet inherits the comment from that
         * interface.
         * <p>
         * Note:<br>
         * The ClassDoc.interfaces() method returns only the interfaces
         * <i>declared</i> by a class, not those it inherits.
         *
         * @param md  a MethodDoc object
         * @return a String containing the fully qualified name of the
         *         interface, or null
         */
        public String implementsInterface(MethodDoc md)
        {
            ClassDoc cd = md.containingClass();
            if (cd != iClass) {
                throw new RuntimeException("ICheck object for " + iClass
                                               + " called with method " + md + " from " + md.containingClass() );
            }
            ListIterator lit = interfaceList.listIterator();
            while (lit.hasNext()) {
                // Examine each interface
                ClassDoc interfaceDoc = (ClassDoc) lit.next();
                MethodDoc[] imethod = interfaceDoc.methods();
                for (int i=0; i<imethod.length; i++) {
                    // Examine each method in the interface
                    if (! imethod[i].name().equals(md.name()) ) continue;
                    if (! imethod[i].returnType().equals(md.returnType()) ) continue;
                    if (! imethod[i].signature().equals(md.signature()) ) continue;
                    // Matching method found
                    return interfaceDoc.qualifiedName();
                }
            }
            // No match
            return null;
        }
    }//ICheck
} //DocCheck

