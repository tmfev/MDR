<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Hibernate Envers - Easy Entity Auditing</title><link rel="stylesheet" href="css/hibernate-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e2"/>Hibernate Envers - Easy Entity Auditing</h1></div><div><h2 class="subtitle">Hibernate Envers Reference Documentation</h2></div><div><p class="releaseinfo">3.6.7.Final</p></div><div><p class="copyright">Copyright © 2004 Red Hat Inc.</p></div><div><a href="Legal_Notice.html">Legal Notice</a></div><div><p class="pubdate">August 17, 2011</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#quickstart">1. Quickstart</a></span></dt><dt><span class="chapter"><a href="#example">2. Short example</a></span></dt><dt><span class="chapter"><a href="#configuration">3. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#config-basics">3.1. Basic configuration</a></span></dt><dt><span class="section"><a href="#config-audit-strategy">3.2. Choosing an audit strategy</a></span></dt><dt><span class="section"><a href="#config-reference">3.3. Reference</a></span></dt></dl></dd><dt><span class="chapter"><a href="#revisionlog">4. Logging data for revisions</a></span></dt><dt><span class="chapter"><a href="#queries">5. Queries</a></span></dt><dd><dl><dt><span class="section"><a href="#entities-at-revision">5.1. Querying for entities of a class at a given revision</a></span></dt><dt><span class="section"><a href="#revisions-of-entity">5.2. Querying for revisions, at which entities of a given class changed</a></span></dt></dl></dd><dt><span class="chapter"><a href="#schema">6. Generating schema with Ant</a></span></dt><dt><span class="chapter"><a href="#tables">7. Generated tables and their content</a></span></dt><dt><span class="chapter"><a href="#partitioning">8. Audit table partitioning</a></span></dt><dd><dl><dt><span class="section"><a href="#partitioning-benefits">8.1. Benefits of audit table partitioning</a></span></dt><dt><span class="section"><a href="#partitioning-columns">8.2. Suitable columns for audit table partitioning</a></span></dt><dt><span class="section"><a href="#partitioning-example">8.3. Audit table partitioning example</a></span></dt><dd><dl><dt><span class="section"><a href="#partitioning-example-column">8.3.1. Determining a suitable partitioning column</a></span></dt><dt><span class="section"><a href="#partitioning-example-scheme">8.3.2. Determining a suitable partitioning scheme</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#source">9. Building from source and testing</a></span></dt><dd><dl><dt><span class="section"><a href="#source-checkout">9.1. Building from source</a></span></dt><dt><span class="section"><a href="#source-contributing">9.2. Contributing</a></span></dt><dt><span class="section"><a href="#source-tests">9.3. Envers integration tests</a></span></dt></dl></dd><dt><span class="chapter"><a href="#exceptions">10. Mapping exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="#exceptions-wontbesupported">10.1. What isn't and will not be supported</a></span></dt><dt><span class="section"><a href="#exceptions-willbesupported">10.2. What isn't and will be supported</a></span></dt><dt><span class="section"><a href="#exceptions-onetomanyjoincolumn">10.3. @OneToMany+@JoinColumn</a></span></dt></dl></dd><dt><span class="chapter"><a href="#migration">11. Migration from Envers standalone</a></span></dt><dd><dl><dt><span class="section"><a href="#migrations-code">11.1. Changes to code</a></span></dt><dt><span class="section"><a href="#migrations-configuration">11.2. Changes to configuration</a></span></dt><dt><span class="section"><a href="#migrations-revisionlog">11.3. Changes to the revision entity</a></span></dt></dl></dd><dt><span class="chapter"><a href="#links">12. Links</a></span></dt></dl></div><div class="preface" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Preface</h2></div></div></div><p>
        The Envers project aims to enable easy auditing of persistent classes. All that you
        have to do is annotate your persistent class or some of its properties, that you
        want to audit, with <code class="literal">@Audited</code>. For each audited entity, a table
        will be created, which will hold the history of changes made to the entity. You
        can then retrieve and query historical data without much effort.
    </p><p>
        Similarly to Subversion, the library has a concept of revisions. Basically, one
        transaction is one revision (unless the transaction didn't modify any audited entities).
        As the revisions are global, having a revision number, you can query for various
        entities at that revision, retrieving a (partial) view of the database at that
        revision. You can find a revision number having a date, and the other way round,
        you can get the date at which a revision was commited.
    </p><p>
        The library works with Hibernate and requires Hibernate Annotations or Entity Manager.
        For the auditing to work properly, the entities must have immutable unique
        identifiers (primary keys). You can use Envers wherever Hibernate works:
        standalone, inside JBoss AS, with JBoss Seam or Spring.
    </p><p>
        Some of the features:
    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                auditing of all mappings defined by the JPA specification
            </p></li><li><p>
                auditing of Hibernate mappings, which extend JPA, like custom types and
                collections/maps of "simple" types (Strings, Integers, etc.)
                (see also <a class="xref" href="#exceptions" title="Chapter 10. Mapping exceptions">Chapter 10, <i>Mapping exceptions</i></a>)
            </p></li><li><p>
                logging data for each revision using a "revision entity"
            </p></li><li><p>
                querying historical data
            </p></li></ol></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="quickstart"/>Chapter 1. Quickstart</h2></div></div></div><p>
        If you're using JPA, when coniguring Hibernate (in <code class="literal">persistence.xml</code>), add the following event
        listeners: (this will allow Envers to check if any audited entities were modified)
    </p><pre class="programlisting">&lt;persistence-unit ...&gt;
&lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
&lt;class&gt;...&lt;/class&gt;
&lt;properties&gt;
   &lt;property name="hibernate.dialect" ... /&gt;
   &lt;!-- other hibernate properties --&gt;

   &lt;property name="hibernate.ejb.event.post-insert"
             value="org.hibernate.ejb.event.EJB3PostInsertEventListener,org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.post-update"
             value="org.hibernate.ejb.event.EJB3PostUpdateEventListener,org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.post-delete"
             value="org.hibernate.ejb.event.EJB3PostDeleteEventListener,org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.pre-collection-update"
             value="org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.pre-collection-remove"
             value="org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.post-collection-recreate"
             value="org.hibernate.envers.event.AuditEventListener" /&gt;
&lt;/properties&gt;
&lt;/persistence-unit&gt;</pre><p>
	If you're using  Hibernate directly, add the following to <code class="literal">hibernate.cfg.xml</code>:
    </p><pre class="programlisting">
	&lt;hibernate-configuration&gt;
	&lt;session-factory&gt;

	&lt;listener class="org.hibernate.envers.event.AuditEventListener" type="post-insert"/&gt;
	&lt;listener class="org.hibernate.envers.event.AuditEventListener" type="post-update"/&gt;
	&lt;listener class="org.hibernate.envers.event.AuditEventListener" type="post-delete"/&gt;
	&lt;listener class="org.hibernate.envers.event.AuditEventListener" type="pre-collection-update"/&gt;
	&lt;listener class="org.hibernate.envers.event.AuditEventListener" type="pre-collection-remove"/&gt;
	&lt;listener class="org.hibernate.envers.event.AuditEventListener" type="post-collection-recreate"/&gt;


	&lt;/session-factory&gt;
	&lt;/hibernate-configuration&gt;
    </pre><p>
        The <code class="literal">EJB3Post...EvenListener</code>s are needed, so that ejb3 entity lifecycle callback
        methods work (<code class="literal">@PostPersist, @PostUpdate, @PostRemove</code>.
    </p><p>
        Then, annotate your persistent class with <code class="literal">@Audited</code> - this will make all
        properties audited. For example:
    </p><pre class="programlisting">import org.hibernate.envers.Audited;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Column;

@Entity
@Audited // that's the important part :)
public class Person {
    @Id
    @GeneratedValue
    private int id;

    private String name;

    private String surname;

    @ManyToOne
    private Address address;

    // add getters, setters, constructors, equals and hashCode here
}</pre><p>
        And the referenced entity:
    </p><pre class="programlisting">@Entity
@Audited
public class Address {
    @Id
    @GeneratedValue
    private int id;

    private String streetName;

    private Integer houseNumber;

    private Integer flatNumber;

    @OneToMany(mappedBy = "address")
    private Set&lt;Person&gt; persons;

    // add getters, setters, constructors, equals and hashCode here
}
</pre><p>
        And that's it! You create, modify and delete the entites as always. If you look
        at the generated schema, you will notice that it is unchanged by adding auditing
        for the Address and Person entities. Also, the data they hold is the same. There are,
        however, two new tables - <code class="literal">Address_AUD</code> and <code class="literal">Person_AUD</code>,
        which store the historical data, whenever you commit a transaction.
    </p><p>
        Instead of annotating the whole class and auditing all properties, you can annotate
        only some persistent properties with <code class="literal">@Audited</code>. This will cause only
        these properties to be audited.
    </p><p>
        You can access the audit (history) of an entity using the <code class="literal">AuditReader</code> interface, which you
        can obtain when having an open EntityManager.
    </p><pre class="programlisting">AuditReader reader = AuditReaderFactory.get(entityManager);
Person oldPerson = reader.find(Person.class, personId, revision)
</pre><p>
        The <code class="literal">T find(Class&lt;T&gt; cls, Object primaryKey, Number revision)</code>
        method returns an entity with the given primary key, with the data it contained at
        the given revision. If the entity didn't exist at this revision, <code class="literal">null</code>
        is returned. Only the audited properties will be set on the returned entity.
        The rest will be <code class="literal">null</code>.
    </p><p>
        You can also get a list of revisions at which an entity was modified using the
        <code class="literal">getRevisions</code> method, as well as retrieve the date,
        at which a revision was created using the <code class="literal">getRevisionDate</code> method.
    </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="example"/>Chapter 2. Short example</h2></div></div></div><p>
        For example, using the entities defined above, the following code will generate
        revision number 1, which will contain two new <code class="literal">Person</code> and
        two new <code class="literal">Address</code> entities:
    </p><pre class="programlisting">entityManager.getTransaction().begin();

Address address1 = new Address("Privet Drive", 4);
Person person1 = new Person("Harry", "Potter", address1);

Address address2 = new Address("Grimmauld Place", 12);
Person person2 = new Person("Hermione", "Granger", address2);

entityManager.persist(address1);
entityManager.persist(address2);
entityManager.persist(person1);
entityManager.persist(person2);

entityManager.getTransaction().commit();</pre><p>
        Now we change some entities. This will generate revision number 2, which will contain
        modifications of one person entity and two address entities (as the collection of
        persons living at <code class="literal">address2</code> and <code class="literal">address1</code> changes):
    </p><pre class="programlisting">entityManager.getTransaction().begin();

Address address1 = entityManager.find(Address.class, address1.getId());
Person person2 = entityManager.find(Person.class, person2.getId());

// Changing the address's house number
address1.setHouseNumber(5)

// And moving Hermione to Harry
person2.setAddress(address1);

entityManager.getTransaction().commit();</pre><p>
        We can retrieve the old versions (the audit) easily:
    </p><pre class="programlisting">AuditReader reader = AuditReaderFactory.get(entityManager);

Person person2_rev1 = reader.find(Person.class, person2.getId(), 1);
assert person2_rev1.getAddress().equals(new Address("Grimmauld Place", 12));

Address address1_rev1 = reader.find(Address.class, address1.getId(), 1);
assert address1_rev1.getPersons().getSize() == 1;

// and so on</pre></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="configuration"/>Chapter 3. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#config-basics">3.1. Basic configuration</a></span></dt><dt><span class="section"><a href="#config-audit-strategy">3.2. Choosing an audit strategy</a></span></dt><dt><span class="section"><a href="#config-reference">3.3. Reference</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="config-basics"/>3.1. Basic configuration</h2></div></div></div><p>
        To start working with Envers, all configuration that you must do is add the event
        listeners to persistence.xml, as described in the <a class="xref" href="#quickstart" title="Chapter 1. Quickstart">Chapter 1, <i>Quickstart</i></a>.
     </p><p>
        However, as Envers generates some entities, and maps them to tables, it is possible to set the prefix and suffix
        that is added to the entity name to create an audit table for an entity, as well
        as set the names of the fields that are generated.
     </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="config-audit-strategy"/>3.2. Choosing an audit strategy</h2></div></div></div><p>
        After the basic configuration it is important to choose the audit strategy that will be used to persist and 
        retrieve audit information. There is a trade-off is between the performance of persisting and the performance  
        of querying the audit information. Currently there two audit strategies:

        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                   The default audit strategy persists the audit data together with a start revision. For each row 
                   inserted, updated or deleted in an audited table, one or more rows are inserted in the audit tables,
                   together with the start revision of its validity. Rows in the audit tables are never updated after insertion. 
                   Queries of audit information use subqueries to select the applicable rows in the audit tables.
                   These subqueries are notoriously slow and difficult to index. 
             </p></li><li><p>
                   The alternative is a validity audit strategy. This strategy stores the start-revision and the end-revision 
                   of audit information. For each row inserted, updated or deleted in an audited table, one or more rows
                   are inserted in the audit tables, together with the start revision of its validity. But at the same time 
                   the end-revision field of the previous audit rows (if available) are set to this revision. 
                   Queries on the audit information can then use 'between start and end revision' instead of subqueries 
                   as used by the default audit strategy. 
                   The consequence of this strategy is that persisting audit information will be a bit slower, because of the  
                   extra updates involved, but retrieving audit information will be a lot faster. This can be improved by
                   adding extra indexes.
             </p></li></ol></div><p>
     </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="config-reference"/>3.3. Reference</h2></div></div></div><p>
        In more detail, here are the properties that you can set:
    </p><div class="table"><a id="d0e252"/><p class="title"><b>Table 3.1. Envers Configuration Properties</b></p><div class="table-contents"><table summary="Envers Configuration Properties" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Property name</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td>
                        <span class="property">org.hibernate.envers.audit_table_prefix</span>
                    </td><td>

                    </td><td>
                        String that will be prepended to the name of an audited entity to create
                        the name of the entity, that will hold audit information.
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.audit_table_suffix</span>
                    </td><td>
                        _AUD
                    </td><td>
                        String that will be appended to the name of an audited entity to create
                        the name of the entity, that will hold audit information. If you
                        audit an entity with a table name Person, in the default setting Envers
                        will generate a <code class="literal">Person_AUD</code> table to store historical data.
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.revision_field_name</span>
                    </td><td>
                        REV
                    </td><td>
                        Name of a field in the audit entity that will hold the revision number.
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.revision_type_field_name</span>
                    </td><td>
                        REVTYPE
                    </td><td>
                        Name of a field in the audit entity that will hold the type of the
                        revision (currently, this can be: add, mod, del).
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.revision_on_collection_change</span>
                    </td><td>
                        true
                    </td><td>
                        Should a revision be generated when a not-owned relation field changes
                        (this can be either a collection in a one-to-many relation, or the field
                        using "mappedBy" attribute in a one-to-one relation).
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.do_not_audit_optimistic_locking_field</span>
                    </td><td>
                        true
                    </td><td>
                        When true, properties to be used for optimistic locking, annotated with
                        <code class="literal">@Version</code>, will be automatically not audited
                        (their history won't be stored; it normally doesn't make sense to store it).
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.store_data_at_delete</span>
                    </td><td>
                        false
                    </td><td>
                        Should the entity data be stored in the revision when the entity is deleted (instead of only
                        storing the id and all other properties as null). This is not normally needed, as the data is
                        present in the last-but-one revision. Sometimes, however, it is easier and more efficient to
                        access it in the last revision (then the data that the entity contained before deletion is
                        stored twice).
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.default_schema</span>
                    </td><td>
                        null (same as normal tables)
                    </td><td>
                        The default schema name that should be used for audit tables. Can be overriden using the
                        <code class="literal">@AuditTable(schema="...")</code> annotation. If not present, the schema will
                        be the same as the schema of the normal tables.
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.default_catalog</span>
                    </td><td>
                        null (same as normal tables)
                    </td><td>
                        The default catalog name that should be used for audit tables. Can be overriden using the
                        <code class="literal">@AuditTable(catalog="...")</code> annotation. If not present, the catalog will
                        be the same as the catalog of the normal tables.                        
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.audit_strategy</span>
                    </td><td>
                        org.hibernate.envers.strategy.DefaultAuditStrategy
                    </td><td>
                        The audit strategy that should be used when persisting audit data. The default stores only the
                        revision, at which an entity was modified. An alternative, the
                        <code class="literal">org.hibernate.envers.strategy.ValidityAuditStrategy</code> stores both the
                        start revision and the end revision. Together these define when an audit row was valid, hence 
                        the name ValidityAuditStrategy. 
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.audit_strategy_validity_end_rev_field_name</span>
                    </td><td>
                        REVEND
                    </td><td>
                        The column name that will hold the end revision number in audit entities. This property is only 
                        valid if the validity audit strategy is used.
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</span>
                    </td><td>
                        false
                    </td><td>
                        Should the timestamp of the end revision be stored, until which the data was valid, in addition to the end revision itself. 
                        This is useful to be able to purge old Audit records out of a relational database by using table partitioning. 
                        Partitioning requires a column that exists within the table.
                        This property is only evaluated if the ValidityAuditStrategy is used.
                    </td></tr><tr><td>
                        <span class="property">org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</span>
                    </td><td>
                        REVEND_TSTMP
                    </td><td>
                        Column name of the timestamp of the end revision until which the data was valid.
                        Only used if the ValidityAuditStrategy is used, and 
                        org.hibernate.envers.audit_strategy_validity_store_revend_timestamp evaluates to true
                    </td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
            The following configuration options have been added recently and should be regarded as experimental: 
            </p><div class="orderedlist"><ol><li>
                    org.hibernate.envers.audit_strategy
                </li><li>
                    org.hibernate.envers.audit_strategy_validity_end_rev_field_name
                </li><li>
                    org.hibernate.envers.audit_strategy_validity_store_revend_timestamp 
                </li><li>
                    org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name
                </li></ol></div><p>
        </p></div><p>
        To change the name of the revision table and its fields (the table, in which the
        numbers of revisions and their timestamps are stored), you can use the
        <code class="literal">@RevisionEntity</code> annotation.
        For more information, see <a class="xref" href="#revisionlog" title="Chapter 4. Logging data for revisions">Chapter 4, <i>Logging data for revisions</i></a>.
    </p><p>
        To set the value of any of the properties described above, simply add an entry to
        your <code class="literal">persistence.xml</code>. For example:
    </p><pre class="programlisting">&lt;persistence-unit ...&gt;
&lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
&lt;class&gt;...&lt;/class&gt;
&lt;properties&gt;
   &lt;property name="hibernate.dialect" ... /&gt;
   &lt;!-- other hibernate properties --&gt;

   &lt;property name="hibernate.ejb.event.post-insert"
             value="org.hibernate.ejb.event.EJB3PostInsertEventListener,org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.post-update"
             value="org.hibernate.ejb.event.EJB3PostUpdateEventListener,org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.post-delete"
             value="org.hibernate.ejb.event.EJB3PostDeleteEventListener,org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.pre-collection-update"
             value="org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.pre-collection-remove"
             value="org.hibernate.envers.event.AuditEventListener" /&gt;
   &lt;property name="hibernate.ejb.event.post-collection-recreate"
             value="org.hibernate.envers.event.AuditEventListener" /&gt;

   &lt;property name="org.hibernate.envers.versionsTableSuffix" value="_V" /&gt;
   &lt;property name="org.hibernate.envers.revisionFieldName" value="ver_rev" /&gt;
   &lt;!-- other envers properties --&gt;
&lt;/properties&gt;
&lt;/persistence-unit&gt;</pre><p>
        The <code class="literal">EJB3Post...EvenListener</code>s are needed, so that ejb3 entity lifecycle callback
        methods work (<code class="literal">@PostPersist, @PostUpdate, @PostRemove</code>.
    </p><p>
        You can also set the name of the audit table on a per-entity basis, using the
        <code class="literal">@AuditTable</code> annotation. It may be tedious to add this
        annotation to every audited entity, so if possible, it's better to use a prefix/suffix.
    </p><p>
        If you have a mapping with secondary tables, audit tables for them will be generated in
        the same way (by adding the prefix and suffix). If you wish to overwrite this behaviour,
        you can use the <code class="literal">@SecondaryAuditTable</code> and
        <code class="literal">@SecondaryAuditTables</code> annotations.
    </p><p>
        If you'd like to override auditing behaviour of some fields/properties in an embedded component, you can use
        the <code class="literal">@AuditOverride(s)</code> annotation on the place where you use the component.
    </p><p>
        If you want to audit a relation mapped with <code class="literal">@OneToMany+@JoinColumn</code>,
        please see <a class="xref" href="#exceptions" title="Chapter 10. Mapping exceptions">Chapter 10, <i>Mapping exceptions</i></a> for a description of the additional
        <code class="literal">@AuditJoinTable</code>  annotation that you'll probably want to use.
    </p><p>
        If you want to audit a relation, where the target entity is not audited (that is the case for example with
        dictionary-like entities, which don't change and don't have to be audited), just annotate it with
        <code class="literal">@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)</code>. Then, when reading historic
        versions of your entity, the relation will always point to the "current" related entity.
    </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="revisionlog"/>Chapter 4. Logging data for revisions</h2></div></div></div><p>
        Envers provides an easy way to log additional data for each revision. You simply need
        to annotate one entity with <code class="literal">@RevisionEntity</code>, and a new instance of
        this entity will be persisted when a new revision is created (that is, whenever an
        audited entity is modified). As revisions are global, you can have at most one revisions entity.
    </p><p>
        Please note that the revision entity must be a mapped Hibernate entity.
    </p><p>
        This entity must have at least two properties:
    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                an integer- or long-valued property, annotated with <code class="literal">@RevisionNumber</code>. Most
                often, this will be an auto-generated primary key.
            </p></li><li><p>
                a long- or j.u.Date- valued property, annotated with <code class="literal">@RevisionTimestamp</code>. Value of
                this property will be automatically set by Envers.
            </p></li></ol></div><p>
        You can either add these properties to your entity, or extend
        <code class="literal">org.hibernate.envers.DefaultRevisionEntity</code>, which already has those two properties.
    </p><p>
        When using a <code class="literal">Date</code>, instead of a <code class="literal">long/Long</code> for the revision timestamp,
        take care not to use a mapping of the property which will loose precision (for example, using
        <code class="literal">@Temporal(DATE)</code> is wrong, as it doesn't store the time information, so many of your
        revisions will appear to happen at exactly the same time). A good choice is a
        <code class="literal">@Temporal(TIMESTAMP)</code>.
    </p><p>
        To fill the entity with additional data, you'll need to implement the
        <code class="literal">org.jboss.envers.RevisionListener</code> interface. Its newRevision method will
        be called when a new revision is created, before persisting the revision entity.
        The implementation should be stateless and thread-safe. The listener then has to be
        attached to the revisions entity by specifying it as a parameter to the
        <code class="literal">@RevisionEntity</code> annotation.
    </p><p>
        Alternatively, you can use the <code class="literal">getCurrentRevision</code> method of the 
        <code class="literal">AuditReader</code> interface to obtain the current revision, and fill it with desired information.
        The method has a <code class="literal">persist</code> parameter specifying, if the revision entity should be persisted
        before returning. If set to <code class="literal">true</code>, the revision number will be available in the returned
        revision entity (as it is normally generated by the database), but the revision entity will be persisted
        regardless of wheter there are any audited entities changed. If set to <code class="literal">false</code>, the revision
        number will be <code class="literal">null</code>, but the revision entity will be persisted only if some audited entities
        have changed.
    </p><p>
        A simplest example of a revisions entity, which with each revision associates the
        username of the user making the change is:
    </p><pre class="programlisting">package org.jboss.envers.example;

import org.hibernate.envers.RevisionEntity;
import org.hibernate.envers.DefaultRevisionEntity;

import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity extends DefaultRevisionEntity {
	private String username;

	public String getUsername() { return username; }
	public void setUsername(String username) { this.username = username; }
}</pre><p>
        Or, if you don't want to extend any class:
    </p><pre class="programlisting">package org.hibernate.envers.example;

import org.hibernate.envers.RevisionNumber;
import org.hibernate.envers.RevisionTimestamp;
import org.hibernate.envers.RevisionEntity;

import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity {
    @Id
    @GeneratedValue
    @RevisionNumber
    private int id;

    @RevisionTimestamp
    private long timestamp;

    private String username;

    // Getters, setters, equals, hashCode ...
}</pre><p>
        An example listener, which, if used in a JBoss Seam application, stores the
        currently logged in user username:
    </p><pre class="programlisting">package org.hibernate.envers.example;

import org.hibernate.envers.RevisionListener;
import org.jboss.seam.security.Identity;
import org.jboss.seam.Component;

public class ExampleListener implements RevisionListener {
    public void newRevision(Object revisionEntity) {
        ExampleRevEntity exampleRevEntity = (ExampleRevEntity) revisionEntity;
        Identity identity = (Identity) Component.getInstance("org.jboss.seam.security.identity");

        exampleRevEntity.setUsername(identity.getUsername());
    }
}</pre><p>
        Having an "empty" revision entity - that is, with no additional properties except the
        two mandatory ones - is also an easy way to change the names of the table and of the
        properties in the revisions table automatically generated by Envers.
    </p><p>
        In case there is no entity annotated with <code class="literal">@RevisionEntity</code>, a default
        table will be generated, with the name <code class="literal">REVINFO</code>.
    </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="queries"/>Chapter 5. Queries</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#entities-at-revision">5.1. Querying for entities of a class at a given revision</a></span></dt><dt><span class="section"><a href="#revisions-of-entity">5.2. Querying for revisions, at which entities of a given class changed</a></span></dt></dl></div><p>
        You can think of historic data as having two dimension. The first - horizontal -
        is the state of the database at a given revision. Thus, you can
        query for entities as they were at revision N. The second - vertical - are the
        revisions, at which entities changed. Hence, you can query for revisions,
        in which a given entity changed.
    </p><p>
        The queries in Envers are similar to
        <a class="ulink" href="http://www.hibernate.org/hib_docs/v3/reference/en/html/querycriteria.html">Hibernate Criteria</a>,
        so if you are common with them, using Envers queries will be much easier.
    </p><p>
        The main limitation of the current queries implementation is that you cannot
        traverse relations. You can only specify constraints on the ids of the
        related entities, and only on the "owning" side of the relation. This however
        will be changed in future releases.
    </p><p>
        Please note, that queries on the audited data will be in many cases much slower
        than corresponding queries on "live" data, as they involve correlated subselects.
    </p><p>
        In the future, queries will be improved both in terms of speed and possibilities, when using the valid-time
        audit strategy, that is when storing both start and end revisions for entities. See
        <a class="xref" href="#configuration" title="Chapter 3. Configuration">Chapter 3, <i>Configuration</i></a>.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="entities-at-revision"/>5.1. Querying for entities of a class at a given revision</h2></div></div></div><p>
            The entry point for this type of queries is:
        </p><pre class="programlisting">AuditQuery query = getAuditReader().createQuery().forEntitiesAtRevision(MyEntity.class, revisionNumber);</pre><p>
            You can then specify constraints, which should be met by the entities returned, by
            adding restrictions, which can be obtained using the <code class="literal">AuditEntity</code>
            factory class. For example, to select only entities, where the "name" property
            is equal to "John":
        </p><pre class="programlisting">query.add(AuditEntity.property("name").eq("John"));</pre><p>
            And to select only entites that are related to a given entity:
        </p><pre class="programlisting">query.add(AuditEntity.property("address").eq(relatedEntityInstance));
// or
query.add(AuditEntity.relatedId("address").eq(relatedEntityId));</pre><p>
            You can limit the number of results, order them, and set aggregations and projections
            (except grouping) in the usual way.
            When your query is complete, you can obtain the results by calling the
            <code class="literal">getSingleResult()</code> or <code class="literal">getResultList()</code> methods.
        </p><p>
            A full query, can look for example like this:
        </p><pre class="programlisting">List personsAtAddress = getAuditReader().createQuery()
    .forEntitiesAtRevision(Person.class, 12)
    .addOrder(AuditEntity.property("surname").desc())
    .add(AuditEntity.relatedId("address").eq(addressId))
    .setFirstResult(4)
    .setMaxResults(2)
    .getResultList();</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="revisions-of-entity"/>5.2. Querying for revisions, at which entities of a given class changed</h2></div></div></div><p>
            The entry point for this type of queries is:
        </p><pre class="programlisting">AuditQuery query = getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true);</pre><p>
            You can add constraints to this query in the same way as to the previous one.
            There are some additional possibilities:
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                using <code class="literal">AuditEntity.revisionNumber()</code> you can specify constraints, projections
                and order on the revision number, in which the audited entity was modified
                </p></li><li><p>
                similarly, using <code class="literal">AuditEntity.revisionProperty(propertyName)</code> you can specify constraints,
                projections and order on a property of the revision entity, corresponding to the revision
                in which the audited entity was modified
                </p></li><li><p>
                <code class="literal">AuditEntity.revisionType()</code> gives you access as above to the type of
                the revision (ADD, MOD, DEL).
                </p></li></ol></div><p>
            Using these methods,
            you can order the query results by revision number, set projection or constraint
            the revision number to be greater or less than a specified value, etc. For example, the
            following query will select the smallest revision number, at which entity of class
            <code class="literal">MyEntity</code> with id <code class="literal">entityId</code> has changed, after revision
            number 42:
        </p><pre class="programlisting">Number revision = (Number) getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true)
    .setProjection(AuditEntity.revisionNumber().min())
    .add(AuditEntity.id().eq(entityId))
    .add(AuditEntity.revisionNumber().gt(42))
    .getSingleResult();</pre><p>
            The second additional feature you can use in queries for revisions is the ability
            to maximalize/minimize a property. For example, if you want to select the
            revision, at which the value of the <code class="literal">actualDate</code> for a given entity
            was larger then a given value, but as small as possible:
        </p><pre class="programlisting">Number revision = (Number) getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true)
    // We are only interested in the first revision
    .setProjection(AuditEntity.revisionNumber().min())
    .add(AuditEntity.property("actualDate").minimize()
        .add(AuditEntity.property("actualDate").ge(givenDate))
        .add(AuditEntity.id().eq(givenEntityId)))
    .getSingleResult();
</pre><p>
            The <code class="literal">minimize()</code> and <code class="literal">maximize()</code> methods return a criteria,
            to which you can add constraints, which must be met by the entities with the
            maximized/minimized properties.
        </p><p>
            You probably also noticed that there are two boolean parameters, passed when
            creating the query. The first one, <code class="literal">selectEntitiesOnly</code>, is only valid when
            you don't set an explicit projection. If true, the result of the query will be
            a list of entities (which changed at revisions satisfying the specified
            constraints).
        </p><p>
            If false, the result will be a list of three element arrays. The
            first element will be the changed entity instance. The second will be an entity
            containing revision data (if no custom entity is used, this will be an instance
            of <code class="literal">DefaultRevisionEntity</code>). The third will be the type of the
            revision (one of the values of the <code class="literal">RevisionType</code> enumeration:
            ADD, MOD, DEL).
        </p><p>
            The second parameter, <code class="literal">selectDeletedEntities</code>, specifies if revisions,
            in which the entity was deleted should be included in the results. If yes, such entities
            will have the revision type DEL and all fields, except the id,
            <code class="literal">null</code>.
        </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="schema"/>Chapter 6. Generating schema with Ant</h2></div></div></div><p>
        If you'd like to generate the database schema file with the Hibernate Tools Ant task,
        you'll probably notice that the generated file doesn't contain definitions of audit
        tables. To generate also the audit tables, you simply need to use 
        <code class="literal">org.hibernate.tool.ant.EnversHibernateToolTask</code> instead of the usual
        <code class="literal">org.hibernate.tool.ant.HibernateToolTask</code>. The former class extends
        the latter, and only adds generation of the version entities. So you can use the task
        just as you used to.
    </p><p>
        For example:
    </p><pre class="programlisting">&lt;target name="schemaexport" depends="build-demo"
  description="Exports a generated schema to DB and file"&gt;
  &lt;taskdef name="hibernatetool"
    classname="org.hibernate.tool.ant.EnversHibernateToolTask"
    classpathref="build.demo.classpath"/&gt;

  &lt;hibernatetool destdir="."&gt;
    &lt;classpath&gt;
      &lt;fileset refid="lib.hibernate" /&gt;
      &lt;path location="${build.demo.dir}" /&gt;
      &lt;path location="${build.main.dir}" /&gt;
    &lt;/classpath&gt;
    &lt;jpaconfiguration persistenceunit="ConsolePU" /&gt;
    &lt;hbm2ddl
      drop="false"
      create="true"
      export="false"
      outputfilename="versioning-ddl.sql"
      delimiter=";"
      format="true"/&gt;
  &lt;/hibernatetool&gt;
&lt;/target&gt;</pre><p>
        Will generate the following schema:
    </p><pre class="programlisting">
    create table Address (
        id integer generated by default as identity (start with 1),
        flatNumber integer,
        houseNumber integer,
        streetName varchar(255),
        primary key (id)
    );

    create table Address_AUD (
        id integer not null,
        REV integer not null,
        flatNumber integer,
        houseNumber integer,
        streetName varchar(255),
        REVTYPE tinyint,
        primary key (id, REV)
    );

    create table Person (
        id integer generated by default as identity (start with 1),
        name varchar(255),
        surname varchar(255),
        address_id integer,
        primary key (id)
    );

    create table Person_AUD (
        id integer not null,
        REV integer not null,
        name varchar(255),
        surname varchar(255),
        REVTYPE tinyint,
        address_id integer,
        primary key (id, REV)
    );

    create table REVINFO (
        REV integer generated by default as identity (start with 1),
        REVTSTMP bigint,
        primary key (REV)
    );

    alter table Person
        add constraint FK8E488775E4C3EA63
        foreign key (address_id)
        references Address;
    </pre></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="tables"/>Chapter 7. Generated tables and their content</h2></div></div></div><p>
        For each audited entity (that is, for each entity containing at least one audited field), an audit
        table is created. By default, the audit table's name is created by adding a "_AUD" suffix to
        the original name, but this can be overriden by specifing a different suffix/prefix
        (see <a class="xref" href="#configuration" title="Chapter 3. Configuration">Chapter 3, <i>Configuration</i></a>) or on a per-entity basis using the
        <code class="literal">@AuditTable</code> annotation.
    </p><p>
        The audit table has the following fields:
    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                id of the original entity (this can be more then one column, if using an embedded or multiple id)
            </p></li><li><p>
                revision number - an integer
            </p></li><li><p>
                revision type - a small integer
            </p></li><li><p>
                audited fields from the original entity
            </p></li></ol></div><p>
        The primary key of the audit table is the combination of the original id of the
        entity and the revision number - there can be at most one historic entry for a given
        entity instance at a given revision.
    </p><p>
        The current entity data is stored in the original table and in the audit table.
        This is a duplication of data, however as this solution makes the query system much more
        powerful, and as memory is cheap, hopefully this won't be a major drawback for the users.
        A row in the audit table with entity id ID, revision N and data D means:
        entity with id ID has data D from revision N upwards. Hence, if we want to find an
        entity at revision M, we have to search for a row in the audit table, which has the
        revision number smaller or equal to M, but as large as possible. If no such row is
        found, or a row with a "deleted" marker is found, it means that the entity didn't
        exist at that revision.
    </p><p>
        The "revision type" field can currently have three values: 0, 1, 2, which means,
        respectively, ADD, MOD and DEL. A row with a revision of type DEL will only contain the
        id of the entity and no data (all fields NULL), as it only serves as a marker saying
        "this entity was deleted at that revision".
    </p><p>
        Additionaly, there is a "REVINFO" table generated, which contains only two fields:
        the revision id and revision timestamp. A row is inserted into this table on each
        new revision, that is, on each commit of a transaction, which changes audited data.
        The name of this table can be configured, as well as additional content stored,
        using the <code class="literal">@RevisionEntity</code> annotation, see <a class="xref" href="#revisionlog" title="Chapter 4. Logging data for revisions">Chapter 4, <i>Logging data for revisions</i></a>.
    </p><p>
        While global revisions are a good way to provide correct auditing of relations,
        some people have pointed out that this may be a bottleneck in systems, where data
        is very often modified. One viable solution is to introduce an option to have an
        entity "locally revisioned", that is revisions would be created for it independently.
        This wouldn't enable correct versioning of relations, but wouldn't also require the
        "REVINFO" table. Another possibility if to have "revisioning groups", that is groups
        of entities which share revision numbering. Each such group would have to consist
        of one or more strongly connected component of the graph induced by relations between
        entities. Your opinions on the subject are very welcome on the forum! :)
    </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="partitioning"/>Chapter 8. Audit table partitioning</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#partitioning-benefits">8.1. Benefits of audit table partitioning</a></span></dt><dt><span class="section"><a href="#partitioning-columns">8.2. Suitable columns for audit table partitioning</a></span></dt><dt><span class="section"><a href="#partitioning-example">8.3. Audit table partitioning example</a></span></dt><dd><dl><dt><span class="section"><a href="#partitioning-example-column">8.3.1. Determining a suitable partitioning column</a></span></dt><dt><span class="section"><a href="#partitioning-example-scheme">8.3.2. Determining a suitable partitioning scheme</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="partitioning-benefits"/>8.1. Benefits of audit table partitioning</h2></div></div></div><p>
            Because audit tables tend to grow indefinitely they can quickly become really large. When the audit tables have grown
            to a certain limit (varying per RDBMS and/or operating system) it makes sense to start using table partitioning.
            SQL table partitioning offers a lot of advantages including, but certainly not limited to:
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                        Improved query performance by selectively moving rows to various partitions (or even purging old rows)
                    </p></li><li><p>
                        Faster data loads, index creation, etc.
                    </p></li></ol></div><p>
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="partitioning-columns"/>8.2. Suitable columns for audit table partitioning</h2></div></div></div><p>         
            Generally SQL tables must be partitioned on a column that exists within the table. As a rule it makes sense to use
            either the <span class="emphasis"><em>end revision</em></span> or the <span class="emphasis"><em>end revision timestamp</em></span> column for 
            partioning of audit tables.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                    End revision information is not available for the default AuditStrategy. 
                </p><p>
                    Therefore the following Envers configuration options are required: 
                </p><p>
                    <code class="literal">org.hibernate.envers.audit_strategy</code> = 
                    <code class="literal">org.hibernate.envers.strategy.ValidityAuditStrategy</code>
                </p><p>
                    <code class="literal">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code> = 
                    <code class="literal">true</code>
                </p><p>
                    Optionally, you can also override the default values following properties: 
                </p><p>
                    <code class="literal">org.hibernate.envers.audit_strategy_validity_end_rev_field_name</code>
                </p><p>
                    <code class="literal">org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</code>
                </p><p>
                    For more information, see <a class="xref" href="#configuration" title="Chapter 3. Configuration">Chapter 3, <i>Configuration</i></a>.
                </p></div><p>
        </p><p>
           The reason why the end revision information should be used for audit table partioning is based on the assumption that
           audit tables should be partionioned on an 'increasing level of interestingness', like so: 
        </p><p>
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                        A couple of partitions with audit data that is not very (or no longer) interesting. 
                        This can be stored on slow media, and perhaps even be purged eventually.  
                    </p></li><li><p>
                        Some partitions for audit data that is potentially interesting.
                    </p></li><li><p>
                        One partition for audit data that is most likely to be interesting. 
                        This should be stored on the fastest media, both for reading and writing.  
                    </p></li></ol></div><p>
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="partitioning-example"/>8.3. Audit table partitioning example</h2></div></div></div><p>
            In order to determine a suitable column for the 'increasing level of interestingness',
            consider a simplified example of a salary registration for an unnamed agency. 
        </p><p>
            Currently, the salary table contains the following rows for a certain person X:
                      
            </p><div class="table"><a id="d0e848"/><p class="title"><b>Table 8.1. Salaries table</b></p><div class="table-contents"><table summary="Salaries table" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Year</th><th>Salary (USD)</th></tr></thead><tbody><tr><td>2006</td><td>3300</td></tr><tr><td>2007</td><td>3500</td></tr><tr><td>2008</td><td>4000</td></tr><tr><td>2009</td><td>4500</td></tr></tbody></table></div></div><p><br class="table-break"/>
        </p><p>
            The salary for the current fiscal year (2010) is unknown. The agency requires that all changes in registered 
            salaries for a fiscal year are recorded (i.e. an audit trail). The rationale behind this is that decisions 
            made at a certain date are based on the registered salary at that time. And at any time it must be possible 
            reproduce the reason why a certain decision was made at a certain date.
        </p><p>
            The following audit information is available, sorted on in order of occurrence:

            </p><div class="table"><a id="d0e886"/><p class="title"><b>Table 8.2. Salaries - audit table</b></p><div class="table-contents"><table summary="Salaries - audit table" border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th>Year</th><th>Revision type</th><th>Revision timestamp</th><th>Salary (USD)</th><th>End revision timestamp</th></tr></thead><tbody><tr><td>2006</td><td>ADD</td><td>2007-04-01</td><td>3300</td><td>null</td></tr><tr><td>2007</td><td>ADD</td><td>2008-04-01</td><td>35</td><td>2008-04-02</td></tr><tr><td>2007</td><td>MOD</td><td>2008-04-02</td><td>3500</td><td>null</td></tr><tr><td>2008</td><td>ADD</td><td>2009-04-01</td><td>3700</td><td>2009-07-01</td></tr><tr><td>2008</td><td>MOD</td><td>2009-07-01</td><td>4100</td><td>2010-02-01</td></tr><tr><td>2008</td><td>MOD</td><td>2010-02-01</td><td>4000</td><td>null</td></tr><tr><td>2009</td><td>ADD</td><td>2010-04-01</td><td>4500</td><td>null</td></tr></tbody></table></div></div><p><br class="table-break"/>
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="partitioning-example-column"/>8.3.1. Determining a suitable partitioning column</h3></div></div></div><p>
                To partition this data, the 'level of interestingness' must be defined. 
                Consider the following:
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                            For fiscal year 2006 there is only one revision. It has the oldest <span class="emphasis"><em>revision timestamp</em></span>
                            of all audit rows, but should still be regarded as interesting because it is the latest modification 
                            for this fiscal year in the salary table; its <span class="emphasis"><em>end revision timestamp</em></span> is null.
                        </p><p>
                            Also note that it would be very unfortunate if in 2011 there would be an update of the salary for fiscal 
                            year 2006 (which is possible in until at least 10 years after the fiscal year) and the audit 
                            information would have been moved to a slow disk (based on the age of the 
                            <span class="emphasis"><em>revision timestamp</em></span>). Remember that in this case Envers will have to update 
                            the <span class="emphasis"><em>end revision timestamp</em></span> of the most recent audit row.
                        </p></li><li><p>
                             There are two revisions in the salary of fiscal year 2007 which both have nearly the same 
                             <span class="emphasis"><em>revision timestamp</em></span> and a different <span class="emphasis"><em>end revision timestamp</em></span>. 
                             On first sight it is evident that the first revision was a mistake and probably uninteresting. 
                             The only interesting revision for 2007 is the one with <span class="emphasis"><em>end revision timestamp</em></span> null.
                        </p></li></ol></div><p>
                        
                Based on the above, it is evident that only the <span class="emphasis"><em>end revision timestamp</em></span> is suitable for 
                audit table partitioning. The <span class="emphasis"><em>revision timestamp</em></span> is not suitable. 
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="partitioning-example-scheme"/>8.3.2. Determining a suitable partitioning scheme</h3></div></div></div><p>
                A possible partitioning scheme for the salary table would be as follows:
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                            <span class="emphasis"><em>end revision timestamp</em></span> year = 2008
                        </p><p>
                            This partition contains audit data that is not very (or no longer) interesting. 
                        </p></li><li><p>
                            <span class="emphasis"><em>end revision timestamp</em></span> year = 2009
                        </p><p>
                            This partition contains audit data that is potentially interesting.
                        </p></li><li><p>
                            <span class="emphasis"><em>end revision timestamp</em></span> year &gt;= 2010 or null  
                        </p><p>
                            This partition contains the most interesting audit data. 
                        </p></li></ol></div><p>
            </p><p>
                This partitioning scheme also covers the potential problem of the update of the 
                <span class="emphasis"><em>end revision timestamp</em></span>, which occurs if a row in the audited table is modified. 
                Even though Envers will update the <span class="emphasis"><em>end revision timestamp</em></span> of the audit row to 
                the system date at the instant of modification, the audit row will remain in the same partition
                (the 'extension bucket').
            </p><p>
                And sometime in 2011, the last partition (or 'extension bucket') is split into two new partitions:
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                            <span class="emphasis"><em>end revision timestamp</em></span> year = 2010
                        </p><p>
                            This partition contains audit data that is potentially interesting (in 2011).
                        </p></li><li><p>
                            <span class="emphasis"><em>end revision timestamp</em></span> year &gt;= 2011 or null  
                        </p><p>
                            This partition contains the most interesting audit data and is the new 'extension bucket'. 
                        </p></li></ol></div><p>
            </p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="source"/>Chapter 9. Building from source and testing</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#source-checkout">9.1. Building from source</a></span></dt><dt><span class="section"><a href="#source-contributing">9.2. Contributing</a></span></dt><dt><span class="section"><a href="#source-tests">9.3. Envers integration tests</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="source-checkout"/>9.1. Building from source</h2></div></div></div><p>
            Envers, as a module of Hibernate, uses the standard Hibernate build. So all the usual
            build targets (compile, test, install) will work.
        </p><p>
            The public Hibernate Git repository is hosted at GitHub and can be browsed using
            <a class="ulink" href="https://github.com/hibernate/hibernate-core">GitHub</a>.

            The source can be checked out using either  
            </p><pre class="programlisting">
            git clone https://github.com/hibernate/hibernate-core hibernate-core.git
            git clone git://github.com/hibernate/hibernate-core.git
            </pre><p>
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="source-contributing"/>9.2. Contributing</h2></div></div></div><p>
             If you want to contribute a fix or new feature, either:
             </p><div class="itemizedlist"><ul><li>
             	    use the GitHub fork capability: clone, work on a branch, fork the repo on GitHub (fork button), push the work there and trigger a pull request (pull request button).
             	</li><li>
             	    use the pure Git approach: clone, work on a branch, push to a public fork repo hosted somewhere, trigger a pull request 
             	    (<code class="literal">git pull-request</code>)
             	</li><li>
             	    provide a good old patch file: clone the repo, create a patch with git format-patch or diff and attach the patch file to JIRA
             	</li></ul></div><p>
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="source-tests"/>9.3. Envers integration tests</h2></div></div></div><p>
            The tests use, by default, use a H2 in-memory database. The configuration
            file can be found in <code class="literal">src/test/resources/hibernate.test.cfg.xml</code>.
        </p><p>
            The tests use TestNG, and can be found in the
            <code class="literal">org.hibernate.envers.test.integration</code> package
            (or rather, in subpackages of this package).
            The tests aren't unit tests, as they don't test individual classes, but the behaviour
            and interaction of many classes, hence the name of package.
        </p><p>
            A test normally consists of an entity (or two entities) that will be audited and extends the
            <code class="literal">AbstractEntityTest</code> class, which has one abstract method:
            <code class="literal">configure(Ejb3Configuration)</code>. The role of this method is to add the entities
            that will be used in the test to the configuration.
        </p><p>
            The test data is in most cases created in the "initData" method (which is called once before
            the tests from this class are executed), which normally creates a couple of revisions,
            by persisting and updating entities. The tests first check if the revisions, in which
            entities where modified are correct (the testRevisionCounts method), and if the historic
            data is correct (the testHistoryOfXxx methods).
        </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="exceptions"/>Chapter 10. Mapping exceptions</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#exceptions-wontbesupported">10.1. What isn't and will not be supported</a></span></dt><dt><span class="section"><a href="#exceptions-willbesupported">10.2. What isn't and will be supported</a></span></dt><dt><span class="section"><a href="#exceptions-onetomanyjoincolumn">10.3. @OneToMany+@JoinColumn</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="exceptions-wontbesupported"/>10.1. What isn't and will not be supported</h2></div></div></div><p>
            Bags (the corresponding Java type is List), as they can contain non-unique elements.
            The reason is that persisting, for example a bag of String-s, violates a principle
            of relational databases: that each table is a set of tuples. In case of bags,
            however (which require a join table), if there is a duplicate element, the two
            tuples corresponding to the elements will be the same. Hibernate allows this,
            however Envers (or more precisely: the database connector) will throw an exception
            when trying to persist two identical elements, because of a unique constraint violation.
        </p><p>
            There are at least two ways out if you need bag semantics:
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                    use an indexed collection, with the <code class="literal">@IndexColumn</code> annotation, or
                </p></li><li><p>
                    provide a unique id for your elements with the <code class="literal">@CollectionId</code> annotation.
                </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="exceptions-willbesupported"/>10.2. What isn't and <span class="emphasis"><em>will</em></span> be supported</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                    collections of components
                </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="exceptions-onetomanyjoincolumn"/>10.3. <code class="literal">@OneToMany</code>+<code class="literal">@JoinColumn</code></h2></div></div></div><p>
            When a collection is mapped using these two annotations, Hibernate doesn't
            generate a join table. Envers, however, has to do this, so that when you read the
            revisions in which the related entity has changed, you don't get false results.
        </p><p>
            To be able to name the additional join table, there is a special annotation:
            <code class="literal">@AuditJoinTable</code>, which has similar semantics to JPA's
            <code class="literal">@JoinTable</code>.
        </p><p>
            One special case are relations mapped with <code class="literal">@OneToMany</code>+<code class="literal">@JoinColumn</code> on
            the one side, and <code class="literal">@ManyToOne</code>+<code class="literal">@JoinColumn(insertable=false, updatable=false</code>)
            on the many side.
            Such relations are in fact bidirectional, but the owning side is the collection (see alse
            <a class="ulink" href="http://docs.jboss.org/hibernate/stable/annotations/reference/en/html_single/#entity-hibspec-collection-extratype">here</a>).
        </p><p>
            To properly audit such relations with Envers, you can use the <code class="literal">@AuditMappedBy</code> annotation.
            It enables you to specify the reverse property (using the <code class="literal">mappedBy</code> element). In case
            of indexed collections, the index column must also be mapped in the referenced entity (using
            <code class="literal">@Column(insertable=false, updatable=false)</code>, and specified using
            <code class="literal">positionMappedBy</code>. This annotation will affect only the way
            Envers works. Please note that the annotation is experimental and may change in the future.
        </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="migration"/>Chapter 11. Migration from Envers standalone</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#migrations-code">11.1. Changes to code</a></span></dt><dt><span class="section"><a href="#migrations-configuration">11.2. Changes to configuration</a></span></dt><dt><span class="section"><a href="#migrations-revisionlog">11.3. Changes to the revision entity</a></span></dt></dl></div><p>
        With the inclusion of Envers as a Hibernate module, some of the public API and configuration defaults
        changed. In general, "versioning" is renamed to "auditing" (to avoid confusion with the annotation used
        for indicating an optimistic locking field - <code class="literal">@Version</code>).
    </p><p>
        Because of changing some configuration defaults, there should be no more problems using Envers out-of-the-box
        with Oracle and other databases, which don't allow tables and field names to start with "_".
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="migrations-code"/>11.1. Changes to code</h2></div></div></div><p>
            Public API changes involve changing "versioning" to "auditing". So, <code class="literal">@Versioned</code>
            became <code class="literal">@Audited</code>; <code class="literal">@VersionsTable</code> became <code class="literal">@AuditTable</code>
            and so on.
        </p><p>
            Also, the query interface has changed slightly, mainly in the part for specifying restrictions,
            projections and order. Please refer to the Javadoc for further details.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="migrations-configuration"/>11.2. Changes to configuration</h2></div></div></div><p>
            First of all, the name of the event listener changed. It is now named
            <code class="literal">org.hibernate.envers.event.AuditEventListener</code>, instead of
            <code class="literal">org.jboss.envers.event.VersionsEventListener</code>. So to make Envers
            work, you will have to change these settings in your <code class="literal">persistence.xml</code>
            or Hibernate configuration.
        </p><p>
            Secondly, the names of the audit (versions) tables and additional auditing (versioning) fields
            changed. The default suffix added to the table name is now <code class="literal">_AUD</code>, instead of
            <code class="literal">_versions</code>. The name of the field that holds the revision number, and which
            is added to each audit (versions) table, is now <code class="literal">REV</code>, instead of
            <code class="literal">_revision</code>. Finally, the name of the field that holds the type of the revision,
            is now <code class="literal">REVTYPE</code>, instead of <code class="literal">_rev_type</code>.
        </p><p>
            If you have a schema generated with the old version of Envers, you will
            have to set those properties, to use the new version of Envers without problems:
        </p><pre class="programlisting">&lt;persistence-unit ...&gt;
&lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
&lt;class&gt;...&lt;/class&gt;
&lt;properties&gt;
   &lt;property name="hibernate.dialect" ... /&gt;
   &lt;!-- other hibernate properties --&gt;

   &lt;!-- Envers listeners --&gt;

   &lt;property name="org.hibernate.envers.auditTableSuffix" value="_versions" /&gt;
   &lt;property name="org.hibernate.envers.revisionFieldName" value="_revision" /&gt;
   &lt;property name="org.hibernate.envers.revisionTypeFieldName" value="_rev_type" /&gt;
   &lt;!-- other envers properties --&gt;
&lt;/properties&gt;
&lt;/persistence-unit&gt;</pre><p>
            The <code class="literal">org.hibernate.envers.doNotAuditOptimisticLockingField</code> property is
            now by default <code class="literal">true</code>, instead of <code class="literal">false</code>. You probably
            never would want to audit the optimistic locking field.
            Also, the <code class="literal">org.hibernate.envers.warnOnUnsupportedTypes</code> configuraiton
            option was removed. In case you are using some unsupported types, use the <code class="literal">@NotAudited</code>
            annotation.
        </p><p>
            See <a class="xref" href="#configuration" title="Chapter 3. Configuration">Chapter 3, <i>Configuration</i></a> for details on the configuration and a description of the
            configuration options.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="migrations-revisionlog"/>11.3. Changes to the revision entity</h2></div></div></div><p>
            This section applies only if you don't have a custom revision entity.
            The name of the revision entity generated by default changed, so if you used the default one, you'll
            have to add a custom revision entity, and map it to the old table. Here's the class
            that you have to create:
        </p><pre class="programlisting">package org.hibernate.envers.example;

import org.hibernate.envers.RevisionNumber;
import org.hibernate.envers.RevisionTimestamp;
import org.hibernate.envers.RevisionEntity;

import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Entity;
import javax.persistence.Column;
import javax.persistence.Table;

@Entity
@RevisionEntity
@Table(name="_revisions_info")
public class ExampleRevEntity {
    @Id
    @GeneratedValue
    @RevisionNumber
    @Column(name="revision_id")
    private int id;

    @RevisionTimestamp
    @Column(name="revision_timestamp")
    private long timestamp;

    // Getters, setters, equals, hashCode ...
}</pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="links"/>Chapter 12. Links</h2></div></div></div><p>
        Some useful links:
    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                <a class="ulink" href="http://hibernate.org">Hibernate</a>
            </p></li><li><p>
                <a class="ulink" href="http://community.jboss.org/en/envers?view=discussions">Forum</a>
            </p></li><li><p>
                <a class="ulink" href="http://anonsvn.jboss.org/repos/hibernate/core/trunk/envers/">Anonymous SVN</a>
            </p></li><li><p>
                <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/HHH">JIRA issue tracker</a>
                (when adding issues concerning Envers, be sure to select the "envers" component!)
            </p></li><li><p>
                <a class="ulink" href="irc://irc.freenode.net:6667/envers">IRC channel</a>
            </p></li><li><p>
                <a class="ulink" href="http://www.jboss.org/feeds/view/envers">Blog</a>
            </p></li><li><p>
                <a class="ulink" href="https://community.jboss.org/wiki/EnversFAQ">FAQ</a>
            </p></li></ol></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat Inc.</p></a></body></html>