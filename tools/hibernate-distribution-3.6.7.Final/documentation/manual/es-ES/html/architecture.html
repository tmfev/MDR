<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 2. Arquitectura</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="prev" href="tutorial.html" title="Capítulo 1. Tutorial"/><link rel="next" href="session-configuration.html" title="Capítulo 3. Configuración"/><link rel="copyright" href="Legal_Notice.html" title="Advertencia legal"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Siguiente</strong></a></li></ul><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Capítulo 2. Arquitectura</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="architecture.html#architecture-overview">2.1. Sinopsis</a></span></dt><dd><dl><dt><span class="section"><a href="architecture.html#architecture-overview-minimal">2.1.1. Minimal architecture</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-overview-comprehensive">2.1.2. Comprehensive architecture</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-overview-terms">2.1.3. Basic APIs</a></span></dt></dl></dd><dt><span class="section"><a href="architecture.html#architecture-jmx">2.2. Integración JMX</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-current-session">2.3. Sesiones contextuales</a></span></dt></dl></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. Sinopsis</h2></div></div></div><p>El diagrama a continuación brinda una perspectiva a alto nivel de la arquitectura de Hibernate: </p><div class="mediaobject" align="center"><img src="images/overview.png" align="middle"/></div><p>Unfortunately we cannot provide a detailed view of all possible runtime architectures. Hibernate is sufficiently flexible to be used in a number of ways in many, many architectures. We will, however, illustrate 2 specifically since they are extremes. </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-overview-minimal"/>2.1.1. Minimal architecture</h3></div></div></div><p>The "minimal" architecture has the application manage its own JDBC connections and provide those connections to Hibernate; additionally the application manages transactions for itself. This approach uses a minimal subset of Hibernate APIs. </p><div class="mediaobject" align="center"><img src="images/lite.png" align="middle"/></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-overview-comprehensive"/>2.1.2. Comprehensive architecture</h3></div></div></div><p>La arquitectura "completa" abstrae la aplicación de las APIs de JDBC/JTA y permite que Hibernate se encargue de los detalles. </p><div class="mediaobject" align="center"><img src="images/full_cream.png" align="middle"/></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-overview-terms"/>2.1.3. Basic APIs</h3></div></div></div><p>Here are quick discussions about some of the API objects depicted in the preceding diagrams (you will see them again in more detail in later chapters). </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="interfacename">org.hibernate.SessionFactory</code>)</span></dt><dd><p>A thread-safe, immutable cache of compiled mappings for a single database. A factory for <code class="interfacename">org.hibernate.Session</code> instances. A client of <code class="interfacename">org.hibernate.connection.ConnectionProvider</code>. Optionally maintains a <code class="literal">second level cache</code> of data that is reusable between transactions at a process or cluster level. </p></dd><dt><span class="term">Session (<code class="interfacename">org.hibernate.Session</code>)</span></dt><dd><p>A single-threaded, short-lived object representing a conversation between the application and the persistent store. Wraps a JDBC <code class="interfacename">java.sql.Connection</code>. Factory for <code class="interfacename">org.hibernate.Transaction</code>. Maintains a <code class="literal">first level cache</code> of persistent the application's persistent objects and collections; this cache is used when navigating the object graph or looking up objects by identifier. </p></dd><dt><span class="term">Objetos y colecciones persistentes</span></dt><dd><p>Short-lived, single threaded objects containing persistent state and business function. These can be ordinary JavaBeans/POJOs. They are associated with exactly one <code class="interfacename">org.hibernate.Session</code>. Once the <code class="interfacename">org.hibernate.Session</code> is closed, they will be detached and free to use in any application layer (for example, directly as data transfer objects to and from presentation). <a class="xref" href="objectstate.html" title="Capítulo 11. Trabajo con objetos">Capítulo 11, <i>Trabajo con objetos</i></a> discusses transient, persistent and detached object states. </p></dd><dt><span class="term">Objetos y colecciones transitorios y separados</span></dt><dd><p>Instances of persistent classes that are not currently associated with a <code class="interfacename">org.hibernate.Session</code>. They may have been instantiated by the application and not yet persisted, or they may have been instantiated by a closed <code class="interfacename">org.hibernate.Session</code>. <a class="xref" href="objectstate.html" title="Capítulo 11. Trabajo con objetos">Capítulo 11, <i>Trabajo con objetos</i></a> discusses transient, persistent and detached object states. </p></dd><dt><span class="term">Transaction (<code class="interfacename">org.hibernate.Transaction</code>)</span></dt><dd><p>(Optional) A single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC, JTA or CORBA transaction. A <code class="interfacename">org.hibernate.Session</code> might span several <code class="interfacename">org.hibernate.Transaction</code>s in some cases. However, transaction demarcation, either using the underlying API or <code class="interfacename">org.hibernate.Transaction</code>, is never optional. </p></dd><dt><span class="term">ConnectionProvider (<code class="interfacename">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Optional) A factory for, and pool of, JDBC connections. It abstracts the application from underlying <code class="interfacename">javax.sql.DataSource</code> or <code class="interfacename">java.sql.DriverManager</code>. It is not exposed to application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term">TransactionFactory (<code class="interfacename">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Optional) A factory for <code class="interfacename">org.hibernate.Transaction</code> instances. It is not exposed to the application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>Hibernate ofrece un rango de interfaces de extensión opcionales que puede implementar para personalizar el comportamiento de su capa de persistencia. Para obtener más detalles, vea la documentación de la API. </p></dd></dl></div><p>
            </p></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.2. Integración JMX</h2></div></div></div><p>JMX es el estándar J2EE para la gestión de componentes Java. Hibernate se puede administrar por medio de un servicio estándar JMX. Brindamos una implementación de MBean en la distribución: <code class="literal">org.hibernate.jmx.HibernateService</code>. </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a class="xref" href="session-configuration.html#configuration-optional-statistics" title="3.4.6. Estadísticas de Hibernate">Sección 3.4.6, “Estadísticas de Hibernate”</a> for more information. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.3. Sesiones contextuales</h2></div></div></div><p>La mayoría de las aplicaciones que utilizan Hibernate necesitan alguna forma de sesiones "contextuales", en donde una sesión dada se encuentra en efecto en todo el campo de acción de un contexto dado. Sin embargo, a través de las aplicaciones la definición de lo que constituye un contexto es usualmente diferente y diferentes contextos definen diferentes campos de acción para la noción de actual. Las aplicaciones que utiliza Hibernate antes de la version 3.0 tienden a utilizar ya sea sesiones contextuales con base <code class="literal">ThreadLocal</code> desarrollados en casa, las clases ayudantes tales como <code class="literal">HibernateUtil</code>, o enfoques de terceros utilizados, como Spring o Pico, los cuales brindaban sesiones contextuales con base proxy/intercepción. </p><p>Comenzando con la version 3.0.1, Hibernate agregó el método <code class="literal">SessionFactory.getCurrentSession()</code>. Inicialmente, este asumió la utilización de las transacciones <code class="literal">JTA</code>, en donde la transacción <code class="literal">JTA</code> definia tanto el contexto como el campo de acción de una sesión actual. Dada la madurez de númerosas implementaciones <code class="literal">JTA TransactionManager</code> autónomas existentes, la mayoría, si no es que todas, las aplicaciones deberían utilizar la administración de transacciones <code class="literal">JTA</code> en el caso de que se deplieguen o no en un contenedor <code class="literal">J2EE</code>. Con base en esto, las sesiones contextuales basadas en <code class="literal">JTA</code> es todo lo que usted necesita utilizar. </p><p>Sin embargo, desde la versión 3.1, el procesamiento detrás de <code class="literal">SessionFactory.getCurrentSession()</code> ahora es conectable. Para ese fin, se ha añadido una nueva interfaz de extensión, <code class="literal">org.hibernate.context.CurrentSessionContext</code>, y un nuevo parámetro de configuración, <code class="literal">hibernate.current_session_context_class</code> para permitir la conexión del campo de acción y el contexto de definición de las sesiones actuales. </p><p>Refiérase a los Javadocs para la interfaz <code class="literal">org.hibernate.context.CurrentSessionContext</code> para poder ver una discusión detallada de su contrato. Define un método único, <code class="literal">currentSession()</code>, por medio del cual la implementación es responsable de rastrear la sesión contextual actual. Tal como viene empacada, Hibernate incluye tres implementaciones de esta interfaz: </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code>: una transacción <code class="literal">JTA</code> rastrea y asume las sesiones actuales. Aquí el procesamiento es exactamente el mismo que en el enfoque más antiguo de JTA-sólamente. Refiérase a los Javadocs para obtener más información. </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code>: las sesiones actuales son rastreadas por un hilo de ejecución. Consulte los Javadocs para obtener más detalles. </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code>: las sesiones actuales son rastreadas por un hilo de ejecución. Sin embargo, usted es responsable de vincular y desvincular una instancia <code class="literal">Session</code> con métodos estáticos en esta clase: no abre, vacia o cierra una <code class="literal">Session</code>. </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a class="xref" href="transactions.html" title="Capítulo 13. Transacciones y concurrencia">Capítulo 13, <i>Transacciones y concurrencia</i></a> for more information and code examples. </p><p>El parámetro de configuración <code class="literal">hibernate.current_session_context_class</code> define cuales implementaciones <code class="literal">org.hibernate.context.CurrentSessionContext</code> deben utilizarse. Para compatibilidad con versiones anteriores, si este parámetro de configuración no está establecido pero si tiene configurado un <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code>, Hibernate utilizará el <code class="literal">org.hibernate.context.JTASessionContext</code>. Usualmente el valor de este parámetro sólamente nombraría la clase de implementación a utilizar. Sin embargo, para las tres implementaciones incluídas existen tress nombres cortos: "jta", "thread" y "managed". </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Anterior</strong>Capítulo 1. Tutorial</a></li><li class="up"><a accesskey="u" href="#"><strong>Subir</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Inicio</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Siguiente</strong>Capítulo 3. Configuración</a></li></ul></body></html>