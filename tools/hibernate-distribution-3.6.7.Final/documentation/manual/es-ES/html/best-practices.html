<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 27. Prácticas recomendadas</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="prev" href="example-mappings.html" title="Capítulo 26. Ejemplo: mapeos varios"/><link rel="next" href="portability.html" title="Capítulo 28. Consideraciones de la portabilidad de la base de datos"/><link rel="copyright" href="Legal_Notice.html" title="Advertencia legal"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="example-mappings.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="portability.html"><strong>Siguiente</strong></a></li></ul><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="best-practices"/>Capítulo 27. Prácticas recomendadas</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Escriba las clases detalladas y mapéelas utilizando <code class="literal">&lt;component&gt;</code>:</span></dt><dd><p>Utilice una clase <code class="literal">Dirección</code> para encapsular <code class="literal">calle</code>, <code class="literal">distrito</code>, <code class="literal">estado</code>, <code class="literal">código postal</code>. Esto promueve la reutilización de código y simplifica la refabricación. </p></dd><dt><span class="term">Declare las propiedades identificadoras en clases persistentes:</span></dt><dd><p>Las propiedades identificadoras son opcionales en Hibernate. Existe todo tipo de razones por las que debe usarlas. Recomendamos que los identificadores sean 'sintéticos', es decir, generados sin ningún significado empresarial. </p></dd><dt><span class="term">Identifique las llaves naturales:</span></dt><dd><p>Identifique las claves naturales de todas las entidades, y mapéelas usando <code class="literal">&lt;natural-id&gt;</code>. Implemente <code class="literal">equals()</code> y <code class="literal">hashCode()</code> para comparar las propiedades que componen la clave natural. </p></dd><dt><span class="term">Coloque cada mapeo de clase en su propio fichero:</span></dt><dd><p>No use un sólo documento monolítico de mapeo. Mapee <code class="literal">com.eg.Foo</code> en el archivo <code class="literal">com/eg/Foo.hbm.xml</code>. Esto tiene sentido particularmente en un entorno de equipo. </p></dd><dt><span class="term">Cargue los mapeos como recursos:</span></dt><dd><p>Despliegue los mapeos junto a las clases que mapean. </p></dd><dt><span class="term">Considere el externalizar las cadenas de petición:</span></dt><dd><p>Esta es una buena práctica si sus consultas llaman a funciones SQL que no son del estándar ANSI. Externalizar las cadenas de consulta a archivos de mapeo hará la aplicación más portátil.  </p></dd><dt><span class="term">Use variables de vinculación.</span></dt><dd><p>Al igual que en JDBC, siempre remplace los valores no constantes con "?". No use la manipulación de cadenas para enlazar un valor no constante en una consulta. También considere utilizar parámetros con nombre en las consultas. </p></dd><dt><span class="term">No administre sus propias conexiones JDBC:</span></dt><dd><p>Hibernate deja a la aplicación administrar las conexiones JDBC, pero este enfoque debe considerarse como el último recurso. Si no puede utilizar los provedores de conexión incorporados, considere proveer su propia implementación de <code class="literal">org.hibernate.connection.ConnectionProvider</code>. </p></dd><dt><span class="term">Considere utilizar un tipo personalizado:</span></dt><dd><p>Supónga que tiene un tipo Java de una biblioteca, que necesita hacerse persistente pero que no provee los métodos de acceso necesarios para mapearlo como un componente. Debe considerar el implementar <code class="literal">org.hibernate.UserType</code>. Este enfoque libera al código de aplicación de implementar transformaciones a/desde un tipo Hibernate. </p></dd><dt><span class="term">Utilice JDBC codificado a mano cuando se encuentre atascado:</span></dt><dd><p>En áreas de rendimiento crítico del sistema, algunos tipos de operaciones podrían beneficiarse del JDBC directo. Sin embargo, no asuma que JDBC es necesariamente más rápido. Por favor, espere hasta que <span class="emphasis"><em>sepa</em></span> que se encuentra realmente atascado. Si necesita utilizar JDBC directo, puede abrir una <code class="literal">Session</code> de Hibernate, envuelva su operación JDBC como un objeto <code class="literal">org.hibernate.jdbc.Work</code> usando esa conexión JDBC. De esta manera puede usar aún la misma estrategia de transacción y el mismo proveedor de conexiones subyacente. </p></dd><dt><span class="term">Comprenda el vaciado de <code class="literal">Session</code>:</span></dt><dd><p>A veces la sesión sincroniza su estado persistente con la base de datos. El rendimiento se verá afectado si este proceso ocurre con demasiada frecuencia. A veces puede minimizar el vaciado innecesario deshabilitando el vaciado automático o incluso cambiando el orden de las consultas u otras operaciones en una transacción en particular. </p></dd><dt><span class="term">En una arquitectura con tres niveles considere el utilizar objetos separados:</span></dt><dd><p>Al usar una arquitectura de servlet/sesión, puede pasar objetos persistentes en el bean de sesión hacia y desde la capa del servlet/JSP. Use una sesión nueva para atender el servicio de cada petición. Use <code class="literal">Session.merge()</code> o <code class="literal">Session.saveOrUpdate()</code> para sincronizar los objetos con la base de datos. </p></dd><dt><span class="term">En una arquitectura con dos niveles considere el utilizar contextos largos de persistencia:</span></dt><dd><p>Las transacciones de la base de datos tienen que ser tan cortas como sea posible para obtener una mejor escalabilidad. Sin embargo, con frecuencia es necesario implementar <span class="emphasis"><em>transacciones de aplicación</em></span> de larga ejecución, una sola unidad de trabajo desde el punto de vista de un usuario. Una transacción de aplicación puede abarcar muchos ciclos de petición/respuesta del cliente. Es común usar objetos separados para implementar transacciones de aplicación. Una alternativa apropiada en arquitecturas de dos niveles, es mantener una sesión de un sólo contacto de persistencia abierto para todo el ciclo de vida de la transacción de aplicación. Luego simplemente desconectar de la conexión JDBC al final de cada petición y reconectar al comienzo de la petición subsecuente. Nunca comparta una sesión única a través de más de una transacción de aplicación o estará trabajando con datos desactualizados. </p></dd><dt><span class="term">No trate las excepciones como recuperables:</span></dt><dd><p>Esto es más bien una práctica necesaria más que una práctica "recomendada". Cuando ocurra una excepción, deshaga la <code class="literal">Transaction</code> y cierre la <code class="literal">Session</code>. Si no lo hace, Hibernate no puede garantizar que el estado en memoria representa con exactitud el estado persistente. Por ejemplo, no utilice <code class="literal">Session.load()</code> para determinar si una instancia con el identificador dado existe en la base de datos; en cambio, use <code class="literal">Session.get()</code> o una consulta. </p></dd><dt><span class="term">Prefiera una recuperación perezosa para las asociaciones:</span></dt><dd><p>No utilice con frecuencia la recuperación temprana. Use proxies y colecciones perezosas para la mayoría de asociaciones a clases que probablemente no se encuentren en el caché de segundo nivel. Para las asociaciones a clases en caché, donde hay una probabilidad de acceso a caché extremadamente alta, deshabilite explícitamente la recuperación temprana usando <code class="literal">lazy="false"</code>. Cuando la recuperación por unión sea apropiada para un caso de uso en particular, utilice una consulta con un <code class="literal">left join fetch</code>. </p></dd><dt><span class="term">Use el patrón de <span class="emphasis"><em>sesión abierta en vista</em></span> o una <span class="emphasis"><em>fase de ensamblado</em></span> disciplinada para evitar problemas con datos no recuperados. </span></dt><dd><p>Hibernate libera al desarrollador de escribir tediosos <span class="emphasis"><em>objetos de transferencia de datos (DTO del inglés Data Transfer Objects)</em></span>. En una arquitectura tradicional de EJB, los DTOs tienen un propósito doble: primero, atacan el problema de que los beans de entidad no son serializables. Segundo, definen implícitamente una fase de ensamblado cuando se recuperan y se forman (marshalling) todos los datos a usar por la vista en los DTOs antes de devolver el control al nivel de presentación. Hibernate elimina el primer propósito. Sin embargo, aún necesita una fase de ensamblado a menos de que esté preparado para tener el contexto de persistencia (la sesión) abierto a través del proceso de entrega de la vista. Piense en sus métodos empresariales como si tuviesen un contrato estricto con el nivel de presentación sobre qué datos están disponibles en los objetos separados. Esta no es una limitación de Hibernate. Este es un requerimiento fundamental de acceso seguro a datos transaccionales. </p></dd><dt><span class="term">Considere abstraer su lógica empresarial de Hibernate:</span></dt><dd><p>Oculte el código de acceso a datos de Hibernate detrás de una interfaz. Combine los patrones <span class="emphasis"><em>DAO</em></span> y <span class="emphasis"><em>sesión local de hilo</em></span>. Incluso puede hacer algunas clases persistentes por medio de JDBC escrito a mano, asociadas a Hibernate por medio de un <code class="literal">UserType</code>. Sin embargo, este consejo va para las aplicaciones "suficientemente grandes". No es apropiado para una aplicación con cinco tablas. </p></dd><dt><span class="term">No utilice mapeos de asociación exóticos:</span></dt><dd><p>Son raros los casos de uso de asociaciones reales muchos-a-muchos. La mayor parte del tiempo necesita información adicional almacenada en una "tabla de enlace". En este caso, es mucho mejor usar dos asociaciones uno-a-muchos a una clase de enlace intermedio. De hecho, la mayoría de las asociaciones son uno-a-muchos y muchos-a-uno. Por esta razón, debe tener cuidado al utilizar cualquier otro estilo de asociación. </p></dd><dt><span class="term">Prefiera las asociaciones bidireccionales:</span></dt><dd><p>Las asociaciones unidireccionales son más difíciles de consultar. En una aplicación grande, casi todas las asociaciones deben ser navegables en ambas direcciones en consultas. </p></dd></dl></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="example-mappings.html"><strong>Anterior</strong>Capítulo 26. Ejemplo: mapeos varios</a></li><li class="up"><a accesskey="u" href="#"><strong>Subir</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Inicio</strong></a></li><li class="next"><a accesskey="n" href="portability.html"><strong>Siguiente</strong>Capítulo 28. Consideraciones de la portabilidad d...</a></li></ul></body></html>