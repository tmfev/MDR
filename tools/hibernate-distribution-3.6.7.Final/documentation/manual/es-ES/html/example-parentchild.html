<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 24. Ejemplo: Padre/Hijo</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="prev" href="additionalmodules.html" title="Capítulo 23. Additional modules"/><link rel="next" href="example-weblog.html" title="Capítulo 25. Ejemplo: Aplicación de Weblog"/><link rel="copyright" href="Legal_Notice.html" title="Advertencia legal"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="additionalmodules.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="example-weblog.html"><strong>Siguiente</strong></a></li></ul><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild"/>Capítulo 24. Ejemplo: Padre/Hijo</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="example-parentchild.html#example-parentchild-collections">24.1. Nota sobre las colecciones</a></span></dt><dt><span class="section"><a href="example-parentchild.html#example-parentchild-bidir">24.2. Uno-a-muchos bidireccional</a></span></dt><dt><span class="section"><a href="example-parentchild.html#example-parentchild-cascades">24.3. Ciclo de vida en cascada </a></span></dt><dt><span class="section"><a href="example-parentchild.html#example-parentchild-update">24.4. Cascadas y unsaved-value</a></span></dt><dt><span class="section"><a href="example-parentchild.html#example-parentchild-conclusion">24.5. Conclusión</a></span></dt></dl></div><p>Una de las primeras cosas que los usuarios nuevos intentan hacer con Hibernate es modelar una relación de tipo padre / hijo. Para esto existen dos enfoques diferentes. El enfoque más conveniente, especialmente para los usuarios nuevos, es modelar tanto <code class="literal">Parent</code> como <code class="literal">Child</code> como clases de entidad con una asociación <code class="literal">&lt;one-to-many&gt;</code> desde <code class="literal">Parent</code> a <code class="literal">Child</code>. El enfoque opcional es declarar el <code class="literal">Child</code> como un <code class="literal">&lt;composite-element&gt;</code>. La semántica prederterminada de una asociación uno-a-muchos en Hibernate es mucho menos cercana a la semántica usual de una relación padre / hijo que la de un mapeo de elementos compuestos. Explicaremos cómo utilizar una <span class="emphasis"><em>asociación uno-a-muchos bidireccional con tratamiento en cascada</em></span> para modelar una relación padre / hijo de manera eficiente y elegante. </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-collections"/>24.1. Nota sobre las colecciones</h2></div></div></div><p>Se considera que las colecciones de Hibernate son una parte lógica de la entidad que las posee y no de las entidades contenidas. Note que esta es una diferencia crucial y que esto tiene las siguientes consecuencias: </p><div class="itemizedlist"><ul><li><p>Cuando se elimina/agrega un objeto desde/a una colección, se incrementa el número de la versión del dueño de la colección. </p></li><li><p>Si un objeto que fue eliminado de una colección es una instancia de un tipo de valor (por ejemplo, un elemento compuesto), ese objeto cesará de ser persistente y su estado será completamente eliminado de la base de datos. Asimismo, añadir una instancia de tipo de valor a la colección causará que su estado sea persistente inmediatamente. </p></li><li><p>Por otro lado, si se elimina una entidad de una colección (una asociación uno-a-muchos o muchos-a-muchos), no se borrará por defecto. Este comportamiento es completamente consistente; un cambio en el estado interno de otra entidad no hace desaparecer la entidad asociada. Asimismo, el agregar una entidad a una colección no causa que la entidad se vuelva persistente por defecto. </p></li></ul></div><p>El comportamiento por defecto es que al agregar una entidad a una colección se crea un enlace entre las dos entidades. Al eliminar la entidad se eliminará el enlace. Esto es muy apropiado para todos los tipos de casos. Sin embargo, no apropiado en el caso de una relación padre / hijo. En este caso la vida del hijo se encuentra vinculada al ciclo de vida del padre. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-bidir"/>24.2. Uno-a-muchos bidireccional</h2></div></div></div><p>Supónga que empezamos con una asociación simple <code class="literal">&lt;one-to-many&gt;</code> desde <code class="literal">Parent</code> a <code class="literal">Child</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Si ejecutásemos el siguiente código: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">.....;</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">save</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>Hibernate publicaría dos declaraciones SQL: </p><div class="itemizedlist"><ul><li><p>un <code class="literal">INSERT</code> para crear el registro de <code class="literal">c</code></p></li><li><p>un <code class="literal">UPDATE</code> para crear el enlace desde <code class="literal">p</code> a <code class="literal">c</code> </p></li></ul></div><p>Esto no es sólo ineficiente, sino que además viola cualquier restricción <code class="literal">NOT NULL</code> en la columna <code class="literal">parent_id</code>. Puede arreglar la violación de restricción de nulabilidad especificando <code class="literal">not-null="true"</code> en el mapeo de la colección: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Sin embargo, esta no es la solución recomendada. </p><p>El caso subyacente de este comportamiento es que el enlace (la clave foránea <code class="literal">parent_id</code>) de <code class="literal">p</code> a <code class="literal">c</code> no se considera parte del estado del objeto <code class="literal">Child</code> y por lo tanto no se crea en el <code class="literal">INSERT</code>. De modo que la solución es hacer que el enlace sea parte del mapeo del <code class="literal">Child</code>.  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>También necesita agregar la propiedad <code class="literal">parent</code> a la clase <code class="literal">Child</code>. </p><p>Ahora que la entidad <code class="literal">Child</code> está administrando el estado del enlace, le decimos a la colección que no actualice el enlace. Usamos el atributo <code class="literal">inverse</code> para hacer esto: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>El siguiente código se podría utilizar para agregar un nuevo <code class="literal">Child</code>: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">save</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>Sólo se emitiría un <code class="literal">INSERT</code> de SQL. </p><p>También podría crear un método <code class="literal">addChild()</code> de <code class="literal">Parent</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">void</span><!-- <br/> --><span class="java_plain">&nbsp;addChild</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Child</span><!-- <br/> --><span class="java_plain">&nbsp;c</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_keyword">this</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;children</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>El código para agregar un <code class="literal">Child</code> se ve así: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">save</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-cascades"/>24.3. Ciclo de vida en cascada </h2></div></div></div><p>Puede abordar las frustraciones de la llamada explícita a <code class="literal">save()</code> utilizando cascadas. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">cascade</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;all&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Esto simplifica el código anterior a: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>De manera similar, no necesitamos iterar los hijos al guardar o borrar un <code class="literal">Parent</code>. Lo siguiente elimina <code class="literal">p</code> y todos sus hijos de la base de datos. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">delete</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>Sin embargo, el siguiente código: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Child</span><span class="java_separator">)</span><span class="java_plain">&nbsp;p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">iterator</span><span class="java_separator">().</span><span class="java_plain">next</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">remove</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_literal">null</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>no eliminará <code class="literal">c</code> de la base de datos. En este caso, sólo quitará el enlace a <code class="literal">p</code> y causará una violación a una restricción <code class="literal">NOT NULL</code>. Necesita borrar el hijo explícitamente llamando a <code class="literal">delete()</code> en <code class="literal">Child</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Child</span><span class="java_separator">)</span><span class="java_plain">&nbsp;p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">iterator</span><span class="java_separator">().</span><span class="java_plain">next</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">remove</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">delete</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>En nuestro caso, un <code class="literal">Child</code> no puede existir realmente sin su padre. De modo que si eliminamos un <code class="literal">Child</code> de la colección, realmente queremos que sea borrado. Para esto, tenemos que utilizar <code class="literal">cascade="all-delete-orphan"</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">cascade</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;all-delete-orphan&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Aunque el mapeo de la colección especifique <code class="literal">inverse="true"</code>, el tratamiento en cascada se procesa aún al iterar los elementos de la colección. De modo que si necesita que un objeto se guarde, borre o actualice en cascada, debe añadirlo a la colección. No es suficiente con simplemente llamar a <code class="literal">setParent()</code>. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-update"/>24.4. Cascadas y <code class="literal">unsaved-value</code></h2></div></div></div><p>Suppose we loaded up a <code class="literal">Parent</code> in one <code class="literal">Session</code>, made some changes in a UI action and wanted to persist these changes in a new session by calling <code class="literal">update()</code>. The <code class="literal">Parent</code> will contain a collection of children and, since the cascading update is enabled, Hibernate needs to know which children are newly instantiated and which represent existing rows in the database. We will also assume that both <code class="literal">Parent</code> and <code class="literal">Child</code> have generated identifier properties of type <code class="literal">Long</code>. Hibernate will use the identifier and version/timestamp property value to determine which of the children are new. (See <a class="xref" href="objectstate.html#objectstate-saveorupdate" title="11.7. Detección automática de estado">Sección 11.7, “Detección automática de estado”</a>.) <span class="emphasis"><em>In Hibernate3, it is no longer necessary to specify an <code class="literal">unsaved-value</code> explicitly.</em></span> </p><p>El siguiente código actualizará <code class="literal">parent</code> y <code class="literal">child</code> e insertará <code class="literal">newChild</code>: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">parent&nbsp;and&nbsp;child&nbsp;were&nbsp;both&nbsp;loaded&nbsp;in&nbsp;a&nbsp;previous&nbsp;session</span>
<!--  --><br/><span class="java_plain">parent</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">child</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;newChild&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">parent</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">newChild</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">update</span><span class="java_separator">(</span><span class="java_plain">parent</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>Todo eso es apropiado para el caso de un identificador generado, pero ¿qué de los identificadores asignados y de los identificadores compuestos? Esto es más difícil, ya que Hibernate no puede usar la propiedad identificadora para distinguir entre un objeto recién instanciado, con un identificador asignado por el usuario y un objeto cargado en una sesión previa. En este caso, Hibernate utilizará la propiedad de versión o sello de fecha, o bien consultará realmente el caché de segundo nivel, o bien, en el peor de los casos, consultará la base de datos, para ver si la fila existe. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-conclusion"/>24.5. Conclusión</h2></div></div></div><p>Las secciones que acabamos de cubrir pueden parecer un poco confusas. Sin embargo, en la práctica, todo funciona muy bien. La mayoría de las aplicaciones de Hibernate utilizan el patrón padre / hijo en muchos sitios. </p><p>Mencionamos una opción en el primer párrafo. Ninguno de los temas anteriores existe en el caso de los mapeos <code class="literal">&lt;composite-element&gt;</code>, los cuales tienen exactamente la semántica de una relación padre / hijo. Desafortunadamente, existen dos grandes limitaciones para las clases de elementos compuestos: los elementos compuestos no pueden poseer sus propias colecciones y no deben ser el hijo de cualquier otra entidad que no sea su padre único. </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="additionalmodules.html"><strong>Anterior</strong>Capítulo 23. Additional modules</a></li><li class="up"><a accesskey="u" href="#"><strong>Subir</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Inicio</strong></a></li><li class="next"><a accesskey="n" href="example-weblog.html"><strong>Siguiente</strong>Capítulo 25. Ejemplo: Aplicación de Weblog</a></li></ul></body></html>