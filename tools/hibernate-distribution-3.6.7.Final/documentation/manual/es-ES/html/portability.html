<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 28. Consideraciones de la portabilidad de la base de datos</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="prev" href="best-practices.html" title="Capítulo 27. Prácticas recomendadas"/><link rel="next" href="bi01.html" title="Referencias"/><link rel="copyright" href="Legal_Notice.html" title="Advertencia legal"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>Siguiente</strong></a></li></ul><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>Capítulo 28. Consideraciones de la portabilidad de la base de datos</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="portability.html#portability-basics">28.1. Aspectos básicos de la portabilidad</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialect">28.2. Dialecto</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialectresolver">28.3. Resolución del dialecto</a></span></dt><dt><span class="section"><a href="portability.html#portability-idgen">28.4. Generación del identificador</a></span></dt><dt><span class="section"><a href="portability.html#portability-functions">28.5. Funciones de la base de datos</a></span></dt><dt><span class="section"><a href="portability.html#portability-types">28.6. Mapeos de tipo</a></span></dt></dl></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>28.1. Aspectos básicos de la portabilidad</h2></div></div></div><p>Uno de los aspectos que más vende de Hibernate (y realmente del mapeo objeto/relacional en sí) es la noción de portabilidad de la base de datos. Podría ser el caso de un administrador de sistemas migrando de una base de datos de un vendedor a otro, o podría ser un marco de trabajo o una aplicación desplegable consumiendo Hibernate para que apunte simultáneamente a múltiples productos de bases de datos. Sin importar el escenario exacto, la idea básica es que quiere que Hibernate le ayude a ejecutar frente a cualquier número de bases de datos sin cambiar el código e idealmente sin cambiar los metadatos de mapeo.  </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>28.2. Dialecto</h2></div></div></div><p>La primera línea de portabilidad para Hibernate es el dialecto, el cual es una especialización del contrato <code class="classname">org.hibernate.dialect.Dialect</code>. Un dialecto encapsula todas las diferencias en la manera en que Hibernate debe comunicarse con una base de datos en particular para lograr alguna tarea como el obtener un valor de secuencia o el estructurar una petición SELECT. Hibernate reune un gran rango de dialectos para muchas de las bases de datos más populares. Si encuentra que su base de datos en particular no se encuentra entre estos, no es demasiado dificil es escribir el propio. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>28.3. Resolución del dialecto</h2></div></div></div><p>Originalmente, Hibernate siempre requería que los usuarios especificaran qué dialecto utilizar. En el caso de aquellos usuarios que buscaban apuntar a múltiples bases de datos de manera simultánea con su construcción eso representaba un problema. Generalmente esto requería que los usuarios configuraran el dialecto de Hibernate o que definieran su propio método para establecer ese valor.  </p><p>Empezando con la versión 3.2, Hibernate introdujo la noción de detectar automáticamente el dialecto a utilizar con base en los <code class="interfacename">java.sql.DatabaseMetaData</code> que se obtuvieron de una <code class="interfacename">java.sql.Connection</code> a esa base de datos. Esto era mucho mejor pero esta resolución estaba limitada a las bases de datos que Hibernate conoce por adelantado y de ninguna manera era configurable ni se podía sobreescribir. </p><p>Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Dialect</span><!-- <br/> --><span class="java_plain">&nbsp;resolveDialect</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">DatabaseMetaData</span><!-- <br/> --><span class="java_plain">&nbsp;metaData</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">throws</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">JDBCConnectionException</span></pre><p>The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver. </p><p>La parte divertida de estos resolvedores es que los usuarios también pueden registrar sus propios resolvedores personalizados, los cuales se procesarán antes de los incluídos en Hibernate. Esto puede llegar a ser útil en un número de situaciones diferentes: permite una fácil integración para la auto-detección de dialectos más allá de los que se envían junto con Hibernate; le permite especificar el uso de un dialecto personalizado cuando se reconoce una base de datos en particular; etc. Para registrar uno o más resolvedores, simplemente especifiquelos (separados por comas o espacios) usando la configuración 'hibernate.dialect_resolvers' (consulte la constante <code class="constant">DIALECT_RESOLVERS</code> en <code class="classname">org.hibernate.cfg.Environment</code>). </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>28.4. Generación del identificador</h2></div></div></div><p>When considering portability between databases, another important decision is selecting the identifier generation stratagy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy becauase the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entitiy be associated with the session (like via save() e.g.) regardless of current transactional semantics. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p> Hibernate was changed slightly once the implication of this was better understood so that the insert is delayed in cases where that is feasible. </p></div><p> The underlying issue is that the actual semanctics of the application itself changes in these cases. </p><p>Starting with version 3.2.3, Hibernate comes with a set of <a class="ulink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting portability in a much different way. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p> There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: </p><div class="itemizedlist"><ul><li><p> <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> </p></li><li><p> <code class="classname">org.hibernate.id.enhanced.TableGenerator</code> </p></li></ul></div><p> </p></div><p> The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>28.5. Funciones de la base de datos</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Aviso</h2><p>Esta es un área en la que Hibernate necesita mejorar. En términos de qué tan portatil puede ser, esta función que se maneja actualmente trabaja bastante bien desde HQL; sin embargo, en otros aspectos le falta mucho.  </p></div><p>Los usuarios pueden referenciar las funciones de SQL de muchas maneras. Sin embargo, no todas las bases de datos soportan el mismo grupo de funciones. Hibernate proporciona una manera de mapear un nombre de una función <span class="emphasis"><em>lógica</em></span> a un delegado, el cual sabe cómo entregar esa función en particular, tal vez incluso usando una llamada de función física totalmente diferente. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Técnicamente este registro de función se maneja por medio de la clase <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code>, la cual tiene el propósito de permitirle a los usuarios el proporcionar definiciones de funciones personalizadas sin tener que brindar un dialecto personalizado. Este comportamiento especifico todavía no está del todo completo. </p><p>De cierta manera está implementado para que los usuarios puedan registrar programáticamente las funciones con la <code class="classname">org.hibernate.cfg.Configuration</code> y aquellas funciones serán reconocidas por HQL. </p></div><p>
        </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>28.6. Mapeos de tipo</h2></div></div></div><p>Esta sección se completará en un futuro cercano... </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>Anterior</strong>Capítulo 27. Prácticas recomendadas</a></li><li class="up"><a accesskey="u" href="#"><strong>Subir</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Inicio</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>Siguiente</strong>Referencias</a></li></ul></body></html>