<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 16. HQL: El lenguaje de consulta de Hibernate</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="prev" href="batch.html" title="Capítulo 15. Procesamiento por lotes"/><link rel="next" href="querycriteria.html" title="Capítulo 17. Consultas por criterios"/><link rel="copyright" href="Legal_Notice.html" title="Advertencia legal"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>Siguiente</strong></a></li></ul><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>Capítulo 16. HQL: El lenguaje de consulta de Hibernate</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="queryhql.html#queryhql-casesensitivity">16.1. Sensibilidad a mayúsculas</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-from">16.2. La cláusula from</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins">16.3. Asociaciones y uniones (joins)</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins-forms">16.4. Formas de sintaxis unida</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-identifier-property">16.5. Referencia a la propiedad identificadora </a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-select">16.6. La cláusula select</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-aggregation">16.7. Funciones de agregación</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-polymorphism">16.8. Consultas polimórficas</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-where">16.9. La cláusula where</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-expressions">16.10. Expresiones</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-ordering">16.11. La cláusula order by</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-grouping">16.12. La cláusula group by</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-subqueries">16.13. Subconsultas</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-examples">16.14. Ejemplos de HQL</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-bulk">16.15. Declaraciones UPDATE y DELETE masivas</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tipstricks">16.16. Consejos y Trucos</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-components">16.17. Componentes</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tuple">16.18. Sintaxis del constructor de valores por fila</a></span></dt></dl></div><p>Hibernate utiliza un lenguaje de consulta potente (HQL) que se parece a SQL. Sin embargo, comparado con SQL, HQL es completamente orientado a objetos y comprende nociones como herencia, polimorfismo y asociación. </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>16.1. Sensibilidad a mayúsculas</h2></div></div></div><p>Las consultas no son sensibles a mayúsculas, a excepción de los nombres de las clases y propiedades Java. De modo que <code class="literal">SeLeCT</code> es lo mismo que <code class="literal">sELEct</code> e igual a <code class="literal">SELECT</code>, pero <code class="literal">org.hibernate.eg.FOO</code> no es lo mismo que <code class="literal">org.hibernate.eg.Foo</code> y <code class="literal">foo.barSet</code> no es igual a <code class="literal">foo.BARSET</code>. </p><p>Este manual utiliza palabras clave HQL en minúsculas. Algunos usuarios encuentran que las consultas con palabras clave en mayúsculas son más fáciles de leer, pero esta convención no es apropiada para las peticiones incluidas en código Java. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>16.2. La cláusula from</h2></div></div></div><p>La consulta posible más simple de Hibernate es de esta manera: </p><pre class="programlisting">from eg.Cat</pre><p>Esto retorna todas las instancias de la clase <code class="literal">eg.Cat</code>. Usualmente no es necesario calificar el nombre de la clase ya que <code class="literal">auto-import</code> es el valor predeterminado. Por ejemplo: </p><pre class="programlisting">from Cat</pre><p>Con el fin de referirse al <code class="literal">Cat</code> en otras partes de la petición, necesitará asignar un <span class="emphasis"><em>alias</em></span>. Por ejemplo: </p><pre class="programlisting">from Cat as cat</pre><p>Esta consulta asigna el alias <code class="literal">cat</code> a las instancias <code class="literal">Cat</code>, de modo que puede utilizar ese alias luego en la consulta. La palabra clave <code class="literal">as</code> es opcional. También podría escribir: </p><pre class="programlisting">from Cat cat</pre><p>Pueden aparecer múltiples clases, lo que causa un producto cartesiano o una unión "cruzada" (cross join). </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>Se considera como una buena práctica el nombrar los alias de consulta utilizando una inicial en minúsculas, consistente con los estándares de nombrado de Java para las variables locales (por ejemplo, <code class="literal">domesticCat</code>).  </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>16.3. Asociaciones y uniones (joins)</h2></div></div></div><p>También puede asignar alias a entidades asociadas o a elementos de una colección de valores utilizando una <code class="literal">join</code>. Por ejemplo: </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>Los tipos de uniones soportadas se tomaron prestados de ANSI SQL </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">inner join</code>
                </p></li><li><p>
                    <code class="literal">left outer join</code>
                </p></li><li><p>
                    <code class="literal">right outer join</code>
                </p></li><li><p><code class="literal">full join</code> (no es útil usualmente) </p></li></ul></div><p>Las construcciones <code class="literal">inner join</code>, <code class="literal">left outer join</code> y <code class="literal">right outer join</code> se pueden abreviar. </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>Puede proveer condiciones extras de unión utilizando la palabra clave <code class="literal">with</code> de HQL. </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight 
&gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a class="xref" href="performance.html#performance-fetching" title="21.1. Estrategias de recuperación">Sección 21.1, “Estrategias de recuperación”</a> for more information. </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>Usualmente no se necesita asignársele un alias a una unión de recuperación ya que los objetos asociados no se deben utilizar en la cláusula <code class="literal">where</code> (ni en cualquier otra cláusula). Los objetos asociados no se retornan directamente en los resultados de la consulta. En cambio, se pueden acceder por medio del objeto padre. La única razón por la que necesitaríamos un alias es si estamos uniendo recursivamente otra colección: </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>La construcción <code class="literal">fetch</code> no puede utilizarse en consultas llamadas que usen <code class="literal">iterate()</code> (aunque se puede utilizar <code class="literal">scroll()</code>). <code class="literal">Fetch</code> se debe usar junto con <code class="literal">setMaxResults()</code> o <code class="literal">setFirstResult()</code> ya que estas operaciones se basan en las filas de resultados, las cuales usualmente contienen duplicados para la recuperación de colección temprana, por lo tanto, el número de filas no es lo que se esperaría. <code class="literal">Fetch</code> no se debe usar junto con una condición <code class="literal">with</code> improvisadas. Es posible crear un producto cartesiano por medio de una recuperación por union más de una colección en una consulta, así que tenga cuidado en este caso. La recuperación por unión de múltiples roles de colección también da resultados a veces inesperados para mapeos de bag, así que tenga cuidado de cómo formular sus consultas en este caso. Finalmente, observe que <code class="literal">full join fetch</code> y <code class="literal">right join fetch</code> no son significativos. </p><p>Si está utilizando una recuperación perezosa a nivel de propiedad (con instrumentación de código byte), es posible forzar a Hibernate a traer las propiedades perezosas inmediatamente utilizando <code class="literal">fetch all properties</code>. </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>16.4. Formas de sintaxis unida</h2></div></div></div><p>HQL soporta dos formas de unión de asociación: <code class="literal">implicit</code> y <code class="literal">explicit</code>. </p><p>Las consultas que se mostraron en la sección anterior todas utilizan la forma <code class="literal">explicit</code>, en donde la palabra clave join se utiliza explícitamente en la claúsula from. Esta es la forma recomendada. </p><p>La forma <code class="literal">implicit</code> no utiliza la palabra clave join. Las asociaciones se "desreferencian" utilizando la notación punto. Uniones <code class="literal">implicit</code> pueden aparecer en cualquiera de las cláusulas HQL. La unión <code class="literal">implicit</code> causa uniones internas (inner joins) en la declaración SQL que resulta. </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>16.5. Referencia a la propiedad identificadora </h2></div></div></div><p>Hay dos maneras de referirse a la propiedad identificadora de una entidad: </p><div class="itemizedlist"><ul compact="compact"><li><p>La propiedad especial (en minúsculas) <code class="literal">id</code> se puede utilizar para referenciar la propiedad identificadora de una entidad <span class="emphasis"><em> dado que la entidad no defina un id del nombre de la propiedad no-identificadora</em></span>. </p></li><li><p>Si la entidad define una propiedad identificadora nombrada, puede utilizar ese nombre de propiedad. </p></li></ul></div><p>Las referencias a propiedades identificadoras compuestas siguen las mismas reglas de nombramiento. Si la entidad no tiene un id del nombre de la propiedad no-identificadora, la propiedad identificadora compuesta sólamente puede ser referenciada por su nombre definido. De otra manera se puede utilizar la propiedad <code class="literal">id</code> especial para referenciar la propiedad identificadora. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Observe que esto ha cambiado bastante desde la version 3.2.2. En versiones previas, <code class="literal">id</code><span class="emphasis"><em>siempre</em></span> se refería a la propiedad identificadora sin importar su nombre real. Una ramificación de esa decisión fue que las propiedades no-identificadoras nombradas <code class="literal">id</code> nunca podrían ser referenciadas en consultas de Hibernate.  </p></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>16.6. La cláusula select</h2></div></div></div><p>La cláusula <code class="literal">select</code> escoge qué objetos y propiedades devolver en el conjunto de resultados de la consulta. Considere lo siguiente: </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>La consulta seleccionará <code class="literal">mate</code>s de otros <code class="literal">Cat</code>s. Puede expresar esta consulta de una manera más compacta así: </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>Las consultas pueden retornar propiedades de cualquier tipo de valor incluyendo propiedades del tipo componente: </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>Las consultas pueden retornar múltiples objetos y/o propiedades como un array de tipo <code class="literal">Object[]</code>, </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>O como una <code class="literal">List</code>: </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>O asumiendo que la clase <code class="literal">Family</code> tiene un constructor apropiado - como un objeto Java de tipo seguro: </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>Puede asignar alias para expresiones seleccionadas utilizando <code class="literal">as</code>: </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>Esto es lo más útil cuando se usa junto con <code class="literal">select new map</code>: </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>Esta consulta devuelve un <code class="literal">Map</code> de alias a valores seleccionados. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>16.7. Funciones de agregación</h2></div></div></div><p>Las consultas HQL pueden incluso retornar resultados de funciones de agregación sobre propiedades: </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>Las funciones de agregación soportadas son: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>Puede utilizar operadores aritméticos, concatenación y funciones SQL reconocidas en la cláusula select: </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>Las palabras clave <code class="literal">distinct</code> y <code class="literal">all</code> se pueden utilizar y tienen las misma semántica que en SQL. </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>16.8. Consultas polimórficas</h2></div></div></div><p>Una consulta como: </p><pre class="programlisting">from Cat as cat</pre><p>devuelve instancias no sólamente de <code class="literal">Cat</code>, sino también de subclases como <code class="literal">DomesticCat</code>. Las consultas de Hibernate pueden nombrar <span class="emphasis"><em>cualquier</em></span> clase o interfaz Java en la cláusula <code class="literal">from</code>. La consulta retornará instancias de todas las clases persistentes que extiendan esa clase o implementen la interfaz. La siguiente consulta retornaría todos los objetos persistentes. </p><pre class="programlisting">from java.lang.Object o</pre><p>La interfaz <code class="literal">Named</code> se podría implementar por varias clases persistentes: </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>Las dos últimas consultas requerirán más de un <code class="literal">SELECT</code> SQL. Esto significa que la cláusula <code class="literal">order by</code> no ordenará correctamente todo el conjunto que resulte. También significa que no puede llamar estas consulta usando <code class="literal">Query.scroll()</code>. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>16.9. La cláusula where</h2></div></div></div><p>La cláusula <code class="literal">where</code> le permite refinar la lista de instancias retornadas. Si no existe ningún alias, puede referirse a las propiedades por nombre: </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>Si existe un alias, use un nombre de propiedad calificado: </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>Esto retorna instancias de <code class="literal">Cat</code> llamadas 'Fritz'. </p><p>La siguiente petición: </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p>retornará todas las instancias de <code class="literal">Foo</code> con una instancia de <code class="literal">bar</code> con una propiedad <code class="literal">date</code> igual a la propiedad <code class="literal">startDate</code> del <code class="literal">Foo</code>. Las expresiones de ruta compuestas hacen la cláusula <code class="literal">where</code> extremadamente potente. Tome en consideración lo siguiente: </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>Esta consulta se traduce a una consulta SQL con una unión de tabla (interna). Por ejemplo: </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>terminaría con una consulta que requeriría cuatro uniones de tablas en SQL.  </p><p>El operador <code class="literal">=</code> se puede utilizar para comparar no sólamente propiedades sino también instancias: </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. Referencia a la propiedad identificadora">Sección 16.5, “Referencia a la propiedad identificadora ”</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>La segunda consulta es eficiente y no se necesita una unión de tablas. </p><p>También se pueden utilizar las propiedades de identificadores compuestos. Considere el siguiente ejemplo en donde <code class="literal">Person</code> tiene identificadores compuestos que consisten de <code class="literal">country</code> y <code class="literal">medicareNumber</code>: </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>Una vez más, la segunda consulta no requiere una unión de tablas. </p><p>See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. Referencia a la propiedad identificadora">Sección 16.5, “Referencia a la propiedad identificadora ”</a> for more information regarding referencing identifier properties) </p><p>La propiedad especial <code class="literal">class</code> acccede al valor discriminador de una instancia en el caso de persistencia polimórfica. Un nombre de clase Java incluído en la cláusula where será traducido a su valor discriminador. </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a class="xref" href="queryhql.html#queryhql-components" title="16.17. Componentes">Sección 16.17, “Componentes”</a> for more information. </p><p>Un tipo "any" tiene las propiedades especiales <code class="literal">id</code> y <code class="literal">class</code>, permiténdole expresar una unión de la siguiente forma (en donde <code class="literal">AuditLog.item</code> es una propiedad mapeada con <code class="literal">&lt;any&gt;</code>). </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>La <code class="literal">log.item.class</code> y <code class="literal">payment.class</code> harían referencia a los valores de columnas de la base de datos completamente diferentes en la consulta anterior. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>16.10. Expresiones</h2></div></div></div><p>Las expresiones utilizadas en la cláusula <code class="literal">where</code> incluyen lo siguiente: </p><div class="itemizedlist"><ul compact="compact"><li><p>operadores matemáticos: <code class="literal">+, -, *, /</code> </p></li><li><p>operadores de comparación binarios: <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code> </p></li><li><p>operadores lógicos <code class="literal">and, or, not</code> </p></li><li><p>Paréntesis <code class="literal">( )</code> que indican agrupación </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> y <code class="literal">not member of</code> </p></li><li><p>Caso "simple", <code class="literal">case ... when ... then ... else ... end</code>, y caso "buscado", <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>concatenación de cadenas <code class="literal">...||...</code> o <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code> y <code class="literal">current_timestamp()</code> </p></li><li><p><code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code>, and <code class="literal">year(...)</code> </p></li><li><p>Cualquier función u operador definido por EJB-QL 3.0: <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</code> </p></li><li><p><code class="literal">coalesce()</code> y <code class="literal">nullif()</code> </p></li><li><p><code class="literal">str()</code> para convertir valores numéricos o temporales a una cadena legible. </p></li><li><p><code class="literal">cast(... as ...)</code>, donde el segundo argumento es el nombre de un tipo de Hibernate , y <code class="literal">extract(... from ...)</code> si <code class="literal">cast()</code> y <code class="literal">extract()</code> es soportado por la base de datos subyacente. </p></li><li><p>la función <code class="literal">index()</code> de HQL, que se aplica a alias de una colección indexada unida. </p></li><li><p>Las funciones de HQL que tomen expresiones de ruta valuadas en colecciones: <code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>, junto con las funciones especiales <code class="literal">elements()</code> e <code class="literal">indices</code>, las cuales se pueden cuantificar utilizando <code class="literal">some, all, exists, any, in</code>. </p></li><li><p>Cualquier función escalar SQL soportada por la base de datos como <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code> y <code class="literal">sin()</code> </p></li><li><p>parámetros posicionales JDBC <code class="literal">?</code> </p></li><li><p>parámetros con nombre <code class="literal">:name</code>, <code class="literal">:start_date</code> y <code class="literal">:x1</code> </p></li><li><p>literales SQL <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">6.66E+2</code>, <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>constantes Java <code class="literal">public static final</code><code class="literal">eg.Color.TABBY</code> </p></li></ul></div><p><code class="literal">in</code> y <code class="literal">between</code> pueden utilizarse así: </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>Las formas negadas se pueden escribir así: </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>De manera similar, <code class="literal">is null</code> y <code class="literal">is not null</code> se pueden utilizar para probar valores nulos. </p><p>Los valores booleanos se pueden utilizar fácilmente en expresiones declarando substituciones de consulta HQL en la configuración de Hibernate: </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"
&gt;true 1, false 0&lt;/property
&gt;</pre><p>Esto remplazará las palabras clave <code class="literal">true</code> y <code class="literal">false</code> con los literales <code class="literal">1</code> y <code class="literal">0</code> en el SQL traducido de este HQL: </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>Puede comprobar el tamaño de una colección con la propiedad especial <code class="literal">size</code> o la función especial <code class="literal">size()</code>. </p><pre class="programlisting">from Cat cat where cat.kittens.size 
&gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) 
&gt; 0</pre><p>Para las colecciones indexadas, puede referirse a los índices máximo y mínimo utilizando las funciones <code class="literal">minindex</code> y <code class="literal">maxindex</code>. De manera similar, se puede referir a los elementos máximo y mínimo de una colección de tipo básico utilizando las funciones <code class="literal">minelement</code> y <code class="literal">maxelement</code>. Por ejemplo:  </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) 
&gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) 
&gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) 
&gt; 10000</pre><p>Las funciones SQL <code class="literal">any, some, all, exists, in</code> están soportadas cuando se les pasa el conjunto de elementos o índices de una colección (las funciones <code class="literal">elements</code> e <code class="literal">indices</code>) o el resultado de una subconsulta (vea a continuación): </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 
&gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>Note que estas construcciones - <code class="literal">size</code>, <code class="literal">elements</code>, <code class="literal">indices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>, <code class="literal">minelement</code>, <code class="literal">maxelement</code> - solo se pueden utilizar en la cláusula where en Hibernate3. </p><p>Los elementos de colecciones indexadas (arrays, listas, mapas) se pueden referir por índice sólamente en una cláusula where: </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>La expresión dentro de <code class="literal">[]</code> puede incluso ser una expresión aritmética: </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>HQL también proporciona la función incorporada <code class="literal">index()</code>, para los elementos de una asociación uno-a-muchos o una colección de valores. </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>Se pueden utilizar las funciones SQL escalares soportadas por la base de datos subyacente: </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>Considere qué tan larga y menos leíble sería la siguiente consulta en SQL: </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>Ayuda:</em></span> algo como </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>16.11. La cláusula order by</h2></div></div></div><p>La lista retornada por una consulta se puede ordenar por cualquier propiedad de una clase retornada o componentes: </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>Los <code class="literal">asc</code> o <code class="literal">desc</code> opcionales indican ordenamiento ascendente o descendente respectivamente. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>16.12. La cláusula group by</h2></div></div></div><p>Una consulta que retorna valores agregados  se puede agrupar por cualquier propiedad de una clase retornada o componentes: </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p>Se permite también una cláusula <code class="literal">having</code>. </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>Las funciones SQL y las funciones de agregación SQL están permitidas en las cláusulas <code class="literal">having</code> y <code class="literal">order by</code>, si están soportadas por la base de datos subyacente (por ejemplo, no lo están en MySQL).  </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.name, cat.other, cat.properties
having avg(kitten.weight) 
&gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>La cláusula <code class="literal">group by</code> ni la cláusula <code class="literal">order by</code> pueden contener expresiones aritméticas. Hibernate tampocoo expande una entidad agrupada así que no puede escribir <code class="literal">group by cat</code> si todas las propiedades de <code class="literal">cat</code> son no-agregadas. Tiene que enumerar todas la propiedades no-agregadas explícitamente. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>16.13. Subconsultas</h2></div></div></div><p>Para bases de datos que soportan subconsultas, Hibernate soporta subconsultas dentro de consultas. Una subconsulta se debe encerrar entre paréntesis (frecuentemente por una llamada a una función de agregación SQL). Incluso se permiten subconsultas correlacionadas (subconsultas que se refieren a un alias en la consulta exterior). </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight 
&gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>Note que las subconsultas HQL pueden ocurrir sólamente en las cláusulas select o where. </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a class="xref" href="queryhql.html#queryhql-tuple" title="16.18. Sintaxis del constructor de valores por fila">Sección 16.18, “Sintaxis del constructor de valores por fila”</a> for more information. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>16.14. Ejemplos de HQL</h2></div></div></div><p>Las consultas de Hibernate pueden ser bastante potentes y complejas. De hecho, el poder del lenguaje de consulta es uno de las fortalezas principales de Hibernate. He aquí algunos ejemplos de consultas muy similares a las consultas de proyectos recientes. Note que la mayoría de las consultas que escribirá son mucho más simples que los siguientes ejemplos. </p><p>La siguiente consulta retorna el order id, número de items y valor total mínimo dado y el valor de la orden para todas las órdenes no pagadas de un cliente en particular. Los resultados se ordenan de acuerdo al valor total. Al determinar los precios, usa el catálogo actual. La consulta SQL resultante, contra las tablas <code class="literal">ORDER</code>, <code class="literal">ORDER_LINE</code>, <code class="literal">PRODUCT</code>, <code class="literal">CATALOG</code> y <code class="literal">PRICE</code> tiene cuatro uniones interiores y una subselección (no correlacionada). </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate 
&gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>¡Qué monstruo! Realmente, en la vida real, no me gustan mucho las subconsultas, de modo que mi consulta fue realmente algo como esto: </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>La próxima consulta cuenta el número de pagos en cada estado, excluyendo todos los pagos en el estado <code class="literal">AWAITING_APPROVAL</code> donde el cambio más reciente al estado lo hizo el usuario actual. Se traduce en una consulta SQL con dos uniones interiores y una subselección correlacionada contra las tablas <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code> y <code class="literal">PAYMENT_STATUS_CHANGE</code>. </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;
&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>Si la colección <code class="literal">statusChanges</code> se mapeara como una lista, en vez de un conjunto, la consulta habría sido mucho más simple de escribir. </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;
&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>La próxima consulta utiliza la función <code class="literal">isNull()</code> de MS SQL Server para devolver todas las cuentas y pagos aún no cancelados de la organización a la que pertenece el usuario actual. Se traduce como una consulta SQL con tres uniones interiores, una unión exterior y una subselección contra las tablas <code class="literal">ACCOUNT</code>, <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">ACCOUNT_TYPE</code>, <code class="literal">ORGANIZATION</code> y <code class="literal">ORG_USER</code>. </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>Para algunas bases de datos, necesitaríamos eliminar la subselección (correlacionada). </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>16.15. Declaraciones UPDATE y DELETE masivas</h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a class="xref" href="batch.html#batch-direct" title="15.4. Operaciones de estilo DML">Sección 15.4, “Operaciones de estilo DML”</a> for more information. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>16.16. Consejos y Trucos</h2></div></div></div><p>Puede contar el número de resultados de una consulta sin retornarlos: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p>Para ordenar un resultado por el tamaño de una colección, utilice la siguiente consulta: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>Si su base de datos soporta subselecciones, puede colocar una condición sobre el tamaño de selección en la cláusula where de su consulta: </p><pre class="programlisting">from User usr where size(usr.messages) 
&gt;= 1</pre><p>Si su base de datos no soporta subselecciones, utilice la siguiente consulta:  </p><pre class="programlisting">select usr.id, usr.name
from User usr
    join usr.messages msg
group by usr.id, usr.name
having count(msg) 
&gt;= 1</pre><p>Como esta solución no puede retornar un <code class="literal">User</code> con cero mensajes debido a la unión interior, la siguiente forma también es útil: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>Las propiedades de un JavaBean pueden ser ligadas a los parámetros de consulta con nombre: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;foo&nbsp;Foo&nbsp;as&nbsp;foo&nbsp;where&nbsp;foo.name=:name&nbsp;and&nbsp;foo.size=:size&quot;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setProperties</span><span class="java_separator">(</span><span class="java_plain">fooBean</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;fooBean&nbsp;has&nbsp;getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;and&nbsp;getSize</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;foos&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>Las colecciones son paginables usando la interfaz <code class="literal">Query</code> con un filtro: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;the&nbsp;trivial&nbsp;filter</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setFirstResult</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE&nbsp;</span><span class="java_operator">*</span><span class="java_plain">&nbsp;pageNumber</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;page&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>Los elementos de colección se pueden ordenar o agrupar usando un filtro de consulta: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Collection</span><!-- <br/> --><span class="java_plain">&nbsp;orderedCollection&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">filter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;order&nbsp;by&nbsp;this.amount&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Collection</span><span class="java_plain">&nbsp;counts&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">filter</span><span class="java_separator">(</span><span class="java_plain">&nbsp;collection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;select&nbsp;this.type,&nbsp;count(this)&nbsp;group&nbsp;by&nbsp;this.type&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span></pre><p>Puede hallar el tamaño de una colección sin inicializarla: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>16.17. Componentes</h2></div></div></div><p>Los componentes se pueden utilizar de la misma manera en que se pueden utilizar los tipos de valores simples en consultas HQL. Pueden aparecer en la cláusula <code class="literal">select</code> así: </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>en donde el nombre de la Persona es un componente. Los componentes también se pueden utilizar en la cláusula <code class="literal">where</code>: </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>Los componentes también se pueden utilizar en la cláusula <code class="literal">where</code>: </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>Otro uso común de los componentes se encuentra en <a class="link" href="queryhql.html#queryhql-tuple" title="16.18. Sintaxis del constructor de valores por fila">row value constructors</a>. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>16.18. Sintaxis del constructor de valores por fila</h2></div></div></div><p>HQL soporta la utilización de la sintaxis <code class="literal">row value constructor</code> de SQL ANSI que a veces se denomina sintaxis <code class="literal">tuple</code>, aunque puede que la base de datos subyacentes no soporte esa noción. Aquí estamos refiriéndonos generalmente a las comparaciones multivaluadas que se asocian típicamente con los componentes. Considere una entidad Persona, la cual define un componente de nombre: </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>Esa es una sintaxis válida aunque un poco verbosa. Puede hacerlo un poco más conciso utilizando la sintaxis <code class="literal">row value constructor</code>: </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p>También puede ser útil especificar esto en la cláusula <code class="literal">select</code>: </p><pre class="programlisting">select p.name from Person p</pre><p>También puede ser beneficioso el utilizar la sintaxis <code class="literal">row value constructor</code> cuando se utilizan subconsultas que necesitan compararse con valores múltiples: </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>Algo que se debe tomar en consideración al decidir si quiere usar esta sintaxis es que la consulta dependerá del orden de las sub-propiedades componentes en los metadatos. </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>Anterior</strong>Capítulo 15. Procesamiento por lotes</a></li><li class="up"><a accesskey="u" href="#"><strong>Subir</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Inicio</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>Siguiente</strong>Capítulo 17. Consultas por criterios</a></li></ul></body></html>