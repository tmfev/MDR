<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 13. Transacciones y concurrencia</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="prev" href="readonly.html" title="Capítulo 12. Read-only entities"/><link rel="next" href="events.html" title="Capítulo 14. Interceptores y eventos"/><link rel="copyright" href="Legal_Notice.html" title="Advertencia legal"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>Siguiente</strong></a></li></ul><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>Capítulo 13. Transacciones y concurrencia</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="transactions.html#transactions-basics">13.1. Ámbitos de sesión y de transacción</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-basics-uow">13.1.1. Unidad de trabajo</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-apptx">13.1.2. Conversaciones largas</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-identity">13.1.3. Consideración de la identidad del objeto</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-issues">13.1.4. Temas comúnes</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-demarcation">13.2. Demarcación de la transacción de la base de datos</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-demarcation-nonmanaged">13.2.1. Entorno no administrado</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-jta">13.2.2. Utilización de JTA</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-exceptions">13.2.3. Manejo de excepciones</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-timeout">13.2.4. Tiempo de espera de la transacción</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-optimistic">13.3. Control de concurrencia optimista</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-optimistic-manual">13.3.1. Chequeo de versiones de la aplicación</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-longsession">13.3.2. Sesión extendida y versionado automático</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-detached">13.3.3. Objetos separados y versionado automático</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-customizing">13.3.4. Personalización del versionado automático</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-locking">13.4. Bloqueo pesimista </a></span></dt><dt><span class="section"><a href="transactions.html#transactions-connection-release">13.5. Modos de liberación de la conexión</a></span></dt></dl></div><p>El punto más importante sobre Hibernate y el control de concurrencia es que es fácil de comprender. Hibernate usa directamente conexiones JDBC y recursos JTA sin agregar ningún comportamiento de bloqueo adicional. Le recomendamos bastante que tome algo de tiempo con la especificación de JDBC, ANSI y el aislamiento de transacciones de su sistema de gestión de base de datos.  </p><p>Hibernate no bloquea objetos en la memoria. Su aplicación puede esperar el comportamiento definido por el nivel de aislamiento de sus transacciones de las bases de datos. Gracias a la <code class="literal">Session</code>, la cual también es un caché con alcance de transacción, Hibernate proporciona lecturas repetidas para búsquedas del identificador y consultas de entidad y no consultas de reporte que retornan valores escalares. </p><p>Además del versionado del control de concurrencia optimista automático, Hibernate también ofrece una API (menor) para bloqueo pesimista de filas, usando la sintáxis <code class="literal">SELECT FOR UPDATE</code>. Esta API y el control de concurrencia optimista se discuten más adelante en este capítulo. </p><p>Comenzamos la discusión del control de concurrencia en Hibernate con la granularidad de <code class="literal">Configuration</code>, <code class="literal">SessionFactory</code> y <code class="literal">Session</code>, así como las transacciones de la base de datos y las conversaciones largas. </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>13.1. Ámbitos de sesión y de transacción</h2></div></div></div><p>Una <code class="literal">SessionFactory</code> es un objeto seguro entre hilos y costoso de crear pensado para que todas las hebras de la aplicación lo compartan. Se crea una sola vez, usualmente en el inicio de la aplicación, a partir de una instancia <code class="literal">Configuration</code>. </p><p>Una <code class="literal">Session</code> es un objeto de bajo costo, inseguro entre hilos que se debe utilizar una sola vez y luego se debe descartar: para un sólo pedido, una sola conversación o una sóla unidad de trabajo. Una <code class="literal">Session</code> no obtendrá una <code class="literal">Connection</code> JDBC o un <code class="literal">Datasource</code> a menos de que sea necesario. No consumirá recursos hasta que se utilice. </p><p>Una transacción de la base de datos tiene que ser tan corta como sea posible para reducir la contención de bloqueos en la base de datos. Las transacciones largas de la base de datos prevendrán a su aplicación de escalar a una carga altamente concurrente. Por lo tanto, no se recomienda que mantenga una transacción de la base de datos abierta durante el tiempo para pensar del usuario, hasta que la unidad de trabajo se encuentre completa. </p><p>¿Cuál es el ámbito de una unidad de trabajo? ¿Puede una sola <code class="literal">Session</code> de Hibernate extenderse a través de varias transacciones de la base de datos o ésta es una relación uno-a-uno de ámbitos? ¿Cuándo debe abrir y cerrar una <code class="literal">Session</code>? y ¿cómo demarca los límites de la transacción de la base de datos? En las siguientes secciones abordaremos estas preguntas.  </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>13.1.1. Unidad de trabajo</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as “<span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span>”[<a class="citation" href="bi01.html#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a class="xref" href="transactions.html#transactions-basics-apptx" title="13.1.2. Conversaciones largas">Sección 13.1.2, “Conversaciones largas”</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>Primero, no use el antipatrón <span class="emphasis"><em>sesión-por-operación</em></span>: no abra y cierre una <code class="literal">Session</code> para cada llamada simple a la base de datos en un solo hilo. Lo mismo aplica para las transacciones de base de datos. Las llamadas a la base de datos en una aplicación se hacen usando una secuencia planeada; estas se agrupan dentro de unidades de trabajo atómicas. Esto también significa que el auto-commit después de cada una de las declaraciones SQL es inútil en una aplicación ya que este modo está pensado para trabajo ad-hoc de consola SQL. Hibernate deshabilita, o espera que el servidor de aplicaciones lo haga, el modo auto-commit inmediatamente. Las transacciones de las bases de datos nunca son opcionales. Toda comunicación con una base de datos tiene que ocurrir dentro de una transacción. El comportamiento auto-commit para leer datos se debe evitar, ya que hay muy poca probabilidad de que las transacciones pequeñas funcionen mejor que una unidad de trabajo definida claramente. La última es mucho más sostenible y extensible. </p><p>El patrón más común en una aplicación multiusuario cliente/servidor es <span class="emphasis"><em>sesión-por-petición</em></span>. En este modelo, una petición del cliente se envia al servidor, en donde se ejecuta la capa de persistencia de Hibernate. Se abre una nueva <code class="literal">Session</code> de Hibernate y todas las operaciones de la base de datos se ejecutan en esta unidad de trabajo. Una vez completado el trabajo, y una vez se ha preparado la respuesta para el cliente, se limpia la sesión y se cierra. Use una sóla transacción de la base de datos para servir la petición del cliente, dándole inicio y guardándola cuando abre y cierra la <code class="literal">Session</code>. La relación entre las dos es uno-a-uno y este modelo es a la medida perfecta de muchas aplicaciones. </p><p>El reto se encuentra en la implementación. Hibernate brinda administración incorporada de la "sesión actual" para simplificar este patrón. Inicie una transacción cuando se tiene que procesar un pedido del servidor y termine la transacción antes de que se envie la respuesta al cliente. Las soluciones más comunes son <code class="literal">ServletFilter</code>, un interceptor AOP con un punto de corte en los métodos del servicio o un contenedor proxy/intercepción. Un contenedor EJB es una manera estandarizada de implementar aspectos de doble filo como demarcación de transacción en beans de sesión EJB, declarativamente con CMT. Si decide utilizar la demarcación de transacción programática, use el API <code class="literal">Transaction</code> de Hibernate de fácil uso y portable que se muestra más adelante en este capítulo. </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sesiones contextuales">Sección 2.3, “Sesiones contextuales”</a>. </p><p>Puede extender el ámbito de una <code class="literal">Session</code> y transacción de la base de datos hasta que "se ha presentado la vista". Esto es bastante útil en aplicaciones de servlet que utilizan una fase de entrega separada después de que se ha procesado el pedido. El extender la transacción de la base de datos hasta que la entrega de la vista se encuentre completa es fácil de lograr si implementa su propio interceptor. Sin embargo, no se logra fácilmente si depende de EJBs con transacciones administradas por el contenedor. Una transacción se completará cuando un método EJB retorna, antes de que pueda empezar la entrega de cualquier vista. Vea el sitio web de Hibernate y el foro para encontrar consejos y ejemplos sobre este patrón de <span class="emphasis"><em>sesión abierta en vista</em></span>. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>13.1.2. Conversaciones largas</h3></div></div></div><p>El patrón sesión-por-petición no es la única forma de diseñar unidades de trabajo. Muchos procesos empresariales requieren una serie completa de interacciones con el usuario intercaladas con accesos a la base de datos. En aplicaciones empresariales y web no es aceptable que una transacción de la base de datos abarque la interacción de un usuario. Considere el siguiente ejemplo: </p><div class="itemizedlist"><ul><li><p>Se abre la primera pantalla de un diálogo. Los datos que ve el usuario han sido cargados en una <code class="literal">Session</code> en particular y en una transacción de la base de datos. El usuario es libre de modificar los objetos. </p></li><li><p>El usuario hace click en "Guardar" después de 5 minutos y espera que sus modificaciones se hagan persistentes. También espera que él sea la única persona editando esta información y que no ocurra ningún conflicto en la modificación. </p></li></ul></div><p>Desde el punto de vista del usuario, llamamos a esta unidad de trabajo, una larga <span class="emphasis"><em>conversación</em></span> o <span class="emphasis"><em>transacción de aplicación</em></span>. Hay muchas formas de implementar esto en su aplicación. </p><p>Una primera implementación ingenua podría mantener abierta la <code class="literal">Session</code> y la transacción de la base de datos durante el tiempo para pensar del usuario, con bloqueos en la base de datos para prevenir la modificación simultánea y para garantizar el aislamiento y la atomicidad. Esto es un antipatrón, ya que la contención de bloqueo no permitiría a la aplicación escalar con el número de usuarios simultáneos. </p><p>Tiene que usar varias transacciones de la base de datos para implementar la conversación. En este caso, mantener el aislamiento de los procesos empresariales se vuelve una responsabilidad parcial de la capa de la aplicación. Una sóla conversación usualmente abarca varias transacciones de la base de datos. Será atómica si sólo una de estas transacciones de la base de datos (la última) almacena los datos actualizados. Todas las otras simplemente leen datos (por ejemplo, en un diálogo de estilo-asistente abarcando muchos ciclos petición/respuesta). Esto es más fácil de implementar de lo que suena, especialmente si usa las funcionalidades de Hibernate: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Versionado automático</em></span> - Hibernate puede realizar un control automático de concurrencia optimista por usted .Puede detectar automáticamente si ha ocurrido una modificación simultánea durante el tiempo para pensar del usuario. Chequee esto al final de la conversación.  </p></li><li><p><span class="emphasis"><em>Objetos separados</em></span>: Si decide usar el patrón <span class="emphasis"><em>sesión-por-petición</em></span>, todas las instancias cargadas estarán en estado separado durante el tiempo para pensar del usuario. Hibernate le permite volver a unir los objetos y hacer persistentes las modificaciones. El patrón se llama <span class="emphasis"><em>sesión-por-petición-con-objetos-separados</em></span>. Se usa el versionado automático para aislar las modificaciones simultáneas. </p></li><li><p><span class="emphasis"><em>Sesión extendida (o larga) </em></span> - La <code class="literal">Session</code> de Hibernate puede ser desconectada de la conexión JDBC subyacente después de que haya guardado la transacción de la base de datos y haya reconectado cuando ocurra una nueva petición del cliente. Este patrón se conoce como <span class="emphasis"><em>sesión-por-conversación</em></span> y hace la re-unión innecesaria. Para aislar las modificaciones simultáneas se usa el versionado automático y usualmente no se permite que se limpie la <code class="literal">Session</code> automáticamente sino explícitamente. </p></li></ul></div><p>Tanto la <span class="emphasis"><em>sesión-por-petición-con-objetos-separados</em></span> como la <span class="emphasis"><em>sesión-por-conversación</em></span> tienen ventajas y desventajas. Estas desventajas las discutimos más adelante en este capítulo en el contexto del control optimista de concurrencia. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>13.1.3. Consideración de la identidad del objeto</h3></div></div></div><p>Una aplicación puede acceder simultáneamente al mismo estado persistente en dos <code class="literal">Session</code>es diferentes. Sin embargo, una instancia de una clase persistente nunca se comparte entre dos instancias de <code class="literal">Session</code>. Por lo tanto, existen dos nociones diferentes de identidad:  </p><div class="variablelist"><dl><dt><span class="term">Identidad de Base de Datos</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">Identidad JVM</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>Para los bjetos unidos a una <code class="literal">Session</code><span class="emphasis"><em> en particular</em></span> (por ejemplo, en el ámbito de una <code class="literal">Session</code>) las dos nociones son equivalentes y la identidad de la MVJ para la identidad de la base de datos se encuentra garantizada por Hibernate. Mientras la aplicación acceda simultáneamente al "mismo" objeto empresarial (identidad persistente) en dos sesiones diferentes, las dos instancias serán realmente "diferentes" (identidad MVJ). Los conflictos se resuelven usando un enfoque optimista y el versionado automático en tiempo de vaciado/ al guardar. </p><p>Este enfoque deja que Hibernate y la base de datos se preocupen de la concurrencia. Además provee la mejor escalabilidad, ya que garantizando la identidad en unidades de trabajo monohilo no se necesitan bloqueos caros u otros medios de sincronización. La aplicación no necesita sincronizar sobre ningún objeto empresarial, siempre que se mantenga un solo hilo por <code class="literal">Session</code>. Dentro de una <code class="literal">Session</code> la aplicación puede usar con seguridad <code class="literal">==</code> para comparar objetos. </p><p>Sin embargo, una aplicación que usa <code class="literal">==</code> fuera de una <code class="literal">Session</code>, podría ver resultados inesperados. Esto podría ocurrir incluso en sitios algo inesperados. Por ejemplo, si pone dos instancias separadas dentro del mismo <code class="literal">Set</code> ambas podrían tener la misma identidad de la base de datos (por ejemplo, representar la misma fila). Sin embargo, la identidad MVJ, por definición, no está garantizada para las instancias en estado separado. El desarrollador tiene que sobrescribir los métodos <code class="literal">equals()</code> y <code class="literal">hashCode()</code> en las clases persistentes e implementar su propia noción de igualdad de objetos. Hay una advertencia: nunca use el identificador de la base de datos para implementar la igualdad. Use una clave de negocio, una combinación de atributos únicos, usualmente inmutables. El identificador de la base de datos cambiará si un objeto transitorio es hecho persistente. Si la instancia transitoria (usualmente junto a las instancias separadas) es mantenida en un <code class="literal">Set</code>, cambiar el código hash rompe el contrato del <code class="literal">Set</code>. Los atributos para las claves empresariales no tienen que ser tan estables como las claves principales de la base de datos, sólo tiene que garantizar estabilidad en tanto los objetos estén en el mismo <code class="literal">Set</code>. Mire el sitio web de Hibernate para obetener una discusión más profunda de este tema. Note también que éste no es problema de Hibernate, sino que simplemente se tiene que implementar la identidad y la igualdad de los objetos Java. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>13.1.4. Temas comúnes</h3></div></div></div><p>No use los antipatrones <span class="emphasis"><em>sesión-por-sesión-de-usuario</em></span> o <span class="emphasis"><em>sesión-por-aplicación</em></span> (hay excepciones raras a esta regla). Algunos de los siguientes temas también podrían aparecer con los patrones recomendados así que asegúrese de que entiende las implicaciones antes de tomar una decisión de diseño: </p><div class="itemizedlist"><ul><li><p>Una <code class="literal">Session</code> no es segura entre hilos. Las cosas que funcionan de manera simultánea, como las peticiones HTTP, beans de sesión, o workers de Swing, provocarán condiciones de competencia si una instancia de <code class="literal">Session</code> se comparte. Si guarda su <code class="literal">Session</code> de Hibernate en su <code class="literal">HttpSession</code> (se discute más adelante), debe considerar el sincronizar el acceso a su sesión HTTP. De otro modo, un usuario que hace click lo suficientemente rápido puede llegar a usar la misma <code class="literal">Session</code> en dos hilos ejecutándose simultáneamente. </p></li><li><p>Una excepción lanzada por Hibernate significa que tiene que deshacer su transacción de la base de datos y cerrar la <code class="literal">Session</code> inmediatamente (se discute en más detalle más adelante en este capítulo). Si su <code class="literal">Session</code> está vinculada a la aplicación, tiene que parar la aplicación. Deshacer la transacción de la base de datos no pone a sus objetos de vuelta al estado en que estaban al comienzo de la transacción. Esto significa que el estado de la base de datos y los objetos empreariales quedan fuera de sincronía. Usualmente esto no es un problema, pues las excepciones no son recuperables y tendrá que volver a comenzar después de deshacer de todos modos. </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a class="xref" href="batch.html" title="Capítulo 15. Procesamiento por lotes">Capítulo 15, <i>Procesamiento por lotes</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>13.2. Demarcación de la transacción de la base de datos</h2></div></div></div><p>Los límites de las transacciones de la base de datos o el sistema son siempre necesarios. Ninguna comunicación con la base de datos puede darse fuera de una transacción de la base de datos (esto parece confundir a muchos desarrolladores acostumbrados al modo auto-commit). Siempre use límites de transacción claros, incluso para las operaciones de sólo lectura. Dependiendo del nivel de aislamiento y las capacidades de la base de datos, esto podría requerirse o no, pero no hay inconvenientes si siempre demarca explícitamente las transacciones. Con seguridad, una transacción única de base de datos va a funcionar mejor que muchas transacciones pequeñas, inclusive para leer datos. </p><p>Una aplicación Hibernate puede ejecutarse en entornos no administrados (por ejemplo, aplicaciones simples Web o Swing autónomas) y entornos administrados por J2EE. En un entorno no administrado, Hibernate es usualmente responsable de su propio pool de conexiones de la base de datos. El desarrollador de aplicaciones tiene que establecer manualmente los límites de transacción (inicar, guardar o deshacer las transacciones de la base de datos) por sí mismo. Un entorno administrado usualmente proporciona transacciones gestionadas por contenedor, con el ensamble de transacción definido declarativamente (por ejemplo, en descriptores de despliegue de beans de sesión EJB). La demarcación programática de transacciones ya no es necesaria. </p><p>Sin embargo, comúnmente se quiere mantener su capa de persistencia portátil entre entornos locales- de recursos no-administrados y sistemas que pueden confiar en JTA, pero utilizar BMT en vez de CMT. En ambos casos utilizaría la demarcación de transacción programática. Hibernate ofrece una API de envoltura llamada <code class="literal">Transaction</code> que se traduce al sistema de transacciones nativo de su entorno de despliegue. Esta API es de hecho opcional, pero le recomendamos bastante su uso salvo que esté en un bean de sesión CMT.  </p><p>Usualmente, el finalizar una <code class="literal">Session</code> implica cuatro fases distintas: </p><div class="itemizedlist"><ul compact="compact"><li><p>limpiar la sesión </p></li><li><p>someter la transacción </p></li><li><p>cerrar la sesión </p></li><li><p>manejar excepciones </p></li></ul></div><p>Anteriormente se discutió el vacido de la sesión así que ahora vamos a mirar más de cerca la demarcación de transacciones y el manejo de excepciones en los dos entornos administrado y no administrado. </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>13.2.1. Entorno no administrado</h3></div></div></div><p>Si una capa de persistencia Hibernate se ejecuta en un entorno no administrado, las conexiones de la base de datos se manejan usualmente por simples pools de conexión (por ejemplo, no-DataSource) del cual Hibernate obtiene conexiones al ser necesario. El idioma de manejo de sesión/transacción se ve así: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>No tiene que vaciar con <code class="literal">flush()</code> la <code class="literal">Session</code> explícitamente: la llamada a <code class="literal">commit()</code> automáticamente dispara la sincronización dependiendo del <a class="link" href="objectstate.html#objectstate-flushing" title="11.10. Limpieza (flushing) de la sesión">FlushMode</a> para la sesión. Una llamada a <code class="literal">close()</code> marca el final de una sesión. La implicación principal de <code class="literal">close()</code> es que la conexión JDBC será abandonada por la sesión. Este código Java es portátil y ejecuta en entornos tanto no-administrados como JTA. </p><p>Como se mencionó anteriormente, una solución mucho más flexible es la administración de contexto "sesión actual" incorporada en Hibernate: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>No verá estos pedazos de código en una aplicación normal; las excepciones fatales (del sistema) siempre deben ser capturadas en la "cima". En otras palabras, el código que ejecuta las llamadas de Hibernate en la capa de persistencia y el código que maneja <code class="literal">RuntimeException</code> (y usualmente sólo puede limpiar y salir) se encuentran en capas diferentes. La administración de contexto actual de Hibernate puede simplificar de manera importante este diseño, ya que todo lo que necesita hacer es acceder a <code class="literal">SessionFactory</code>. El manejo de excepciones se discute más adelante en este capítulo. </p><p>Debe seleccionar <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code>, el cual es el predeterminado, y para el segundo ejemplo seleccionar <code class="literal">"thread"</code> como su <code class="literal">hibernate.current_session_context_class</code>. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>13.2.2. Utilización de JTA</h3></div></div></div><p>Si su capa de persistencia se ejecuta en un servidor de aplicaciones (por ejemplo, detrás de los beans de sesión EJB), cada conexión de fuente de datos obtenida por Hibernate será parte de la transacción JTA global de manera automática. También puede instalar una implementación JTA autónoma y utilizarla sin EJB. Hibernate ofrece dos estrategias para esta integración JTA. </p><p>Si usa transacciones gestionadas-por-bean (BMT) Hibernate le dirá al servidor de aplicaciones que comience y finalice una transacción BMT si usa la API de <code class="literal">Transaction</code>. De modo que, el código de gestión de la transacción es idéntico al de un entorno no administrado.  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Si quiere utilizar un vínculo de transacción <code class="literal">Session</code>, es decir, la funcionalidad <code class="literal">getCurrentSession()</code> para propagación de contexto de manera fácil, tendrá que utilizar el API <code class="literal">UserTransaction</code> del JTA directamente:  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">UserTransaction</span><span class="java_separator">)</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;java:comp/UserTransaction&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Do</span><span class="java_plain">&nbsp;some&nbsp;work&nbsp;on&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;bound&nbsp;to&nbsp;transaction</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">load</span><span class="java_separator">(...);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">persist</span><span class="java_separator">(...);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Con CMT, la demarcación de transacción se realiza en los descriptores de implementacion bean de sesión, no programáticamente. Por lo tanto el código se reduce a: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;CMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</pre><p>En un CMT/EJB incluso el deshacer sucede de forma automática. Un <code class="literal">RuntimeException</code> lanzado por un método bean de sesión le dice al contenedor que establezca una transacción global para deshacer. <span class="emphasis"><em>No necesita utilizar el API <code class="literal">Transaction</code> de Hibernate con BMT o CMT y obtiene la propagación automática de sesión"actual" vinculada a la transacción.</em></span> </p><p>Al configurar la fábrica de transacciones de Hibernate, escoja <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> si utiliza JTA directamente (BMT) y <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> en una bean de sesión CMT. Recuerde establecer también <code class="literal">hibernate.transaction.manager_lookup_class</code>. Asegúrese de que su <code class="literal">hibernate.current_session_context_class</code> no se encuentra configurado (compatibilidad retrasada) o configurada como <code class="literal">"jta"</code>. </p><p>La operación <code class="literal">getCurrentSession()</code> tiene un inconveniente en un entorno JTA. Hay una desventaja en el uso del modo de liberación de la conección <code class="literal">after_statement</code>, la cual luego se utiliza por defecto. Debido a una limitación de la especificación JTA, no le es posible a Hibernate limpiar automáticamente cualquier instancia <code class="literal">ScrollableResults</code> o <code class="literal">Iterator</code> no cerradas y retornadas por <code class="literal">scroll()</code> o <code class="literal">iterate()</code>. <span class="emphasis"><em>Tiene</em></span> que liberar el cursor de la base de datos subyacente llamando a <code class="literal">ScrollableResults.close()</code> o <code class="literal">Hibernate.close(Iterator)</code> explícitamente desde un bloque <code class="literal">finally</code>. La mayoría de las aplicaciones pueden evitar fácilmente el utilizar <code class="literal">scroll()</code> o <code class="literal">iterate()</code> del código JTA o CMT. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>13.2.3. Manejo de excepciones</h3></div></div></div><p>Si la <code class="literal">Session</code> lanza una excepción, incluyendo cualquier <code class="literal">SQLException</code>, debe deshacer inmediatamente la transacción de la base de datos, llamar a <code class="literal">Session.close()</code> y descartar la instancia de <code class="literal">Session</code>. Ciertos métodos de <code class="literal">Session</code> <span class="emphasis"><em>no</em></span> dejarán la sesión en un estado consistente. Ninguna excepción lanzada por Hibernate puede ser tratada como recuperable. Asegúrese de que la <code class="literal">Session</code> se cierre llamando a <code class="literal">close()</code> en un bloque <code class="literal">finally</code>. </p><p>La <code class="literal">HibernateException</code>, que envuelve a la mayoría de los errores que pueden ocurrir en la capa de persistencia de Hibernate, es una excepción no chequeada. No lo era en versiones anteriores de Hibernate. En nuestra opinión, no debemos forzar al desarrollador de aplicaciones a capturar una excepción irrecuperable en una capa baja. En la mayoría de los sistemas, las excepciones no chequeadas y fatales son manejadas en uno de los primeros cuadros de la pila de llamadas a métodos (por ejemplo, en las capas más altas) y presenta un mensaje de error al usuario de la aplicación o se toma alguna otra acción apropiada. Note que Hibernate podría también lanzar otras excepciones no chequeadas que no sean una <code class="literal">HibernateException</code>. Estas no son recuperables y debe tomarse una acción apropiada. </p><p>Hibernate envuelve <code class="literal">SQLException</code>s lanzadas mientras se interactúa con la base de datos en una <code class="literal">JDBCException</code>. De hecho, Hibernate intentará convertir la excepción en una subclase de <code class="literal">JDBCException</code> más significativa. La <code class="literal">SQLException</code> subyacente siempre está disponible por medio de <code class="literal">JDBCException.getCause()</code>. Hibernate convierte la <code class="literal">SQLException</code> en una subclase de <code class="literal">JDBCException</code> apropiada usando el <code class="literal">SQLExceptionConverter</code> adjunto a la <code class="literal">SessionFactory</code>. Por defecto, el <code class="literal">SQLExceptionConverter</code> está definido por el dialecto configurado. Sin embargo, también es posible enchufar una implementación personalizada . Consulte los javadocs de la clase <code class="literal">SQLExceptionConverterFactory</code> para obtener más detalles. Los subtipos estándar de <code class="literal">JDBCException</code> son:  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code>: indica un error con la comunicación JDBC subyacente. </p></li><li><p><code class="literal">SQLGrammarException</code>: indica un problema de gramática o sintáxis con el SQL publicado. </p></li><li><p><code class="literal">ConstraintViolationException</code>: indica alguna forma de violación de restricción de integridad. </p></li><li><p><code class="literal">LockAcquisitionException</code>: indica un error adquiriendo un nivel de bloqueo necesario para realizar una operación solicitada. </p></li><li><p><code class="literal">GenericJDBCException</code>: una excepción genérica que no encajó en ninguna de las otras categorías. </p></li></ul></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>13.2.4. Tiempo de espera de la transacción</h3></div></div></div><p>Una característica importante proporcionada por un entorno administrado como EJB que nunca es proporcionado para un código no-administrado, es el tiempo de espera de la transacción. Estos tiempos de espera se aseguran de que ninguna transacción que se comporte inapropiadamente pueda vincular recursos mientras no devuelva una respuesta al usuario. Fuera de un entorno administrado (JTA), Hibernate no puede proporcionar completamente esta funcionalidad. Sin embargo, Hibernate puede por lo menos controlar las operaciones de acceso de datos, asegurándose de que los bloqueos a nivel de base de datos y las consultas con grandes grupos de resultados se encuentran limitados por un tiempo de espera definido. En un entorno administrado, Hibernate puede delegar el tiempo de espera de la transacción a JTA. Esta funcionalidad es abstraída por el objeto <code class="literal">Transaction</code> de Hibernate. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">set&nbsp;transaction&nbsp;timeout&nbsp;to&nbsp;</span><span class="java_literal">3</span><span class="java_plain">&nbsp;seconds</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">setTimeout</span><span class="java_separator">(</span><span class="java_literal">3</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p><code class="literal">setTimeout()</code> no se puede llamar en un bean CMT, en donde se deben definir declarativamente los tiempos de espera de las transacciones. </p></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>13.3. Control de concurrencia optimista</h2></div></div></div><p>El único enfoque consistente con una alta concurrencia y una alta escalabilidad es el control de concurrencia optimista con versionamiento. El chequeo de versión utiliza números de versión, o sellos de fecha (timestamps), para detectar actualizaciones en conflicto y para prevenir la pérdida de actualizaciones. Hibernate proporciona tres enfoques posibles de escribir código de aplicación que utilice concurrencia optimista. Los casos de uso que mostramos se encuentran en el contexto de conversaciones largas, pero el chequeo de versiones tiene además el beneficio de prevenir la pérdida de actualizaciones en transacciones individuales de la base de datos. </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>13.3.1. Chequeo de versiones de la aplicación</h3></div></div></div><p>En una implementación que no tiene mucha ayuda de Hibernate, cada interacción con la base de datos ocurre en una nueva <code class="literal">Session</code> y el desarrollador es el responsable de recargar todas las intancias persistentes desde la base de datos antes de manipularlas. Este enfoque fuerza a la aplicación a realizar su propio chequeo de versiones para asegurar el aislamiento de transacciones de conversaciones. Este enfoque es el menos eficiente en términos de acceso a la base de datos. Es el enfoque más similar a los EJBs de entidad. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">int</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">,</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getKey</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;load&nbsp;the&nbsp;current&nbsp;state</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StaleObjectStateException</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>La propiedad <code class="literal">version</code> se mapea utilizando <code class="literal">&lt;version&gt;</code>, e Hibernate la incrementará automáticamente durante la limpieza si la entidad está desactualizada. </p><p>Si está operando un entorno de baja-concurrencia-de-datos y no requiere chequeo de versiones, puede usar este enfoque y simplemente saltarse el chequeo de versiones. En ese caso, <span class="emphasis"><em>el último que guarda gana</em></span> y será la estrategia por defecto para conversaciones largas. Tenga en mente que esto podría confundir a los usuarios de la aplicación, pues podrían experimentar pérdidas de actualizaciones sin mensajes de error ni oportunidad de fusionar los cambios conflictivos. </p><p>El chequeo manual de versiones es factible sólamente en circunstancias muy triviales y no es práctico para la mayoría de las aplicaciones. Con frecuencia se tienen que chequear no sólamente las intancias sólas, sino también grafos completos de objetos modificados. Hibernate ofrece el chequeo de versiones automático con el paradigma de diseño de <code class="literal">Session</code> larga o de instancias separadas. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>13.3.2. Sesión extendida y versionado automático</h3></div></div></div><p>Una sóla instancia de <code class="literal">Session</code> y sus instancias persistentes se utilizan para toda la convervsación conocida como <span class="emphasis"><em>sesión-por-conversación</em></span>. Hibernate chequea las versiones de instancia en el momento de vaciado, lanzando una excepción si se detecta una modificación concurrente. Le concierne al desarrollador capturar y manejar esta excepción. Las opciones comunes son la oportunidad del usuario de fusionar los cambios, o de recomenzar el proceso empresarial sin datos desactualizados. </p><p>La <code class="literal">Session</code> se desconecta de cualquier conexión JDBC subyacente a la espera de una interacción del usuario. Este enfoque es el más eficiente en términos de acceso a la base de datos. La aplicación no necesita por sí misma tratar con el chequeo de versiones, ni re-unir instancias separadas, ni tiene que recargar instancias en cada transacción de la base de datos. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;earlier&nbsp;by&nbsp;the&nbsp;old&nbsp;session</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Obtain</span><span class="java_plain">&nbsp;a&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;start&nbsp;transaction</span>
</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Also</span><span class="java_plain">&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span></pre><p>El objeto <code class="literal">foo</code> sabe en qué <code class="literal">Session</code> fue cargado. El dar inicio a una nueva base de datos en una sesión vieja obtiene una nueva conexión y reanuda la sesión. El guardar una transacción de la base de datos desconecta una sesión de la conexion JDBC y devuelve la conexión al pool. Después de la reconexión, para poder forzar una verificación de versión sobre datos que usted no está actalizando, puede llamar a <code class="literal">Session.lock()</code> con <code class="literal">LockMode.READ</code> en cualquier objeto que pueda haber sido actualizado por otra transacción. No necesita bloquear ningún dato que <span class="emphasis"><em>sí esté</em></span> actualizando. Usualmente configuraría <code class="literal">FlushMode.MANUAL</code> en una <code class="literal">Session</code> extendida, de manera que de hecho sólamente se permite persistir el último ciclo de transacción de la base de datos de todas las modificaciones realizadas en esta conversación. Sólamente esta última transacción de la base de datos incluiría la operación <code class="literal">flush()</code> y luego cierra -<code class="literal">close()</code>- la sesión para dar fin a la conversación. </p><p>Este patrón es problemático si la <code class="literal">Session</code> es demasiado grande para almacenarla durante el tiempo para pensar del usuario, por ejemplo, una <code class="literal">HttpSession</code> se debe mantener tan pequeña como sea posible. Como la <code class="literal">Session</code> también lo es el caché de primer nivel (obligatorio) y comprende todos los objetos cargados, probablemente podemos utilizar esta estrategia sólamente para unos pocos ciclos de pedido/respuesta. Debe utilizar una <code class="literal">Session</code> sólamente para una conversación única ya que pronto también tendrá  datos añejos. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>Las versiones anteriores de Hibernate necesitaban desconexión explícita y reconexión de una <code class="literal">Session</code>. Estos métodos ya no se aprueban ya que tienen el mismo efecto que dar inicio o finalizar a una transacción. </p></div><p>Mantenga la <code class="literal">Session</code> desconectada cerca a la capa de persistencia. Use un bean de sesión EJB con estado para mantener la <code class="literal">Session</code> en un entorno de tres capas . No la transfiera a la capa web ni la serialice en una capa separada para almacenarla en la <code class="literal">HttpSession</code>. </p><p>El patrón de sesión extendido, o <span class="emphasis"><em>sesión-por-conversación</em></span>, es más dificil de implementar con la administración de contexto de sesión actual. Necesita proporcionar su propia implementación de la <code class="literal">CurrentSessionContext</code> para esto, vea el Wiki de Hibernate para obtener más ejemplos. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>13.3.3. Objetos separados y versionado automático</h3></div></div></div><p>Cada interacción con el almacenamiento persistente ocurre en una nueva <code class="literal">Session</code>. Sin embargo, las mismas instancias persistentes son reutilizadas para cada interacción con la base de datos. La aplicación manipula el estado de las instancias separadas cargadas originalmente en otra <code class="literal">Session</code> y luego las readjunta usando <code class="literal">Session.update()</code>, <code class="literal">Session.saveOrUpdate()</code>, o <code class="literal">Session.merge()</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">saveOrUpdate</span><span class="java_separator">(</span><span class="java_plain">foo</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Use</span><span class="java_plain">&nbsp;merge</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;foo&quot;</span><span class="java_plain">&nbsp;might&nbsp;have&nbsp;been&nbsp;loaded&nbsp;already</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>De nuevo, Hibernate chequeará las versiones de la instancia durante el vaciado, lanzando una excepción si tuvieron lugar conflictos en las actualizaciones. </p><p>También puede llamar a <code class="literal">lock()</code> en lugar de <code class="literal">update()</code> y utilizar <code class="literal">LockMode.READ</code> (realizando un chequeo de versión, evitando todos los cachés) si está seguro de que el objeto no ha sido modificado. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>13.3.4. Personalización del versionado automático</h3></div></div></div><p>Puede deshabilitar el incremento de la versión automática de Hibernate para ciertas propiedades y colecciones en particular estableciendo el atributo de mapeo <code class="literal">optimistic-lock</code> como <code class="literal">false</code>. Hibernate entonces ya no incrementará más las versiones si la propiedad se encuentra desactualizada. </p><p>Los esquemas heredados de la base de datos con frecuencia son estáticos y no pueden ser modificados. Inclusive otras aplicaciones podrían también acceder la misma base de datos y no saber cómo manejar los números de versión ni los sellos de fecha. En ambos casos, el versionado no puede confiarse a una columna en particular en una tabla. Para forzar un chequeo de versiones sin un mapeo de propiedad de versión o sello de fecha, con una comparación del estado de todos los campos en una fila, active <code class="literal">optimistic-lock="all"</code> en el mapeo de <code class="literal">&lt;class&gt;</code>. Esto funciona conceptualmente sólamente si Hibernate puede comparar el estado viejo y el nuevo, es decir, si usa una sóla <code class="literal">Session</code> larga y no sesión-por-petición-con-instancias-separadas. </p><p>Las modificaciones simultáneas pueden permitirse en instancias en tanto los cambios que se hayan realizado no se superpongan. Si establece <code class="literal">optimistic-lock="dirty"</code> al mapear la <code class="literal">&lt;class&gt;</code>, Hibernate sólo comparará los campos desactualizados durante el vaciado. </p><p>En ambos casos, con columnas de versión/sello de fecha dedicadas o con comparación de campos completos/desactualizados, Hibernate utiliza una sóla declaración <code class="literal">UPDATE</code> (con una cláusula <code class="literal">WHERE</code> apropiada) por entidad para ejecutar el chequeo de versiones y actualizar la información. Si utiliza una persistencia transitiva para la re-unión en cascada de entidades asociadas, Hibernate podría ejecutar actualizaciones innecesarias. Esto usualmente no es problema, pero podrían ejecutarse disparadores (triggers) <span class="emphasis"><em>enactualizazción</em></span> en la base de datos incluso cuando no se haya hecho ningún cambio a las instancias separadas. Puede personalizar este comportamiento estableciendo <code class="literal">select-before-update="true"</code> en el mapeo de <code class="literal">&lt;class&gt;</code>, forzando a Hibernate a <code class="literal">SELECT</code> la instancia para asegurar que las actualizaciones realmente ocurran, antes de actualizar la fila. </p></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>13.4. Bloqueo pesimista </h2></div></div></div><p>No se pretende que los usuarios tomen mucho tiempo preocupándose de las estrategias de bloqueo. Usualmente es suficiente con especificar un nivel de aislamiento para las conexiones JDBC y entonces simplemente dejar que la base de datos haga todo el trabajo. Sin embargo, los usuarios avanzados a veces pueden obtener bloqueos exclusivos pesimistas, o reobtener bloqueos al comienzo de una nueva transacción. </p><p>Hibernate siempre usará el mecanismo de bloqueo de la base de datos, nunca el bloqueo de objetos en memoria. </p><p>La clase <code class="literal">LockMode</code> define los diferentes niveles de bloqueo que Hibernate puede adquirir. Un bloqueo se obtiene por medio de los siguientes mecanismos:  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode.WRITE</code> se adquiere automáticamente cuando Hibernate actualiza o inserta una fila. </p></li><li><p><code class="literal">LockMode.UPGRADE</code> se puede ser adquirir bajo petición explícita del usuario usando <code class="literal">SELECT ... FOR UPDATE</code> en bases de datos que soporten esa sintáxis. </p></li><li><p><code class="literal">LockMode.UPGRADE_NOWAIT</code> se puede adquirir bajo petición explícita del usuario usando un <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> bajo Oracle. </p></li><li><p><code class="literal">LockMode.READ</code> se adquiere automáticamente cuando Hibernate lee los datos bajo los niveles de aislamiento de lectura repetible o serializable. Se puede readquirir por pedido explícito del usuario. </p></li><li><p><code class="literal">LockMode.NONE</code> representa la ausencia de un bloqueo. Todos los objetos se pasan a este modo de bloqueo al final de una <code class="literal">Transaction</code>. Los objetos asociados con una sesión por medio de una llamada a <code class="literal">update()</code> o <code class="literal">saveOrUpdate()</code> también comienzan en este modo de bloqueo. </p></li></ul></div><p>La "petición explícita del usuario" se expresa en una de las siguientes formas: </p><div class="itemizedlist"><ul compact="compact"><li><p>Una llamada a <code class="literal">Session.load()</code>, especificando un <code class="literal">LockMode</code>. </p></li><li><p>Una llamada a <code class="literal">Session.lock()</code>. </p></li><li><p>Una llamada a <code class="literal">Query.setLockMode()</code>. </p></li></ul></div><p>Si se llama a <code class="literal">Session.load()</code> con <code class="literal">UPGRADE</code> o <code class="literal">UPGRADE_NOWAIT</code>, y el objeto pedido no ha sido cargado todavía por la sesión, el objeto es cargado usando <code class="literal">SELECT ... FOR UPDATE</code>. Si se llama a <code class="literal">load()</code> para un objeto que ya esté cargado con un bloqueo menos restrictivo que el pedido, Hibernate llama a <code class="literal">lock()</code> para ese objeto. </p><p><code class="literal">Session.lock()</code> realiza un chequeo de número de versión si el modo de bloqueo especificado es <code class="literal">READ</code>, <code class="literal">UPGRADE</code> o <code class="literal">UPGRADE_NOWAIT</code>. En el caso de <code class="literal">UPGRADE</code> o <code class="literal">UPGRADE_NOWAIT</code>, se usa <code class="literal">SELECT ... FOR UPDATE</code>. </p><p>Si la base de datos no soporta el modo de bloqueo solicitado, Hibernate usa un modo opcional apropiado en lugar de lanzar una excepción. Esto asegura que las aplicaciones serán portátiles. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>13.5. Modos de liberación de la conexión</h2></div></div></div><p>La herencia (2x) de Hibernate en relación con la administración de la conexion JDBC fue que una <code class="literal">Session</code> obtendría una conexión cuando se necesitara por primera vez y luego la mantendría hasta que se cerrara la sesión. Hibernate 3.x introdujo la noción de modos de liberación de conexión para decirle a la sesión como manejar sus conexiones JDBC. La siguiente discusión sólamente es pertinente para las conexiones provistas por medio de un <code class="literal">ConnectionProvider</code> configurado. Las conexiones provistas por el usuario no se discuten aquí. Los diferentes modos de liberación se identifican por los valores numerados de <code class="literal">org.hibernate.ConnectionReleaseMode</code>: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code>: es el comportamiento heredado descrito anteriormente. La sesión de Hibernate obtiene una conexión cuando necesita acceder a JDBC la primera vez y mantiene esa conexión hasta que se cierra la sesión. </p></li><li><p><code class="literal">AFTER_TRANSACTION</code>: libera las conecciones después de que se ha completado una <code class="literal">org.hibernate.Transaction</code>. </p></li><li><p><code class="literal">AFTER_STATEMENT</code> (también se conoce como una liberación agresiva): libera conexiones después de cada ejecución de una declaración. Se salta esta liberación agresiva si la declaración deja abiertos recursos asociados con la sesión dada. Actualmente la única situación donde ocurre esto es por medio del uso de <code class="literal">org.hibernate.ScrollableResults</code>. </p></li></ul></div><p>El parámetro de configuración <code class="literal">hibernate.connection.release_mode</code> se utiliza para especificar el modo de liberación a utilizar. Los valores posibles son los siguientes: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code> (predeterminado): esta opción delega al modo de liberación devuelto por el método <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code>. Para JTATransactionFactory, esto devuelve ConnectionReleaseMode.AFTER_STATEMENT; para JDBCTransactionFactory, esto devuelve ConnectionReleaseMode.AFTER_TRANSACTION. No cambie este comportamiento predeterminado ya que las fallas debido a este valor de esta configuración tienden a indicar errores y/o suposiciones en el código del usuario. </p></li><li><p><code class="literal">on_close</code>: usa ConnectionReleaseMode.ON_CLOSE. Esta configuración se deja para la compatibilidad con versiones anteriores, pero no se recomienda para nada su utilización. </p></li><li><p><code class="literal">after_transaction</code>: utiliza ConnectionReleaseMode.AFTER_TRANSACTION. Esta configuración no se debe utilizar en entornos JTA. También note que con ConnectionReleaseMode.AFTER_TRANSACTION, si se considera que una sesión se encuentra en modo auto-commit, las conexiones serán liberada como si el modo de liberación fuese AFTER_STATEMENT. </p></li><li><p><code class="literal">after_statement</code>: usa ConnectionReleaseMode.AFTER_STATEMENT. Además se consulta la <code class="literal">ConnectionProvider</code> configurada para ver si soporta esta característica <code class="literal">supportsAggressiveRelease()</code>. Si no, el modo de liberación se vuelve a establecer como ConnectionReleaseMode.AFTER_TRANSACTION. Esta configuración sólamente es segura en entornos en donde podemos re-adquirir la misma conexión JDBC subyacente cada vez que llamamos a <code class="literal">ConnectionProvider.getConnection()</code> o en entornos auto-commit, en donde no importa si recibimos la misma conexión. </p></li></ul></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>Anterior</strong>Capítulo 12. Read-only entities</a></li><li class="up"><a accesskey="u" href="#"><strong>Subir</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Inicio</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>Siguiente</strong>Capítulo 14. Interceptores y eventos</a></li></ul></body></html>