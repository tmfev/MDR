<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapitre 2. Architecture</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="tutorial.html" title="Chapitre 1. Tutoriel"/><link rel="next" href="session-configuration.html" title="Chapitre 3. Configuration"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Précédent</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Suivant</strong></a></li></ul><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Chapitre 2. Architecture</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="architecture.html#architecture-overview">2.1. Généralités</a></span></dt><dd><dl><dt><span class="section"><a href="architecture.html#architecture-overview-minimal">2.1.1. Minimal architecture</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-overview-comprehensive">2.1.2. Comprehensive architecture</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-overview-terms">2.1.3. Basic APIs</a></span></dt></dl></dd><dt><span class="section"><a href="architecture.html#architecture-jmx">2.2. Intégration JMX</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-current-session">2.3. Sessions contextuelles </a></span></dt></dl></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. Généralités</h2></div></div></div><p>Le diagramme ci-dessus procure une vue - (très) haut niveau - de l'architecture Hibernate : </p><div class="mediaobject" align="center"><img src="images/overview.png" align="middle"/></div><p>Unfortunately we cannot provide a detailed view of all possible runtime architectures. Hibernate is sufficiently flexible to be used in a number of ways in many, many architectures. We will, however, illustrate 2 specifically since they are extremes. </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-overview-minimal"/>2.1.1. Minimal architecture</h3></div></div></div><p>The "minimal" architecture has the application manage its own JDBC connections and provide those connections to Hibernate; additionally the application manages transactions for itself. This approach uses a minimal subset of Hibernate APIs. </p><div class="mediaobject" align="center"><img src="images/lite.png" align="middle"/></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-overview-comprehensive"/>2.1.2. Comprehensive architecture</h3></div></div></div><p>L'architecture "complète" abstrait l'application des API JDBC/JTA sous-jacentes et permet à Hibernate de s'occuper des détails. </p><div class="mediaobject" align="center"><img src="images/full_cream.png" align="middle"/></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-overview-terms"/>2.1.3. Basic APIs</h3></div></div></div><p>Here are quick discussions about some of the API objects depicted in the preceding diagrams (you will see them again in more detail in later chapters). </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="interfacename">org.hibernate.SessionFactory</code>)</span></dt><dd><p>A thread-safe, immutable cache of compiled mappings for a single database. A factory for <code class="interfacename">org.hibernate.Session</code> instances. A client of <code class="interfacename">org.hibernate.connection.ConnectionProvider</code>. Optionally maintains a <code class="literal">second level cache</code> of data that is reusable between transactions at a process or cluster level. </p></dd><dt><span class="term">Session (<code class="interfacename">org.hibernate.Session</code>)</span></dt><dd><p>A single-threaded, short-lived object representing a conversation between the application and the persistent store. Wraps a JDBC <code class="interfacename">java.sql.Connection</code>. Factory for <code class="interfacename">org.hibernate.Transaction</code>. Maintains a <code class="literal">first level cache</code> of persistent the application's persistent objects and collections; this cache is used when navigating the object graph or looking up objects by identifier. </p></dd><dt><span class="term">Objets et collections persistants</span></dt><dd><p>Short-lived, single threaded objects containing persistent state and business function. These can be ordinary JavaBeans/POJOs. They are associated with exactly one <code class="interfacename">org.hibernate.Session</code>. Once the <code class="interfacename">org.hibernate.Session</code> is closed, they will be detached and free to use in any application layer (for example, directly as data transfer objects to and from presentation). <a class="xref" href="objectstate.html" title="Chapitre 11. Travailler avec des objets">Chapitre 11, <i>Travailler avec des objets</i></a> discusses transient, persistent and detached object states. </p></dd><dt><span class="term">Objets et collections éphémères (transient) et détachés</span></dt><dd><p>Instances of persistent classes that are not currently associated with a <code class="interfacename">org.hibernate.Session</code>. They may have been instantiated by the application and not yet persisted, or they may have been instantiated by a closed <code class="interfacename">org.hibernate.Session</code>. <a class="xref" href="objectstate.html" title="Chapitre 11. Travailler avec des objets">Chapitre 11, <i>Travailler avec des objets</i></a> discusses transient, persistent and detached object states. </p></dd><dt><span class="term">Transaction (<code class="interfacename">org.hibernate.Transaction</code>)</span></dt><dd><p>(Optional) A single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC, JTA or CORBA transaction. A <code class="interfacename">org.hibernate.Session</code> might span several <code class="interfacename">org.hibernate.Transaction</code>s in some cases. However, transaction demarcation, either using the underlying API or <code class="interfacename">org.hibernate.Transaction</code>, is never optional. </p></dd><dt><span class="term">ConnectionProvider (<code class="interfacename">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Optional) A factory for, and pool of, JDBC connections. It abstracts the application from underlying <code class="interfacename">javax.sql.DataSource</code> or <code class="interfacename">java.sql.DriverManager</code>. It is not exposed to application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term">TransactionFactory (<code class="interfacename">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Optional) A factory for <code class="interfacename">org.hibernate.Transaction</code> instances. It is not exposed to the application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>Hibernate fournit de nombreuses interfaces d'extensions optionnelles que vous pouvez implémenter pour personnaliser le comportement de votre couche de persistance. Reportez vous à la documentation de l'API pour plus de détails.  </p></dd></dl></div><p>
            </p></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.2. Intégration JMX</h2></div></div></div><p>JMX est le standard J2EE de gestion des composants Java. Hibernate peut être géré via un service JMX standard. Nous fournissons une implémentation d'un MBean dans la distribution : <code class="literal">org.hibernate.jmx.HibernateService</code>.  </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a class="xref" href="session-configuration.html#configuration-optional-statistics" title="3.4.6. Statistiques Hibernate">Section 3.4.6, « Statistiques Hibernate »</a> for more information. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.3. Sessions contextuelles </h2></div></div></div><p>Certaines applications utilisant Hibernate ont besoin d'une sorte de session "contextuelle", où une session donnée est en effet liée à la portée d'un contexte particulier. Cependant, les applications ne définissent pas toutes la notion de contexte de la même manière, et différents contextes définissent différentes portées à la notion de "courant". Les applications qui utilisaient Hibernate, versions précédentes à la 3.0, avaient tendance à employer un principe maison de sessions contextuelles basées sur le <code class="literal">ThreadLocal</code>, ainsi que sur des classes utilitaires comme <code class="literal">HibernateUtil</code>, ou utilisaient des framework tiers (comme Spring ou Pico) qui fournissaient des sessions contextuelles basées sur l'utilisation de proxy/interception.  </p><p>A partir de la version 3.0.1, Hibernate a ajouté la méthode <code class="literal">SessionFactory.getCurrentSession()</code>. Initialement, cela demandait l'usage de transactions <code class="literal">JTA</code>, où la transaction <code class="literal">JTA</code> définissait la portée et le contexte de la session courante. L'équipe Hibernate pense que, étant donnée la maturité des nombreuses implémentations autonomes du <code class="literal">JTA TransactionManager</code>, la plupart (sinon toutes) des applications devraient utiliser la gestion des transactions par <code class="literal">JTA</code> qu'elles soient ou non déployées dans un conteneur <code class="literal">J2EE</code>. Par conséquent, il vous suffira de contextualiser vos sessions via la méthode basée sur <code class="literal">JTA</code>.  </p><p>Cependant, depuis la version 3.1, la logique derrière <code class="literal">SessionFactory.getCurrentSession()</code> est désormais enfichable. A cette fin, une nouvelle interface d'extension(<code class="literal">org.hibernate.context.CurrentSessionContext</code> et un nouveau paramètre de configuration <code class="literal">hibernate.current_session_context_class</code> ont été ajoutés pour enficher la portée et le contexte de sessions courantes caractéristiques. </p><p>Pour une description détaillée de son contrat, consultez les Javadocs de l'interface <code class="literal">org.hibernate.context.CurrentSessionContext</code>. Elle définit une seule méthode, <code class="literal">currentSession()</code>, par laquelle l'implémentation est responsable de traquer la session contextuelle courante. Hibernate fournit trois implémentations de cette interface : </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code> - les sessions courantes sont associées à une transaction <code class="literal">JTA</code>. La logique est la même que l'ancienne approche basée sur JTA. Consultez les javadocs pour pour plus d'informations.  </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code> - les sessions courantes sont traquées par l'exécution du thread. Consultez les javadocs pour plus d'informations.  </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code> - les sessions courantes sont traquées par l'exécution du thread. Toutefois, vous êtes responsable de lier et de délier une instance de <code class="literal">Session</code> avec des méthodes statiques de cette classe.  Elle n'ouvre jamais, ni ne nettoie ou ne ferme une <code class="literal">Session</code>. </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a class="xref" href="transactions.html" title="Chapitre 13. Transactions et Accès concurrents">Chapitre 13, <i>Transactions et Accès concurrents</i></a> for more information and code examples. </p><p>Le paramètre de configuration <code class="literal">hibernate.current_session_context_class</code> définit quelle implémentation de <code class="literal">org.hibernate.context.CurrentSessionContext</code> doit être utilisée. Notez que pour assurer la compatibilité avec les versions précédentes, si ce paramètre n'est pas défini mais qu'un <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> est configuré, Hibernate utilisera le <code class="literal">org.hibernate.context.JTASessionContext</code>. La valeur de ce paramètre devrait juste nommer la classe d'implémentation à utiliser. Pour les trois implémentations prêtes à utiliser, toutefois, il y a trois noms brefs correspondants : "jta", "thread" et "managed". </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Précédent</strong>Chapitre 1. Tutoriel</a></li><li class="up"><a accesskey="u" href="#"><strong>Niveau supérieur</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Sommaire</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Suivant</strong>Chapitre 3. Configuration</a></li></ul></body></html>