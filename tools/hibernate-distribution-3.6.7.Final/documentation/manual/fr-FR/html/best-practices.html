<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapitre 27. Meilleures pratiques</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="example-mappings.html" title="Chapitre 26. Exemple : quelques mappages"/><link rel="next" href="portability.html" title="Chapitre 28. Considérations de portabilité des bases de données"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="example-mappings.html"><strong>Précédent</strong></a></li><li class="next"><a accesskey="n" href="portability.html"><strong>Suivant</strong></a></li></ul><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="best-practices"/>Chapitre 27. Meilleures pratiques</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Découpez finement vos classes et mappez-les en utilisant <code class="literal">&lt;component&gt;</code> :</span></dt><dd><p>Utilisez une classe <code class="literal">Address</code> pour résumer <code class="literal">street</code>, <code class="literal">suburb</code>, <code class="literal">state</code>, <code class="literal">postcode</code>. Ceci permet la réutilisation du code et simplifie la maintenance.  </p></dd><dt><span class="term">Déclarez des propriétés d'identifiants dans les classes persistantes :</span></dt><dd><p>Hibernate rend les propriétés d'identifiants optionnelles. Il est recommandé de les utiliser pour de nombreuses raisons. Utilisez les identifiants comme 'synthetic' (générés, et sans connotation métier). </p></dd><dt><span class="term">Identifiez les clefs naturelles :</span></dt><dd><p>Identifiez les clefs naturelles pour toutes les entités, et mappez-les avec <code class="literal">&lt;natural-id&gt;</code>. Implémentez <code class="literal">equals()</code> et <code class="literal">hashCode()</code> pour comparer les propriétés qui composent la clef naturelle.  </p></dd><dt><span class="term">Placez chaque mapping de classe dans son propre fichier :</span></dt><dd><p>N'utilisez pas un unique document de mapping. Mappez <code class="literal">com.eg.Foo</code> dans le fichier <code class="literal">com/eg/Foo.hbm.xml</code>. Cela prend tout son sens lors d'un travail en équipe.  </p></dd><dt><span class="term">Chargez les mappings comme des ressources :</span></dt><dd><p>Déployez les mappings en même temps que les classes qu'ils mappent. </p></dd><dt><span class="term">Pensez à externaliser les chaînes de requêtes :</span></dt><dd><p>Ceci est une bonne habitude si vos requêtes appellent des fonctions SQL qui ne sont pas au standard ANSI. Cette externalisation des chaînes de requête dans les fichiers de mapping rendra votre application plus portable.  </p></dd><dt><span class="term">Utilisez les variables bindées.</span></dt><dd><p>Comme dans JDBC, remplacez toujours les valeurs non constantes par "?". N'utilisez jamais la manipulation des chaînes de caractères pour lier des valeurs non constantes dans une requête ! Encore mieux, utilisez les paramètres nommés dans les requêtes. </p></dd><dt><span class="term">Ne gérez pas vous-même les connexions JDBC :</span></dt><dd><p>Hibernate permet à l'application de gérer les connexions JDBC. Vous ne devriez gérer vos connexions qu'en dernier recours. Si vous ne pouvez pas utiliser les systèmes de connexions livrés, considérez la fourniture de votre propre implémentation de <code class="literal">org.hibernate.connection.ConnectionProvider</code>.  </p></dd><dt><span class="term">Considérez l'utilisation de types personnalisés :</span></dt><dd><p>Supposez que vous ayez un type Java, de telle bibliothèque, qui a besoin d'être persisté mais qui ne fournit pas les accesseurs nécessaires pour le mapper comme composant. Vous devriez implémenter <code class="literal">org.hibernate.UserType</code>. Cette approche évite au code de l'application, l'implémentation de transformations vers / depuis les types Hibernate.  </p></dd><dt><span class="term">Utilisez du JDBC pur dans les goulots d'étranglement :</span></dt><dd><p>In performance-critical areas of the system, some kinds of operations might benefit from direct JDBC. Do not assume, however, that JDBC is necessarily faster. Please wait until you <span class="emphasis"><em>know</em></span> something is a bottleneck. If you need to use direct JDBC, you can open a Hibernate <code class="literal">Session</code>, wrap your JDBC operation as a <code class="literal">org.hibernate.jdbc.Work</code> object and using that JDBC connection. This way you can still use the same transaction strategy and underlying connection provider. </p></dd><dt><span class="term">Comprenez le flush de <code class="literal">Session</code> :</span></dt><dd><p>De temps en temps la Session synchronise ses états persistants avec la base de données. Les performances seront affectées si ce processus arrive trop souvent. Vous pouvez parfois minimiser les flush non nécessaires en désactivant le flush automatique ou même en changeant l'ordre des requêtes et autres opérations effectuées dans une transaction particulière.  </p></dd><dt><span class="term">Dans une architecture à trois couches, vous pouvez utilisez des objets détachés :</span></dt><dd><p>Quand vous utilisez une architecture à base de servlet / session bean, vous pouvez passer des objets chargés dans le bean session vers et depuis la couche servlet / JSP. Utilisez une nouvelle session pour traiter chaque requête. Utilisez <code class="literal">Session.merge()</code> ou <code class="literal">Session.saveOrUpdate()</code> pour synchroniser les objets avec la base de données.  </p></dd><dt><span class="term">Dans une architecture à deux couches, pensez à utiliser les contextes de persistance longue :</span></dt><dd><p>Les transactions de bases de données doivent être aussi courtes que possible pour une meilleure extensibilité. Cependant, il est souvent nécessaire d'implémenter de longues <span class="emphasis"><em>transactions applicatives</em></span>, une simple unité de travail du point de vue de l'utilisateur. Une transaction applicative peut s'étaler sur plusieurs cycles de requêtes/réponses du client. Il est commun d'utiliser des objets détachés pour implémenter des transactions applicatives. Une alternative, extrêmement appropriée dans une architecture à deux couches, est de maintenir un seul contact de persistance ouvert (session) pour toute la durée de vie de la transaction applicative et simplement se déconnecter de la connexion JDBC à la fin de chaque requête, et se reconnecter au début de la requête suivante. Ne partagez jamais une seule session avec plus d'une transaction applicative, ou bien vous travaillerez avec des données périmées.  </p></dd><dt><span class="term">Considérez que les exceptions ne sont pas rattrapables :</span></dt><dd><p>Il s'agit plus d'une pratique obligatoire que d'une "meilleure pratique". Quand une exception intervient, il faut faire un rollback de la <code class="literal">Transaction</code> et fermer la <code class="literal">Session</code>. Sinon, Hibernate ne peut garantir l'intégrité des états persistants en mémoire. En particulier, n'utilisez pas <code class="literal">Session.load()</code> pour déterminer si une instance avec l'identifiant donné existe en base de données, à la place utilisez <code class="literal">Session.get()</code> ou une requête.  </p></dd><dt><span class="term">Préférez le chargement différé des associations :</span></dt><dd><p>Utilisez le chargement complet avec modération. Utilisez les proxies et les collections chargées tardivement pour la plupart des associations vers des classes qui ne sont pas susceptibles d'être complètement retenues dans le cache de second niveau. Pour les associations de classes en cache, où il y a une forte probabilité que l'élément soit en cache, désactivez explicitement le chargement par jointures ouvertes en utilisant <code class="literal">outer-join="false"</code>. Lorsqu'un chargement par jointure ouverte est approprié pour un cas d'utilisation particulier, utilisez une requête avec un <code class="literal">left join fetch</code>.  </p></dd><dt><span class="term">Utilisez le pattern <span class="emphasis"><em>d'une ouverture de session dans une vue</em></span>, ou une <span class="emphasis"><em>phase d'assemblage</em></span> disciplinée pour éviter des problèmes avec des données non rapatriées : </span></dt><dd><p>Hibernate libère les développeurs de l'écriture fastidieuse des <span class="emphasis"><em>objets de transfert de données </em></span> (DTO). Dans une architecture EJB traditionnelle, les DTO ont deux buts : premièrement, ils contournent le problème des beans entités qui ne sont pas sérialisables ; deuxièmement, ils définissent implicitement une phase d'assemblage où toutes les données utilisées par la vue sont rapatriées et organisées dans les DTO avant de retourner sous le contrôle de la couche de présentation. Hibernate élimine le premier but. Cependant, vous aurez encore besoin d'une phase d'assemblage (pensez à vos méthodes métier comme ayant un contrat strict avec la couche de présentation, en ce qui concerne les données disponibles dans les objets détachés) à moins que vous soyez préparés à garder le contexte de persistance (la session) ouvert à travers tout le processus de rendu de la vue. Ceci ne représente pas une limitation de Hibernate! Au contraire c'est une exigence fondamentale d'un accès sécurisé aux données transactionnelles.  </p></dd><dt><span class="term">Pensez à abstraire votre logique métier d'Hibernate :</span></dt><dd><p>Cachez le mécanisme d'accès aux données (Hibernate) derrière une interface. Combinez les modèles <span class="emphasis"><em>DAO</em></span> et <span class="emphasis"><em>Thread Local Session</em></span>. Vous pouvez même avoir quelques classes persistées par du JDBC pur, associées à Hibernate via un <code class="literal">UserType</code> (ce conseil est valable pour des applications de taille respectables ; il n'est pas valable pour une application avec cinq tables).  </p></dd><dt><span class="term">N'utilisez pas d'associations de mapping exotiques :</span></dt><dd><p>Les utilisations appropriées de vraies associations plusieurs-à-plusieurs sont rares. La plupart du temps vous avez besoin d'informations additionnelles stockées dans la table d'association. Dans ce cas, il est préférable d'utiliser deux associations un-à-plusieurs vers une classe de liaisons intermédiaire. En fait, nous pensons que la plupart des associations sont de type un-à-plusieurs ou plusieurs-à-un, vous devez être très prudent lorsque vous utilisez toute autre association et vous demander si c'est vraiment nécessaire.  </p></dd><dt><span class="term">Préférez les associations bidirectionnelles :</span></dt><dd><p>Les associations unidirectionnelles sont plus difficiles à questionner. Dans une grande application, la plupart des associations devraient être navigables dans les deux directions dans les requêtes.  </p></dd></dl></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="example-mappings.html"><strong>Précédent</strong>Chapitre 26. Exemple : quelques mappages</a></li><li class="up"><a accesskey="u" href="#"><strong>Niveau supérieur</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Sommaire</strong></a></li><li class="next"><a accesskey="n" href="portability.html"><strong>Suivant</strong>Chapitre 28. Considérations de portabilité des ba...</a></li></ul></body></html>