<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapitre 21. Améliorer les performances</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="xml.html" title="Chapitre 20. Mappage XML"/><link rel="next" href="toolsetguide.html" title="Chapitre 22. Guide de la boîte à outils"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>Précédent</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>Suivant</strong></a></li></ul><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>Chapitre 21. Améliorer les performances</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance.html#performance-fetching">21.1. Stratégies de chargement</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-fetching-lazy">21.1.1. Travailler avec des associations chargées en différé</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-custom">21.1.2. Personnalisation des stratégies de chargement</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-proxies">21.1.3. Proxies pour des associations vers un seul objet </a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-initialization">21.1.4. Initialisation des collections et des proxies</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-batch">21.1.5. Utiliser le chargement par lot</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-subselect">21.1.6. Utilisation du chargement par sous select</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-profiles">21.1.7. Fetch profiles</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-lazyproperties">21.1.8. Utiliser le chargement en différé des propriétés</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-cache">21.2. Le cache de second niveau</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-cache-mapping">21.2.1. Mappages de Cache</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-readonly">21.2.2. Stratégie : lecture seule</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-readwrite">21.2.3. Stratégie : lecture/écriture</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-nonstrict">21.2.4. Stratégie : lecture/écriture non stricte</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-transactional">21.2.5. Stratégie : transactionelle</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-compat-matrix">21.2.6. Support de stratégie de concurrence du fournisseur-cache</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-sessioncache">21.3. Gérer les caches</a></span></dt><dt><span class="section"><a href="performance.html#performance-querycache">21.4. Le cache de requêtes</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-querycache-enable">21.4.1. Enabling query caching</a></span></dt><dt><span class="section"><a href="performance.html#performance-querycache-regions">21.4.2. Query cache regions</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-collections">21.5. Comprendre les performances des collections</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-collections-taxonomy">21.5.1. Taxinomie</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-mostefficientupdate">21.5.2. Les lists, les maps, les idbags et les ensembles sont les collections les plus efficaces pour la mise à jour </a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-mostefficentinverse">21.5.3. Les sacs et les listes sont les plus efficaces pour les collections inverses</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-oneshotdelete">21.5.4. Suppression en un coup</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-monitoring">21.6. Moniteur de performance</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-monitoring-sf">21.6.1. Suivi d'une SessionFactory</a></span></dt><dt><span class="section"><a href="performance.html#performance-monitoring-metrics">21.6.2. Métriques</a></span></dt></dl></dd></dl></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>21.1. Stratégies de chargement</h2></div></div></div><p>Une <span class="emphasis"><em>stratégie de chargement</em></span> est une stratégie que Hibernate va utiliser pour récupérer des objets associés si l'application a besoin de naviguer à travers une association. Les stratégies de chargement peuvent être déclarées dans les méta-données de l'outil de mappage objet relationnel, ou surchargées par une requête de type HQL ou <code class="literal">Criteria</code> particulière.</p><p>Hibernate3 définit les stratégies de chargement suivantes :</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Chargement par jointure</em></span> - Hibernate récupère l'instance associée ou la collection dans un même <code class="literal">SELECT</code>, en utilisant un <code class="literal">OUTER JOIN</code>. </p></li><li><p><span class="emphasis"><em>Chargement par select</em></span> - Un second <code class="literal">SELECT</code> est utilisé pour récupérer l'instance associée à l'entité ou à la collection. À moins que vous ne désactiviez explicitement le chargement différé en spécifiant <code class="literal">lazy="false"</code>, ce second select ne sera exécuté que lorsque vous accéderez réellement à l'association.</p></li><li><p><span class="emphasis"><em>Chargement par sous-select</em></span> - Un second <code class="literal">SELECT</code> est utilisé pour récupérer les associations pour toutes les entités récupérées dans une requête ou un chargement préalable. A moins que vous ne désactiviez explicitement le chargement différé en spécifiant <code class="literal">lazy="false"</code>, ce second select ne sera exécuté que lorsque vous accéderez réellement à l'association. </p></li><li><p><span class="emphasis"><em>Chargement par lot</em></span> - Il s'agit d'une stratégie d'optimisation pour le chargement par select - Hibernate récupère un lot d'instances ou de collections en un seul <code class="literal">SELECT</code> en spécifiant une liste de clés primaires ou de clés étrangères. </p></li></ul></div><p>Hibernate fait également la distinction entre :</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Chargement immédiat</em></span> - Une association, une collection ou un attribut est chargé immédiatement lorsque l'objet auquel appartient cet élément est chargé. </p></li><li><p><span class="emphasis"><em>Chargement différé d'une collection</em></span> - Une collection est chargée lorsque l'application invoque une méthode sur cette collection (il s'agit du mode de chargement par défaut pour les collections). </p></li><li><p><span class="emphasis"><em>Chargement "super différé" d'une collection</em></span> - On accède aux éléments de la collection depuis la base de données lorsque c'est nécessaire. Hibernate essaie de ne pas charger toute la collection en mémoire sauf si cela est absolument nécessaire (bien adapté aux très grandes collections). </p></li><li><p><span class="emphasis"><em>Chargement par proxy</em></span> - Une association vers un seul objet est chargée lorsqu'une méthode autre que le getter sur l'identifiant est appelée sur l'objet associé.</p></li><li><p><span class="emphasis"><em>Chargement "sans proxy"</em></span> - une association vers un seul objet est chargée lorsque l'on accède à la variable d'instance. Par rapport au chargement par proxy, cette approche est moins différée (l'association est quand même chargée même si on n'accède qu'à l'identifiant) mais plus transparente car il n'y a pas de proxy visible dans l'application. Cette approche requiert une instrumentation du bytecode à la compilation et est rarement nécessaire. </p></li><li><p><span class="emphasis"><em>Chargement différé des attributs</em></span> - Un attribut ou un objet associé seul est chargé lorsque l'on accède à la variable d'instance. Cette approche requiert une instrumentation du bytecode à la compilation et est rarement nécessaire. </p></li></ul></div><p>Nous avons ici deux notions orthogonales : <span class="emphasis"><em>quand</em></span> l'association est chargée et <span class="emphasis"><em>comment</em></span> (quelle requête SQL est utilisée). Il ne faut pas les confondre. Le mode de chargement <code class="literal">fetch</code> est utilisé pour améliorer les performances. On peut utiliser le mode <code class="literal">lazy</code> pour définir un contrat sur quelles données sont toujours accessibles sur toute instance détachée d'une classe particulière. </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>21.1.1. Travailler avec des associations chargées en différé</h3></div></div></div><p>Par défaut, Hibernate3 utilise le chargement différé par select pour les collections et le chargement différé par proxy pour les associations vers un seul objet. Ces valeurs par défaut sont valables pour la plupart des associations dans la plupart des applications. </p><p>Si vous définissez <code class="literal">hibernate.default_batch_fetch_size</code>, Hibernate va utiliser l'optimisation du chargement par lot pour le chargement différé (cette optimisation peut aussi être activée à un niveau de granularité plus fin). </p><p>L'accès à une association définie comme "différé", hors du contexte d'une session Hibernate ouverte, entraîne une exception. Par exemple : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">s&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessions</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">openSession</span><!-- <br/> --><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_type">User</span><span class="java_plain">&nbsp;u&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">User</span><span class="java_separator">)</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;from&nbsp;User&nbsp;u&nbsp;where&nbsp;u.name=:userName&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setString</span><span class="java_separator">(</span><span class="java_literal">&quot;userName&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;userName</span><span class="java_separator">).</span><span class="java_plain">uniqueResult</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Map</span><span class="java_plain">&nbsp;permissions&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;u</span><span class="java_separator">.</span><span class="java_plain">getPermissions</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">s</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">Integer</span><span class="java_plain">&nbsp;accessLevel&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Integer</span><span class="java_separator">)</span><span class="java_plain">&nbsp;permissions</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">&quot;accounts&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Error</span><span class="java_operator">!</span></pre><p>Étant donné que la collection des permissions n'a pas été initialisée avant de fermer la <code class="literal">Session</code>, la collection n'est pas capable de charger son état. <span class="emphasis"><em>Hibernate ne supporte pas le chargement différé pour des objets détachés</em></span>. La solution à ce problème est de déplacer le code qui lit à partir de la collection avant le "commit" de la transaction. </p><p>Une autre alternative est d'utiliser une collection ou une association non "différée" en spécifiant <code class="literal">lazy="false"</code> dans le mappage de l'association. Cependant il est prévu que le chargement différé soit utilisé pour quasiment toutes les collections ou associations. Si vous définissez trop d'associations non "différées" dans votre modèle objet, Hibernate va finir par devoir charger toute la base de données en mémoire à chaque transaction.</p><p>Par ailleurs, on veut souvent choisir un chargement par jointure (qui est par défaut non différé) à la place du chargement par select dans une transaction particulière. Nous allons maintenant voir comment adapter les stratégies de chargement. Dans Hibernate3 les mécanismes pour choisir une stratégie de chargement sont identiques que l'on ait une association vers un objet simple ou vers une collection. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>21.1.2. Personnalisation des stratégies de chargement</h3></div></div></div><p>Le chargement par select (mode par défaut) est très vulnérable au problème du N+1 selects, ainsi vous souhaiterez peut-être activer le chargement par jointure dans les fichiers de mappage :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;permissions&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">fetch</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;userId&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Permission&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;mother&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">fetch</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>La stratégie de chargement définie à l'aide du mot <code class="literal">fetch</code> dans les fichiers de mappage affecte :</p><div class="itemizedlist"><ul><li><p>La récupération via <code class="literal">get()</code> ou <code class="literal">load()</code></p></li><li><p>La récupération implicite lorsque l'on navigue à travers une association</p></li><li><p>Les requêtes par <code class="literal">Criteria</code></p></li><li><p>Les requêtes HQL si l'on utilise le chargement par <code class="literal">subselect</code></p></li></ul></div><p>Quelle que soit la stratégie de chargement que vous utilisez, la partie du graphe d'objets, non-différée, sera chargée en mémoire. Cela peut mener à l'exécution de plusieurs selects successifs pour une seule requête HQL. </p><p>On n'utilise pas souvent les documents de mappage pour adapter le chargement. En revanche, on conserve le comportement par défaut et on le surcharge pour une transaction particulière en utilisant <code class="literal">left join fetch</code> dans les requêtes HQL. Cela indique à Hibernate de charger l'association de manière agressive lors du premier select en utilisant une jointure externe. Dans la requête API <code class="literal">Criteria</code> vous utiliserez la méthode <code class="literal">setFetchMode(FetchMode.JOIN)</code>.</p><p>S'il vous arrive de vouloir changer la stratégie de chargement utilisée par utilisée par <code class="literal">get()</code> ou <code class="literal">load()</code>, vous pouvez juste utiliser une requête de type <code class="literal">Criteria</code> comme par exemple : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_plain">&nbsp;user&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createCriteria</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setFetchMode</span><span class="java_separator">(</span><span class="java_literal">&quot;permissions&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">FetchMode</span><span class="java_separator">.</span><span class="java_plain">JOIN</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Restrictions</span><span class="java_separator">.</span><span class="java_plain">idEq</span><span class="java_separator">(</span><span class="java_plain">userId</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">uniqueResult</span><span class="java_separator">();</span></pre><p>Il s'agit de l'équivalent pour Hibernate de ce que d'autres outils de mappage appellent un "fetch plan" ou "plan de chargement".</p><p>Une autre manière complètement différente d'éviter le problème des N+1 selects est d'utiliser le cache de second niveau. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>21.1.3. Proxies pour des associations vers un seul objet </h3></div></div></div><p>Le chargement différé des collections est implémenté par Hibernate qui utilise ses propres implémentations pour des collections persistantes. Si l'on veut un chargement différé pour des associations vers un seul objet, il faut utiliser un autre mécanisme. L'entité qui est pointée par l'association doit être masquée derrière un proxy. Hibernate implémente l'initialisation différée des proxies sur des objets persistants via une mise à jour à chaud du bytecode (à l'aide de l'excellente librairie CGLIB).</p><p>Par défaut, Hibernate génère des proxies (au démarrage) pour toutes les classes persistantes et les utilise pour activer le chargement différé des associations <code class="literal">many-to-one</code> et <code class="literal">one-to-one</code>.</p><p>Le fichier de mappage peut déclarer une interface à utiliser comme interface de proxy pour cette classe à l'aide de l'attribut <code class="literal">proxy</code>. Par défaut Hibernate utilise une sous-classe de la classe persistante. <span class="emphasis"><em>Il faut que les classes pour lesquelles on ajoute un proxy implémentent un constructeur par défaut avec au minimum une visibilité de paquetage. Ce constructeur est recommandé pour toutes les classes persistantes !</em></span>.</p><p>Il y a quelques précautions à prendre lorsque l'on étend cette approche à des classes polymorphiques, par exemple : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Tout d'abord, les instances de <code class="literal">Cat</code> ne pourront jamais être "castées" en <code class="literal">DomesticCat</code>, même si l'instance sous-jacente est une instance de <code class="literal">DomesticCat</code> :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;instantiate&nbsp;a&nbsp;proxy&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">does&nbsp;not&nbsp;hit&nbsp;the&nbsp;db</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cat</span><span class="java_separator">.</span><span class="java_plain">isDomesticCat</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;hit&nbsp;the&nbsp;db&nbsp;to&nbsp;initialize&nbsp;the&nbsp;proxy</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;dc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cat</span><span class="java_separator">;</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Error</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">....</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Deuxièmement, il est possible de casser la notion de <code class="literal">==</code> des proxies. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;instantiate&nbsp;a&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;proxy</span>
<!--  --><br/><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;dc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;id</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;acquire&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;proxy</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_operator">==</span><span class="java_plain">dc</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span></pre><p>Cette situation n'est pas si mauvaise qu'il n'y parait. Même si nous avons deux références à deux objets proxies différents, l'instance sous-jacente sera quand même le même objet :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">setWeight</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">11.0</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;hit&nbsp;the&nbsp;db&nbsp;to&nbsp;initialize&nbsp;the&nbsp;proxy</span>
<!--  --><br/><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">&nbsp;dc</span><span class="java_separator">.</span><span class="java_plain">getWeight</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_literal">11.0</span></pre><p>Troisièmement, vous ne pourrez pas utiliser un proxy CGLIB pour une classe <code class="literal">final</code> ou pour une classe contenant la moindre méthode <code class="literal">final</code>. </p><p>Enfin, si votre objet persistant obtient une quelconque ressource à l'instanciation (par exemple dans les initialiseurs ou dans le constructeur par défaut), alors ces ressources seront aussi obtenues par le proxy. La classe proxy est en réalité une sous-classe de la classe persistante. </p><p>Ces problèmes sont tous dus aux limitations fondamentales du modèle d'héritage unique de Java. Si vous souhaitez éviter ces problèmes, vos classes persistantes doivent chacune implémenter une interface qui déclare ses méthodes métier. Vous devriez alors spécifier ces interfaces dans le fichier de mappage : <code class="literal">CatImpl</code> implémente l'interface <code class="literal">Cat</code> et <code class="literal">DomesticCatImpl</code> implémente l'interface <code class="literal">DomesticCat</code>. Par exemple :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CatImpl&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCatImpl&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Tout d'abord, les instances de <code class="literal">Cat</code> et de <code class="literal">DomesticCat</code> peuvent être retournées par <code class="literal">load()</code> ou par <code class="literal">iterate()</code>.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">CatImpl</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Iterator</span><span class="java_plain">&nbsp;iter&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;from&nbsp;CatImpl&nbsp;as&nbsp;cat&nbsp;where&nbsp;cat.name='fritz'&quot;</span><span class="java_separator">).</span><span class="java_plain">iterate</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Cat</span><span class="java_plain">&nbsp;fritz&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;iter</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">();</span></pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Remarque</h2><p><code class="literal">list()</code> ne retourne pas les proxies normalement.</p></div><p>Les relations sont aussi initialisées en différé. Ceci signifie que vous devez déclarer chaque propriété comme étant de type <code class="literal">Cat</code>, et non <code class="literal">CatImpl</code>.</p><p>Certaines opérations ne nécessitent <span class="emphasis"><em>pas</em></span> l'initialisation du proxy :</p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code>, si la classe persistante ne surcharge pas <code class="literal">equals()</code> </p></li><li><p><code class="literal">hashCode()</code>, si la classe persistante ne surcharge pas <code class="literal">hashCode()</code> </p></li><li><p>La méthode getter de l'identifiant </p></li></ul></div><p>Hibernate détectera les classes qui surchargent <code class="literal">equals()</code> ou <code class="literal">hashCode()</code>.</p><p>Eh choisissant <code class="literal">lazy="no-proxy"</code> au lieu de <code class="literal">lazy="proxy"</code> qui est la valeur par défaut, il est possible d'éviter les problèmes liés au transtypage. Il faudra alors une instrumentation du bytecode à la compilation et toutes les opérations résulteront immédiatement en une initialisation du proxy. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>21.1.4. Initialisation des collections et des proxies</h3></div></div></div><p>Une exception de type <code class="literal">LazyInitializationException</code> sera renvoyée par Hibernate si une collection ou un proxy non initialisé est accédé en dehors de la portée de la <code class="literal">Session</code>, par ex. lorsque l'entité à laquelle appartient la collection ou qui a une référence vers le proxy, est dans l'état "détaché". </p><p>Parfois, nous devons nous assurer qu'un proxy ou une collection est initialisé avant de fermer la <code class="literal">Session</code>. Bien sûr, nous pouvons toujours forcer l'initialisation en appelant par exemple <code class="literal">cat.getSex()</code> ou <code class="literal">cat.getKittens().size()</code>. Mais ceci n'est pas très lisible pour les personnes parcourant le code et n'est pas approprié pour le code générique. </p><p>Les méthodes statiques <code class="literal">Hibernate.initialize()</code> et <code class="literal">Hibernate.isInitialized()</code> fournissent à l'application un moyen de travailler avec des proxies ou des collections initialisés. <code class="literal">Hibernate.initialize(cat)</code> forcera l'initialisation d'un proxy de <code class="literal">cat</code>, si tant est que sa <code class="literal">Session</code> est ouverte. <code class="literal">Hibernate.initialize( cat.getKittens() )</code> a le même effet sur la collection kittens. </p><p>Une autre option est de conserver la <code class="literal">Session</code> ouverte jusqu'à ce que toutes les collections et tous les proxies nécessaires aient été chargés. Dans certaines architectures applicatives, particulièrement celles ou le code d'accès aux données via Hiberante et le code qui utilise ces données sont dans des couches applicatives différentes ou des processus physiques différents, il sera alors difficile de garantir que la <code class="literal">Session</code> est ouverte lorsqu'une collection est initialisée. Il y a deux moyens de maîtriser ce problème : </p><div class="itemizedlist"><ul><li><p>Dans une application web, un filtre de servlet peut être utilisé pour fermer la <code class="literal">Session</code> uniquement lorsque la requête a été entièrement traitée, lorsque le rendu de la vue est fini (il s'agit du modèle <span class="emphasis"><em>Vue de la session ouverte</em></span>). Bien sûr, cela demande plus d'attention à la bonne gestion des exceptions de l'application. Il est d'une importance vitale que la <code class="literal">Session</code> soit fermée et la transaction terminée avant que l'on rende la main à l'utilisateur même si une exception survient durant le traitement de la vue. Voir le wiki Hibernate pour des exemples sur le modèle "Open Session in View". </p></li><li><p>Dans une application avec une couche métier multiniveaux séparée, la couche contenant la logique métier doit "préparer" toutes les collections qui seront nécessaires à la couche web multiniveaux avant de retourner les données. Cela signifie que la couche métier doit charger toutes les données et retourner toutes les données déjà initialisées à la couche de présentation/web pour un cas d'utilisation donné. En général l'application appelle la méthode <code class="literal">Hibernate.initialize()</code> pour chaque collection nécessaire dans la couche web (cet appel doit être fait avant la fermeture de la session) ou bien récupère les collections de manière agressive à l'aide d'une requête HQL avec une clause <code class="literal">FETCH</code> ou à l'aide du mode <code class="literal">FetchMode.JOIN</code> pour une requête de type <code class="literal">Criteria</code>. Cela est en général plus facile si vous utilisez le modèle <span class="emphasis"><em>Command</em></span> plutôt que <span class="emphasis"><em>Session Facade</em></span>. </p></li><li><p>Vous pouvez également attacher à une <code class="literal">Session</code> un objet chargé au préalable à l'aide des méthodes <code class="literal">merge()</code> ou <code class="literal">lock()</code> avant d'accéder aux collections (ou aux proxies) non initialisés. Non, Hibernate ne fait pas, et ne doit pas faire cela automatiquement car cela pourrait introduire une sémantique transactionnelle ad hoc. </p></li></ul></div><p>Parfois, vous ne voulez pas initialiser une grande collection mais vous avez quand même besoin d'informations sur elle (comme sa taille) ou un sous-ensemble de ses données.</p><p>Vous pouvez utiliser un filtre de collection pour récupérer sa taille sans l'initialiser :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">list</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">get</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">0</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p>La méthode <code class="literal">createFilter()</code> est également utilisée pour récupérer efficacement des sous-ensembles d'une collection sans avoir besoin de l'initialiser dans son ensemble :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;lazyCollection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">setFirstResult</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">0</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">setMaxResults</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">10</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">list</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>21.1.5. Utiliser le chargement par lot</h3></div></div></div><p>Pour améliorer les performances, Hibernate peut utiliser le chargement par lot ce qui veut dire que Hibernate peut charger plusieurs proxies (ou collections) non initialisés en une seule requête lorsque l'on accède à l'un de ces proxies. Le chargement par lot est une optimisation intimement liée à la stratégie de chargement en différé par select. Il y a deux moyens d'activer le chargement par lot : au niveau de la classe et au niveau de la collection.</p><p>Le chargement par lot pour les classes/entités est plus simple à comprendre. Imaginez que vous ayez la situation suivante à l'exécution : vous avez 25 instances de <code class="literal">Cat</code> chargées dans une <code class="literal">Session</code>, chaque <code class="literal">Cat</code> a une référence à son <code class="literal">owner</code>, une <code class="literal">Person</code>. La classe <code class="literal">Person</code> est mappée avec un proxy, <code class="literal">lazy="true"</code>. Si vous itérez sur tous les cats et appelez <code class="literal">getOwner()</code> sur chacun d'eux, Hibernate exécutera par défaut 25 <code class="literal">SELECT</code>, pour charger les owners (initialiser le proxy). Vous pouvez paramétrer ce comportement en spécifiant une <code class="literal">batch-size</code> (taille du lot) dans le mappage de <code class="literal">Person</code> : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">batch-size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;10&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">...</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Hibernate exécutera désormais trois requêtes, en chargeant respectivement 10, 10, et 5 entités. </p><p>Vous pouvez aussi activer le chargement par lot pour les collections. Par exemple, si chaque <code class="literal">Person</code> a une collection chargée en différé des <code class="literal">Cat</code>s, et que 10 personnes sont actuellement chargées dans la <code class="literal">Session</code>, itérer sur toutes les persons générera 10 <code class="literal">SELECT</code> s, un pour chaque appel de <code class="literal">getCats()</code>. Si vous activez le chargement par lot pour la collection <code class="literal">cats</code> dans le mappage de <code class="literal">Person</code>, Hibernate pourra précharger les collections :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cats&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">batch-size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;3&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Avec une taille de lot <code class="literal">batch-size</code> de 8, Hibernate chargera respectivement des collections 3, 3, 3, et 1 en quatre <code class="literal">SELECT</code> s. Encore une fois, la valeur de l'attribut dépend du nombre de collections non initialisées dans une <code class="literal">Session</code> particulière. </p><p>Le chargement par lot de collections est particulièrement utile si vous avez une arborescence imbriquée d'éléments, c'est-à-dire le le schéma facture de matériels typique. (Bien qu'un <span class="emphasis"><em>sous ensemble</em></span> ou un <span class="emphasis"><em>chemin matérialisé</em></span> soit probablement une meilleure option pour des arbres principalement en lecture.) </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>21.1.6. Utilisation du chargement par sous select</h3></div></div></div><p>Si une collection en différé ou un proxy vers un objet doit être chargée, Hibernate va tous les charger en ré-exécutant la requête originale dans un sous select. Cela fonctionne de la même manière que le chargement par lot sans la possibilité de fragmenter le chargement.</p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-profiles"/>21.1.7. Fetch profiles</h3></div></div></div><p>Another way to affect the fetching strategy for loading associated objects is through something called a fetch profile, which is a named configuration associated with the <code class="interfacename">org.hibernate.SessionFactory</code> but enabled, by name, on the <code class="interfacename">org.hibernate.Session</code>. Once enabled on a <code class="interfacename">org.hibernate.Session</code>, the fetch profile will be in affect for that <code class="interfacename">org.hibernate.Session</code> until it is explicitly disabled.</p><p>So what does that mean? Well lets explain that by way of an example which show the different available approaches to configure a fetch profile:</p><div class="example"><a id="d0e18874"/><p class="title"><b>Exemple 21.1. Specifying a fetch profile using <code class="classname">@FetchProfile</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">@Entity</span><br />
<span class="xml_plain">@FetchProfile(name&nbsp;=&nbsp;&quot;customer-with-orders&quot;,&nbsp;fetchOverrides&nbsp;=&nbsp;{</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@FetchProfile.FetchOverride(entity&nbsp;=&nbsp;Customer.class,&nbsp;association&nbsp;=&nbsp;&quot;orders&quot;,&nbsp;mode&nbsp;=&nbsp;FetchMode.JOIN)</span><br />
<span class="xml_plain">})</span><br />
<span class="xml_plain">public&nbsp;class&nbsp;Customer&nbsp;{</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@Id</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@GeneratedValue</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;id;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;customerNumber;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@OneToMany</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;Set</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">Order</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;orders;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;//&nbsp;standard&nbsp;getter/setter</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">}</span><br />
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e18881"/><p class="title"><b>Exemple 21.2. Specifying a fetch profile using <code class="literal">&lt;fetch-profile&gt;</code> outside <code class="literal">&lt;class&gt;</code> node</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cust_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch-profile</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;customer-with-orders&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">entity</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">association</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">style</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetch-profile</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e18892"/><p class="title"><b>Exemple 21.3. Specifying a fetch profile using <code class="literal">&lt;fetch-profile&gt;</code> inside <code class="literal">&lt;class&gt;</code> node</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cust_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch-profile</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;customer-with-orders&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">association</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">style</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetch-profile</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>Now normally when you get a reference to a particular customer, that customer's set of orders will be lazy meaning we will not yet have loaded those orders from the database. Normally this is a good thing. Now lets say that you have a certain use case where it is more efficient to load the customer and their orders together. One way certainly is to use "dynamic fetching" strategies via an HQL or criteria queries. But another option is to use a fetch profile to achieve that. The following code will load both the customer <span class="emphasis"><em>and</em></span>their orders:</p><div class="example"><a id="d0e18908"/><p class="title"><b>Exemple 21.4. Activating a fetch profile for a given <code class="classname">Session</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Session</span><!-- <br/> --><span class="java_plain">&nbsp;session&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">...;</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">enableFetchProfile</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;customer-with-orders&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;name&nbsp;matches&nbsp;from&nbsp;mapping</span>
<!--  --><br/><span class="java_type">Customer</span><span class="java_plain">&nbsp;customer&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Customer</span><span class="java_separator">)</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Customer</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;customerId&nbsp;</span><span class="java_separator">);</span>
</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="classname">@FetchProfile </code>definitions are global and it does not matter on which class you place them. You can place the <code class="classname">@FetchProfile</code> annotation either onto a class or package (package-info.java). In order to define multiple fetch profiles for the same class or package <code class="classname">@FetchProfiles</code> can be used.</p></div><p>Currently only join style fetch profiles are supported, but they plan is to support additional styles. See <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-3414">HHH-3414</a> for details.</p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>21.1.8. Utiliser le chargement en différé des propriétés</h3></div></div></div><p>Hibernate3 supporte le chargement en différé de propriétés individuelles. La technique d'optimisation est également connue sous le nom de <span class="emphasis"><em>fetch groups</em></span> (groupes de chargement). Il faut noter qu'il s'agit principalement d'une fonctionnalité marketing car en pratique l'optimisation de la lecture d'un enregistrement est beaucoup plus importante que l'optimisation de la lecture d'une colonne. Cependant, la restriction du chargement à certaines colonnes peut être pratique dans des cas extrêmes, lorsque des tables "legacy" possèdent des centaines de colonnes et que le modèle de données ne peut pas être amélioré.</p><p>Pour activer le chargement en différé d'une propriété, il faut mettre l'attribut <code class="literal">lazy</code> sur une propriété particulière du mappage :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Document&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;native&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;50&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;summary&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;200&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">lazy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;text&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;2000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">lazy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Le chargement en différé des propriétés requiert une instrumentation du bytecode lors de la compilation ! Si les classes persistantes ne sont pas instrumentées, Hibernate ignorera de manière silencieuse le mode en différé et retombera dans le mode de chargement immédiat. </p><p>Pour l'instrumentation du bytecode vous pouvez utiliser la tâche Ant suivante :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">target</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;instrument&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">depends</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;compile&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">taskdef</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;instrument&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">classname</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.tool.instrument.InstrumentTask&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">path</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${jar.path}&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">path</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${classes.dir}&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">refid</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;lib.class.path&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">taskdef</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">instrument</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">verbose</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fileset</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">dir</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${testclasses.dir}/org/hibernate/auction/model&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">include</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;*.class&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fileset</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">instrument</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">target</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Une autre façon (meilleure ?) pour éviter de lire plus de colonnes que nécessaire au moins pour des transactions en lecture seule est d'utiliser les fonctionnalités de projection des requêtes HQL ou Criteria. Cela évite de devoir instrumenter le bytecode à la compilation et est certainement une solution préférable. </p><p>Vous pouvez forcer le mode de chargement agressif des propriétés en utilisant <code class="literal">fetch all properties</code> dans les requêtes HQL. </p></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>21.2. Le cache de second niveau</h2></div></div></div><p>Une <code class="literal">Session</code> Hibernate est un cache de niveau transactionnel de données persistantes. Il est possible de configurer un cache de cluster ou de JVM (de niveau <code class="literal">SessionFactory</code>) défini classe par classe et collection par collection. Vous pouvez même utiliser votre choix de cache en implémentant le fournisseur associé. Faites attention, les caches ne sont jamais avertis des modifications faites dans la base de données par d'autres applications (ils peuvent cependant être configurés pour régulièrement expirer les données en cache). </p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed in <a class="xref" href="performance.html#cacheproviders" title="Tableau 21.1. Fournisseurs de cache">Tableau 21.1, « Fournisseurs de cache »</a>. You can also implement your own and plug it in as outlined above. Note that versions prior to Hibernate 3.2 use EhCache as the default cache provider.</p><div class="table"><a id="cacheproviders"/><p class="title"><b>Tableau 21.1. Fournisseurs de cache</b></p><div class="table-contents"><table summary="Fournisseurs de cache" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">Classe pourvoyeuse</th><th align="left">Type</th><th align="left">Cluster sécurisé</th><th align="left">Cache de requêtes supporté</th></tr></thead><tbody><tr><td align="left">Table de hachage (ne pas utiliser en production)</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">mémoire</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">memory, disk, transactional, clustered</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">mémoire, disque</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">en cluster (multicast ip)</td><td align="left">oui (invalidation de cluster)</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">en cluster (multicast ip), transactionnel</td><td align="left">oui (réplication)</td><td align="left">oui (horloge sync. nécessaire)</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc.JBossCacheRegionFactory</code></td><td align="left">en cluster (multicast ip), transactionnel</td><td align="left">oui (replication ou invalidation)</td><td align="left">oui (horloge sync. nécessaire)</td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>21.2.1. Mappages de Cache</h3></div></div></div><p>As we have done in previous chapters we are looking at the two different possibiltites to configure caching. First configuration via annotations and then via Hibernate mapping files.</p><p>By default, entities are not part of the second level cache and we recommend you to stick to this setting. However, you can override this by setting the <code class="literal">shared-cache-mode</code> element in your <code class="filename">persistence.xml</code> file or by using the <code class="literal">javax.persistence.sharedCache.mode </code>property in your configuration. The following values are possible:</p><div class="itemizedlist"><ul><li><p><code class="literal">ENABLE_SELECTIVE</code> (Default and recommended value): entities are not cached unless explicitly marked as cacheable.</p></li><li><p><code class="literal">DISABLE_SELECTIVE</code>: entities are cached unless explicitly marked as not cacheable.</p></li><li><p><code class="literal">ALL</code>: all entities are always cached even if marked as non cacheable.</p></li><li><p><code class="literal">NONE</code>: no entity are cached even if marked as cacheable. This option can make sense to disable second-level cache altogether.</p></li></ul></div><p>The cache concurrency strategy used by default can be set globaly via the <code class="literal">hibernate.cache.default_cache_concurrency_strategy</code> configuration property. The values for this property are:</p><div class="itemizedlist"><ul><li><p><code class="literal">read-only</code></p></li><li><p><code class="literal">read-write</code></p></li><li><p><code class="literal">nonstrict-read-write</code></p></li><li><p><code class="literal">transactional</code></p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>It is recommended to define the cache concurrency strategy per entity rather than using a global one. Use the <code class="classname">@org.hibernate.annotations.Cache</code> annotation for that.</p></div><div class="example"><a id="example-cache-concurrency-with-cache-annotation"/><p class="title"><b>Exemple 21.5. Definition of cache concurrency strategy via <code class="classname">@Cache</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Entity</span><!-- <br/> --><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cacheable</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">Forest</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>Hibernate also let's you cache the content of a collection or the identifiers if the collection contains other entities. Use the <code class="classname">@Cache</code> annotation on the collection property.</p><div class="example"><a id="d0e19148"/><p class="title"><b>Exemple 21.6. Caching collections using annotations</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">OneToMany</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">cascade</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">CascadeType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">ALL</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;fetch</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">FetchType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">EAGER</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">JoinColumn</span><span class="java_separator">(</span><span class="java_plain">name</span><span class="java_operator">=</span><span class="java_literal">&quot;CUST_ID&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">SortedSet</span><span class="java_operator">&lt;</span><span class="java_type">Ticket</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;getTickets</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;tickets</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p><a class="xref" href="performance.html#example-cache-annotation-with-attributes" title="Exemple 21.7. @Cache annotation with attributes">Exemple 21.7, « @Cache annotation with attributes »</a>shows the<code class="literal"> @org.hibernate.annotations.Cache</code> annotations with its attributes. It allows you to define the caching strategy and region of a given second level cache.</p><div class="example"><a id="example-cache-annotation-with-attributes"/><p class="title"><b>Exemple 21.7. <code class="classname">@Cache</code> annotation with attributes</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">@Cache(
    CacheConcu<span xmlns="" class="co" id="cache-hm1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>rrencyStrategy usage();
    String reg<span xmlns="" class="co" id="cache-hm2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>ion() default "";
    String inc<span xmlns="" class="co" id="cache-hm3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>lude() default "all";
)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>usage: the given cache concurrency strategy (NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>region (optional): the cache region (default to the fqcn of the class or the fq role name of the collection)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code> (optional): all to include all properties, non-lazy to only include non lazy properties (default all).</p></td></tr></table></div></div></div></div><br class="example-break"/><p>Let's now take a look at Hibernate mapping files. There the <code class="literal">&lt;cache&gt;</code> element of a class or collection mapping is used to configure the second level cache. Looking at <a class="xref" href="performance.html#example-hibernate-cache-mapping-element" title="Exemple 21.8. The Hibernate &lt;cache&gt; mapping element">Exemple 21.8, « The Hibernate &lt;cache&gt; mapping element »</a> the parallels to anotations is obvious.</p><div class="example"><a id="example-hibernate-cache-mapping-element"/><p class="title"><b>Exemple 21.8. The Hibernate <code class="literal">&lt;cache&gt;</code> mapping element</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">&lt;cache
    usage="tra<span xmlns="" class="co" id="cache1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>nsactional|read-write|nonstrict-read-write|read-only"
    region="Re<span xmlns="" class="co" id="cache2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>gionName"
    include="a<span xmlns="" class="co" id="cache3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>ll|non-lazy"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">usage</code> (requis) spécifie la stratégie de cache : <code class="literal">transactionel</code>, <code class="literal">lecture-écriture</code>, <code class="literal">lecture-écriture non stricte</code> ou <code class="literal">lecture seule</code></p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">region</code> (optionnel, par défaut il s'agit du nom de la classe ou du nom de rôle de la collection) : spécifie le nom de la région du cache de second niveau</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code> (optionnel, par défaut <code class="literal">all</code>) <code class="literal">non-lazy</code> : spécifie que les propriétés des entités mappées avec <code class="literal">lazy="true"</code> ne doivent pas être mises en cache lorsque le chargement en différé des attributs est activé.</p></td></tr></table></div></div></div></div><br class="example-break"/><p>Alternatively to <code class="literal">&lt;cache&gt;</code>, you can use <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>.</p><p>Let's now have a closer look at the different usage strategies</p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>21.2.2. Stratégie : lecture seule</h3></div></div></div><p>Si votre application a besoin de lire mais ne modifie jamais les instances d'une classe, un cache <code class="literal">read-only</code> peut être utilisé. C'est la stratégie la plus simple et la plus performante. Elle est même parfaitement sûre dans un cluster. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>21.2.3. Stratégie : lecture/écriture</h3></div></div></div><p>Si l'application a besoin de mettre à jour des données, un cache <code class="literal">read-write</code> peut être approprié. Cette stratégie ne devrait jamais être utilisée si votre application nécessite un niveau d'isolation transactionnelle sérialisable. Si le cache est utilisé dans un environnement JTA, vous devez spécifier la propriété <code class="literal">hibernate.transaction.manager_lookup_class</code>, fournissant une stratégie pour obtenir le JTA <code class="literal">TransactionManager</code>. Dans d'autres environnements, vous devriez vous assurer que la transation est terminée à l'appel de <code class="literal">Session.close()</code> ou <code class="literal">Session.disconnect()</code>. Si vous souhaitez utiliser cette stratégie dans un cluster, vous devriez vous assurer que l'implémentation de cache utilisée supporte le verrouillage, ce que ne font <span class="emphasis"><em>pas</em></span> les pourvoyeurs caches fournis. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>21.2.4. Stratégie : lecture/écriture non stricte</h3></div></div></div><p>Si l'application a besoin de mettre à jour les données de manière occasionnelle (il est très peu probable que deux transactions essaient de mettre à jour le même élément simultanément) et si une isolation transactionnelle stricte n'est pas nécessaire, un cache <code class="literal">nonstrict-read-write</code> peut être approprié. Si le cache est utilisé dans un environnement JTA, vous devez spécifier <code class="literal">hibernate.transaction.manager_lookup_class</code>. Dans d'autres environnements, vous devriez vous assurer que la transation est terminée à l'appel de <code class="literal">Session.close()</code> ou <code class="literal">Session.disconnect()</code>.</p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>21.2.5. Stratégie : transactionelle</h3></div></div></div><p>La stratégie de cache <code class="literal">transactional</code> supporte un cache complètement transactionnel comme, par exemple, JBoss TreeCache. Un tel cache ne peut être utilisé que dans un environnement JTA et vous devez spécifier <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>21.2.6. Support de stratégie de concurrence du fournisseur-cache</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Aucun des caches livrés ne supporte toutes les stratégies de concurrence. Le tableau suivant montre quels caches sont compatibles avec quelles stratégies de concurrence. </p></div><p>Aucun des caches livrés ne supporte toutes les stratégies de concurrence. Le tableau suivant montre quels caches sont compatibles avec quelles stratégies de concurrence. </p><div class="table"><a id="d0e19322"/><p class="title"><b>Tableau 21.2. Support de stratégie de concurrence du cache</b></p><div class="table-contents"><table summary="Support de stratégie de concurrence du cache" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Table de hachage (ne pas utiliser en production)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>21.3. Gérer les caches</h2></div></div></div><p>A chaque fois que vous passez un objet à la méthode <code class="literal">save()</code>, <code class="literal">update()</code> ou <code class="literal">saveOrUpdate()</code> et à chaque fois que vous récupérez un objet avec <code class="literal">load()</code>, <code class="literal">get()</code>, <code class="literal">list()</code>, <code class="literal">iterate()</code> ou <code class="literal">scroll()</code>, cet objet est ajouté au cache interne de la <code class="literal">Session</code>. </p><p>Lorsqu'il y a un appel à la méthode <code class="literal">flush()</code>, l'état de cet objet va être synchronisé avec la base de données. Si vous ne voulez pas que cette synchronisation ait lieu ou si vous traitez un grand nombre d'objets et que vous avez besoin de gérer la mémoire de manière efficace, vous pouvez utiliser la méthode <code class="literal">evict()</code> pour supprimer l'objet et ses collections dépendantes du cache de premier niveau de la session. </p><div class="example"><a id="d0e19442"/><p class="title"><b>Exemple 21.9. Explcitly evicting a cached instance from the first level cache using <code class="methodname">Session.evict()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">ScrollableResult</span><!-- <br/> --><span class="java_plain">&nbsp;cats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Cat&nbsp;as&nbsp;cat&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">scroll</span><!-- <br/> --><span class="java_separator">();</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">a&nbsp;huge&nbsp;result&nbsp;set</span>
<!--  --><br/><span class="java_keyword">while</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;cat&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">0</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWithACat</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>La <code class="literal">Session</code> fournit également une méthode <code class="literal">contains()</code> pour déterminer si une instance appartient au cache de la session. </p><p>Pour retirer tous les objets du cache session, appelez <code class="literal">Session.clear()</code> </p><p>Pour le cache de second niveau, il existe des méthodes définies dans <code class="literal">SessionFactory</code> pour retirer du cache d'une instance, de la classe entière, d'une instance de collection ou du rôle entier d'une collection.</p><div class="example"><a id="d0e19467"/><p class="title"><b>Exemple 21.10. Second-level cache eviction via <code class="methodname">SessionFactoty.evict() </code>and <code class="methodname">SessionFacyory.evictCollection()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">evict</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catId</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;</span><span class="java_type">Cats</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;catId</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;collection&nbsp;of&nbsp;kittens</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;kitten&nbsp;collections</span></pre></div></div><br class="example-break"/><p>Le <code class="literal">CacheMode</code> contrôle la manière dont une session particulière interagit avec le cache de second niveau :</p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code> - lit et écrit les articles dans le cache de second niveau </p></li><li><p><code class="literal">CacheMode.GET</code> - lit les articles du cache de second niveau mais ne les écrit pas sauf dans le cas d'une mise à jour des données </p></li><li><p><code class="literal">CacheMode.PUT</code> - écrit les articles dans le cache de second niveau mais ne les lit pas dans le cache de second niveau </p></li><li><p><code class="literal">CacheMode.REFRESH</code> - écrit les articles dans le cache de second niveau mais ne les lit pas dans le cache de second niveau, outrepasse l'effet de <code class="literal">hibernate.cache.use_minimal_puts</code>, en forçant un rafraîchissement du cache de second niveau pour chaque article lu dans la base de données. </p></li></ul></div><p>Pour parcourir le contenu du cache de second niveau ou la région du cache dédiée aux requêtes, vous pouvez utiliser l'API <code class="literal">Statistics</code> :</p><div class="example"><a id="d0e19511"/><p class="title"><b>Exemple 21.11. Browsing the second-level cache entries via the <code class="classname">Statistics</code> API</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Map</span><!-- <br/> --><span class="java_plain">&nbsp;cacheEntries&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getSecondLevelCacheStatistics</span><span class="java_separator">(</span><span class="java_plain">regionName</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getEntries</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>Vous devez pour cela activer les statistiques et optionnellement forcer Hibernate à conserver les entrées dans le cache sous un format plus compréhensible pour l'utilisateur : </p><div class="example"><a id="d0e19521"/><p class="title"><b>Exemple 21.12. Enabling Hibernate statistics</b></p><div class="example-contents"><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div></div><br class="example-break"/></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>21.4. Le cache de requêtes</h2></div></div></div><p>Query result sets can also be cached. This is only useful for queries that are run frequently with the same parameters.</p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-enable"/>21.4.1. Enabling query caching</h3></div></div></div><p>Caching of query results introduces some overhead in terms of your applications normal transactional processing. For example, if you cache results of a query against Person Hibernate will need to keep track of when those results should be invalidated because changes have been committed against Person. That, coupled with the fact that most applications simply gain no benefit from caching query results, leads Hibernate to disable caching of query results by default. To use query caching, you will first need to enable the query cache:</p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>This setting creates two new cache regions: </p><div class="itemizedlist"><ul><li><p><code class="classname">org.hibernate.cache.StandardQueryCache</code>, holding the cached query results</p></li><li><p><code class="classname">org.hibernate.cache.UpdateTimestampsCache</code>, holding timestamps of the most recent updates to queryable tables. These are used to validate the results as they are served from the query cache.</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>If you configure your underlying cache implementation to use expiry or timeouts is very important that the cache timeout of the underlying cache region for the UpdateTimestampsCache be set to a higher value than the timeouts of any of the query caches. In fact, we recommend that the the UpdateTimestampsCache region not be configured for expiry at all. Note, in particular, that an LRU cache expiry policy is never appropriate.</p></div><p>As mentioned above, most queries do not benefit from caching or their results. So by default, individual queries are not cached even after enabling query caching. To enable results caching for a particular query, call <code class="literal">org.hibernate.Query.setCacheable(true)</code>. This call allows the query to look for existing cache results or add its results to the cache when it is executed.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The query cache does not cache the state of the actual entities in the cache; it caches only identifier values and results of value type. For this reaso, the query cache should always be used in conjunction with the second-level cache for those entities expected to be cached as part of a query result cache (just as with collection caching).</p></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-regions"/>21.4.2. Query cache regions</h3></div></div></div><p>Si vous avez besoin de contrôler finement les délais d'expiration du cache, vous pouvez spécifier une région de cache nommée pour une requête particulière en appelant <code class="literal">Query.setCacheRegion()</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">List</span><!-- <br/> --><span class="java_plain">&nbsp;blogs&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Blog&nbsp;blog&nbsp;where&nbsp;blog.blogger&nbsp;=&nbsp;:blogger&quot;</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setEntity</span><span class="java_separator">(</span><span class="java_literal">&quot;blogger&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;blogger</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_literal">15</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheable</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheRegion</span><span class="java_separator">(</span><span class="java_literal">&quot;frontpages&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>If you want to force the query cache to refresh one of its regions (disregard any cached results it finds there) you can use <code class="literal">org.hibernate.Query.setCacheMode(CacheMode.REFRESH)</code>. In conjunction with the region you have defined for the given query, Hibernate will selectively force the results cached in that particular region to be refreshed. This is particularly useful in cases where underlying data may have been updated via a separate process and is a far more efficient alternative to bulk eviction of the region via <code class="literal">org.hibernate.SessionFactory.evictQueries()</code>.</p></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>21.5. Comprendre les performances des collections</h2></div></div></div><p>Dans les sections précédentes, nous avons couvert les collections et leurs applications. Dans cette section, nous allons explorer de nouveaux problèmes en rapport aux collections en cours d'exécution.</p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>21.5.1. Taxinomie</h3></div></div></div><p>Hibernate définit trois types de collections de base :</p><div class="itemizedlist"><ul><li><p>les collections de valeurs</p></li><li><p>Association un-à-plusieurs </p></li><li><p>les associations plusieurs-à-plusieurs </p></li></ul></div><p>Cette classification distingue les différentes relations entre les tables et les clés étrangères mais ne n'en dit pas suffisamment sur le modèle relationnel. Pour comprendre parfaitement la structure relationnelle et les caractéristiques des performances, nous devons considérer la structure de la clé primaire qui est utilisée par Hibernate pour mettre à jour ou supprimer les lignes des collections. Cela nous amène aux classifications suivantes :</p><div class="itemizedlist"><ul><li><p>collections indexées</p></li><li><p>ensembles (sets)</p></li><li><p>sacs (bags)</p></li></ul></div><p>Toutes les collections indexées (maps, lists, arrays) ont une clé primaire constituée des colonnes clés (<code class="literal">&lt;key&gt;</code>) et <code class="literal">&lt;index&gt;</code>. Avec ce type de clé primaire, la mise à jour de collection est en général très performante - la clé primaire peut être indexées efficacement et une ligne particulière peut être localisée efficacement lorsque Hibernate essaie de la mettre à jour ou de la supprimer. </p><p>Les ensembles ont une clé primaire composée de <code class="literal">&lt;key&gt;</code> et des colonnes représentant l'élément. Elle est donc moins efficace pour certains types d'éléments de collection, en particulier les éléments composites, les textes volumineux ou les champs binaires ; la base de données peut ne pas être capable d'indexer aussi efficacement une clé primaire aussi complexe. Cependant, pour les associations un-à-plusieurs ou plusieurs-à-plusieurs, en particulier lorsqu'on utilise des entités ayant des identifiants techniques, il est probable que cela soit aussi efficace (note : si vous voulez que <code class="literal">SchemaExport</code> crée effectivement la clé primaire d'un <code class="literal">&lt;set&gt;</code> pour vous, vous devez déclarer toutes les colonnes avec <code class="literal">not-null="true"</code>). </p><p>Le mappage à l'aide de <code class="literal">&lt;idbag&gt;</code> définit une clé de substitution ce qui leur permet d'être très efficaces lors de la mise à jour. En fait il s'agit du meilleur cas de mise à jour d'une collection.</p><p>Le pire cas intervient pour les sacs. Dans la mesure où un sac permet la duplication des valeurs d'éléments et n'a pas de colonne d'index, aucune clé primaire ne peut être définie. Hibernate n'a aucun moyen de distinguer entre les  lignes dupliquées. Hibernate résout ce problème en supprimant complètement (via un simple <code class="literal">DELETE</code>), puis en recréant la collection chaque fois qu'elle change. Ce qui peut être très inefficace. </p><p>Notez que pour une relation un-à-plusieurs, la "clé primaire" peut ne pas être la clé primaire de la table en base de données - mais même dans ce cas, la classification ci-dessus reste utile (Elle explique comment Hibernate localise les lignes individuelles de la collection). </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>21.5.2. Les lists, les maps, les idbags et les ensembles sont les collections les plus efficaces pour la mise à jour </h3></div></div></div><p>La discussion précédente montre clairement que les collections indexées et (la plupart du temps) les ensembles, permettent de réaliser le plus efficacement les opérations d'ajout, de suppression ou mise à jour d'éléments. </p><p>Les collections indexées ont un avantage sur les ensembles, dans le cadre des associations plusieurs-à-plusieurs ou de collections de valeurs. À cause de la structure inhérente d'un <code class="literal">Set</code>, Hibernate n'effectue jamais de ligne <code class="literal">UPDATE</code> quand un élément est modifié. Les modifications apportées à un <code class="literal">Set</code> se font via un <code class="literal">INSERT</code> et <code class="literal">DELETE</code> (de chaque ligne). Une fois de plus, ce cas ne s'applique pas aux associations un-à-plusieurs. </p><p>Après s'être rappelé que les tableaux ne peuvent pas être chargés en différé, nous pouvons conclure que les lists, les maps et les idbags sont les types de collections (non inversées) les plus performants, avec les ensembles pas loin derrière. Les ensembles sont le type de collection le plus courant dans les applications Hibernate. Cela vient du fait que la sémantique des ensembles est la plus naturelle dans le modèle relationnel. </p><p>Cependant, dans des modèles objet bien conçus avec Hibernate, on constate que la plupart des collections sont en fait des associations un-à-plusieurs avec <code class="literal">inverse="true"</code>. Pour ces associations, les mises à jour sont gérées au niveau de l'association "plusieurs-à-un" et les considérations de performance de mise à jour des collections ne s'appliquent tout simplement pas dans ces cas-là. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>21.5.3. Les sacs et les listes sont les plus efficaces pour les collections inverses</h3></div></div></div><p>Avant que vous n'oubliez les sacs pour toujours, il y a un cas précis où les sacs (et les listes) sont bien plus performants que les ensembles. Pour une collection marquée comme <code class="literal">inverse="true"</code> (le choix le plus courant pour un relation un-à-plusieurs bidirectionnelle), nous pouvons ajouter des éléments à un sac ou une liste sans avoir besoin de l'initialiser (charger) les éléments du sac! Ceci parce que <code class="literal">Collection.add()</code> ou <code class="literal">Collection.addAll()</code> doit toujours retourner vrai pour un sac ou une <code class="literal">List</code> (contrairement au <code class="literal">Set</code>). Cela peut rendre le code suivant beaucoup plus rapide :</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">no&nbsp;need&nbsp;to&nbsp;fetch&nbsp;the&nbsp;collection</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">sess</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>21.5.4. Suppression en un coup</h3></div></div></div><p>Parfois, effacer les éléments d'une collection un par un peut être extrêmement inefficace. Hibernate n'est pas totalement stupide, il sait qu'il ne faut pas le faire dans le cas d'une collection complètement vidée (lorsque vous appelez <code class="literal">list.clear()</code>, par exemple). Dans ce cas, Hibernate fera un simple <code class="literal">DELETE</code> et le travail est fait ! </p><p>Supposons que nous ajoutions un élément unique dans une collection de taille vingt et que nous enlevions ensuite deux éléments. Hibernate effectuera un <code class="literal">INSERT</code> puis deux <code class="literal">DELETE</code> (à moins que la collection ne soit un sac). Cela est préférable. </p><p>Cependant, supposons que nous enlevions dix-huit éléments, laissant ainsi deux éléments, puis que nous ajoutions trois nouveaux éléments. Il y a deux moyens de procéder.</p><div class="itemizedlist"><ul><li><p>effacer dix-huit lignes une à une puis en insérer trois</p></li><li><p>effacer la totalité de la collection (en un SQL <code class="literal">DELETE</code>) puis insérer les cinq éléments restant (un à un) </p></li></ul></div><p>Hibernate n'est pas assez intelligent pour savoir que, dans ce cas, la seconde option est plus rapide (Il vaut mieux que Hibernate ne soit pas trop intelligent ; un tel comportement pourrait rendre l'utilisation de triggers de bases de données plutôt aléatoire, etc...). </p><p>Heureusement, vous pouvez forcer ce comportement (c'est-à-dire la deuxième stratégie) à tout moment en libérant (c'est-à-dire en déréférençant) la collection initiale et en retournant une collection nouvellement instanciée avec tous les éléments restants. </p><p>Bien sûr, la suppression en un coup ne s'applique pas pour les collections qui sont mappées avec <code class="literal">inverse="true"</code>. </p></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>21.6. Moniteur de performance</h2></div></div></div><p>L'optimisation n'est pas d'un grand intérêt sans le suivi et l'accès aux données de performance. Hibernate fournit toute une panoplie de rapport sur ses opérations internes. Les statistiques dans Hibernate sont fournies par <code class="literal">SessionFactory</code>.</p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>21.6.1. Suivi d'une SessionFactory</h3></div></div></div><p>Vous pouvez accéder aux métriques d'une <code class="literal">SessionFactory</code> de deux manières. La première option est d'appeler <code class="literal">sessionFactory.getStatistics()</code> et de lire ou d'afficher les <code class="literal">Statistics</code> vous-même.</p><p>Hibernate peut également utiliser JMX pour publier les métriques si vous activez le MBean <code class="literal">StatisticsService</code>. Vous pouvez activer un seul MBean pour toutes vos <code class="literal">SessionFactory</code> ou un par fabrique. Voici un code qui montre un exemple de configuration minimaliste : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;a&nbsp;specific&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;sessionFactory&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;myFinancialApp&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;tb</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;object&nbsp;name</span>
</span>
<!--  --><br/><span class="java_type">StatisticsService</span><span class="java_plain">&nbsp;stats&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StatisticsService</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">stats</span><span class="java_separator">.</span><span class="java_plain">setSessionFactory</span><span class="java_separator">(</span><span class="java_plain">sessionFactory</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Bind</span><span class="java_plain">&nbsp;the&nbsp;stats&nbsp;to&nbsp;a&nbsp;</span><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_plain">server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">stats</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Register</span><span class="java_plain">&nbsp;the&nbsp;</span><span class="java_type">Mbean</span><span class="java_plain">&nbsp;on&nbsp;the&nbsp;server</span></pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;all&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">'s</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;sessionFactory&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;all&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;tb</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;object&nbsp;name</span>
</span>
<!--  --><br/><span class="java_type">StatisticsService</span><span class="java_plain">&nbsp;stats&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StatisticsService</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">stats</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Register</span><span class="java_plain">&nbsp;the&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;on&nbsp;the&nbsp;server</span></pre><p>Vous pouvez (dés)activer le suivi pour une <code class="literal">SessionFactory</code> :</p><div class="itemizedlist"><ul><li><p>au moment de la configuration en mettant <code class="literal">hibernate.generate_statistics</code> à <code class="literal">false</code></p></li></ul></div><div class="itemizedlist"><ul><li><p>à chaud avec <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> ou <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code></p></li></ul></div><p>Les statistiques peuvent être remises à zéro de manière programmatique à l'aide de la méthode <code class="literal">clear()</code> Un résumé peut être envoyé à un logger (niveau info) à l'aide de la méthode <code class="literal">logSummary()</code>.</p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>21.6.2. Métriques</h3></div></div></div><p>Hibernate fournit plusieurs métriques, qui vont des informations très basiques aux informations très spécialisées qui ne sont appropriées que dans certains scénarios. Tous les compteurs accessibles sont décrits dans l'API de l'interface <code class="literal">Statistics</code> dans trois catégories : </p><div class="itemizedlist"><ul><li><p>Les métriques relatives à l'usage général de la <code class="literal">Session</code> comme le nombre de sessions ouvertes, le nombre de connexions JDBC récupérées, etc...</p></li><li><p>Les métriques relatives aux entités, collections, requêtes et caches dans leur ensemble (métriques globales aka).</p></li><li><p>Les métriques détaillées relatives à une entité, une collection, une requête ou une région de cache particulière.</p></li></ul></div><p>Par exemple, vous pouvez vérifier les hit, miss du cache ainsi que le taux d'éléments manquants et de mise à jour des entités, collections et requêtes et le temps moyen que met une requête. Il faut faire attention au fait que le nombre de millisecondes est sujet à approximation en Java. Hibernate est lié à la précision de la machine virtuelle, sur certaines plateformes, cela n'offre qu'une précision de l'ordre de 10 secondes. </p><p>Des accesseurs simples sont utilisés pour accéder aux métriques globales (c'est-à-dire, celles qui ne sont pas liées à une entité, collection ou région de cache particulière). Vous pouvez accéder aux métriques d'une entité, collection, région de cache particulière à l'aide de son nom et à l'aide de sa représentation HQL ou SQL pour une requête. Référez vous à la javadoc des APIS <code class="literal">Statistics</code>, <code class="literal">EntityStatistics</code>, <code class="literal">CollectionStatistics</code>, <code class="literal">SecondLevelCacheStatistics</code>, et <code class="literal">QueryStatistics</code> pour plus d'informations. Le code ci-dessous montre un exemple simple : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Statistics</span><!-- <br/> --><span class="java_plain">&nbsp;stats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">HibernateUtil</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheHitCount&nbsp;&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getQueryCacheHitCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheMissCount&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getQueryCacheMissCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheHitRatio&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;queryCacheHitCount&nbsp;</span><span class="java_operator">/</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">queryCacheHitCount&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;queryCacheMissCount</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">log</span><span class="java_separator">.</span><span class="java_plain">info</span><span class="java_separator">(</span><span class="java_literal">&quot;Query&nbsp;Hit&nbsp;ratio:&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;queryCacheHitRatio</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_type">EntityStatistics</span><span class="java_plain">&nbsp;entityStats&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getEntityStatistics</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">long</span><span class="java_plain">&nbsp;changes&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getInsertCount</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getUpdateCount</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getDeleteCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">log</span><span class="java_separator">.</span><span class="java_plain">info</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;&nbsp;changed&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;changes&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;times&quot;</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">);</span></pre><p>Pour travailler sur toutes les entités, collections, requêtes et régions de cache, vous pouvez récupérer la liste des noms des entités, collections, requêtes et régions de cache avec les méthodes suivantes : <code class="literal">getQueries()</code>, <code class="literal">getEntityNames()</code>, <code class="literal">getCollectionRoleNames()</code>, et <code class="literal">getSecondLevelCacheRegionNames()</code>. </p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>Précédent</strong>Chapitre 20. Mappage XML</a></li><li class="up"><a accesskey="u" href="#"><strong>Niveau supérieur</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Sommaire</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>Suivant</strong>Chapitre 22. Guide de la boîte à outils</a></li></ul></body></html>