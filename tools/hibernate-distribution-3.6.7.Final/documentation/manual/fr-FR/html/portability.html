<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapitre 28. Considérations de portabilité des bases de données</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="best-practices.html" title="Chapitre 27. Meilleures pratiques"/><link rel="next" href="bi01.html" title="References"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>Précédent</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>Suivant</strong></a></li></ul><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>Chapitre 28. Considérations de portabilité des bases de données</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="portability.html#portability-basics">28.1. Aspects fondamentaux de la portabilité</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialect">28.2. Dialecte</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialectresolver">28.3. Résolution de dialecte</a></span></dt><dt><span class="section"><a href="portability.html#portability-idgen">28.4. Générer les identifiants</a></span></dt><dt><span class="section"><a href="portability.html#portability-functions">28.5. Fonctions de base de données</a></span></dt><dt><span class="section"><a href="portability.html#portability-types">28.6. Type mappings</a></span></dt></dl></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>28.1. Aspects fondamentaux de la portabilité</h2></div></div></div><p>La portabilité des bases de données est un des atouts qui sont mis en avant pour vendre Hibernate (et plus largement le mappage objet/relationnel dans son ensemble). Il pourrait s'agir d'un utilisateur IT interne qui migre d'une base de données de fournisseur vers une autre, ou il pourrait s'agir d'un framework ou d'une application déployable consommant Hibernate pour cibler simultanément plusieurs produits de base de données par leurs utilisateurs. Quel que soit le scénario exact, l'idée de base est que vous souhaitez que HIBERNATE vous permettre d'exécuter avec un certain nombre de bases de données sans modifications à votre code et idéalement sans modifications des métadonnées de mappage. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>28.2. Dialecte</h2></div></div></div><p>La première ligne de la portabilité d'Hibernate est le dialecte, qui est une spécialisation du contrat <code class="classname">org.Hibernate.dialect.dialect</code>. Un dialecte encapsule toutes les différences selon lesquelles Hibernate doit communiquer avec une base de données particulière pour accomplir certaines tâches comme l'obtention d'une valeur de la séquence ou de structuration d'une requête SELECT. Hibernate regroupe un large éventail de dialectes pour la plupart des bases de données les plus communes. Si vous trouvez que votre base de données particulière n'en fait pas partie, il n'est pas difficile d'écrire votre propre dialecte. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>28.3. Résolution de dialecte</h2></div></div></div><p>À l'origine, Hibernate exigeait toujours que les utilisateurs spécifient quel dialecte utiliser. Dans le cas des utilisateurs qui cherchent à cibler simultanément plusieurs bases de données avec leur version, c'était problématique. Généralement cela amenait leurs utilisateurs à configurer le dialecte Hibernate ou à définir leur propre méthode de définition de cette valeur. </p><p>A partir de la version 3.2, Hibernate a introduit la détection automatiquement du dialecte à utiliser basé sur les <code class="interfacename">Java.SQL.DatabaseMetaData</code> obtenues à partir d'un <code class="interfacename">Java.SQL.Connexion</code> vers cette base de données. C'était beaucoup mieux, sauf que cette résolution a été limitée aux bases de données déjà connues d'Hibernate et elle n'était ni configurable, ni remplaçable. </p><p>Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Dialect</span><!-- <br/> --><span class="java_plain">&nbsp;resolveDialect</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">DatabaseMetaData</span><!-- <br/> --><span class="java_plain">&nbsp;metaData</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">throws</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">JDBCConnectionException</span></pre><p>The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver. </p><p>Le bon côté de ces outils de résolution, c'est que les utilisateurs peuvent également enregistrer leurs propres outils de résolution personnalisés, qui seront traités avant les résolveurs Hibernate intégrés. Cette option peut être utile dans un certain nombre de situations différentes : elle permet une intégration aisée pour la détection automatique des dialectes au-delà de ceux qui sont livrés avec Hibernate lui-même ; elle vous permet de spécifier d'utiliser un dialecte personnalisé lorsqu'une base de données particulière est reconnue ; etc.. Pour enregistrer un ou plusieurs outils de résolution, il vous suffit de les spécifier (séparés par des virgules, des onglets ou des espaces) à l'aide du paramètre de configuration 'hibernate.dialect_resolvers' (voir la constante <code class="constant">DIALECT_RESOLVERS</code> sur <code class="classname">cfg.Environment org.Hibernate.</code>). </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>28.4. Générer les identifiants</h2></div></div></div><p>When considering portability between databases, another important decision is selecting the identifier generation stratagy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy becauase the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entitiy be associated with the session (like via save() e.g.) regardless of current transactional semantics. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p> Hibernate was changed slightly once the implication of this was better understood so that the insert is delayed in cases where that is feasible. </p></div><p> The underlying issue is that the actual semanctics of the application itself changes in these cases. </p><p>Starting with version 3.2.3, Hibernate comes with a set of <a class="ulink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting portability in a much different way. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p> There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: </p><div class="itemizedlist"><ul><li><p> <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> </p></li><li><p> <code class="classname">org.hibernate.id.enhanced.TableGenerator</code> </p></li></ul></div><p> </p></div><p> The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>28.5. Fonctions de base de données</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Avertissement</h2><p>This is an area in Hibernate in need of improvement. In terms of portability concerns, this function handling currently works pretty well from HQL; however, it is quite lacking in all other aspects. </p></div><p>SQL functions can be referenced in many ways by users. However, not all databases support the same set of functions. Hibernate, provides a means of mapping a <span class="emphasis"><em>logical</em></span> function name to a delegate which knows how to render that particular function, perhaps even using a totally different physical function call. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Techniquement, cet enregistrement de la fonction est géré par le biais de la classe <code class="classname">hibernate.dialect.function.SQLFunctionRegistry org.</code> qui est destinée à permettre aux utilisateurs de fournir des définitions de fonction personnalisée sans avoir à fournir un dialecte personnalisé. Ce comportement spécifique n'est pas encore entièrement terminé. </p><p>Il est mis en oeuvre de telle sorte que les utilisateurs peuvent enregistrer des fonctions par programmation avec <code class="classname">org.Hibernate.cfg.Configuration</code> et ces fonctions seront reconnues pour HQL. </p></div><p>
        </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>28.6. Type mappings</h2></div></div></div><p>This section scheduled for completion at a later date... </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>Précédent</strong>Chapitre 27. Meilleures pratiques</a></li><li class="up"><a accesskey="u" href="#"><strong>Niveau supérieur</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Sommaire</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>Suivant</strong>References</a></li></ul></body></html>