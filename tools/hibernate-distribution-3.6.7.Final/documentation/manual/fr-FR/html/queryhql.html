<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapitre 16. HQL : langage d'interrogation d'Hibernate</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="batch.html" title="Chapitre 15. Traitement par lot"/><link rel="next" href="querycriteria.html" title="Chapitre 17. Requêtes par critères"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>Précédent</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>Suivant</strong></a></li></ul><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>Chapitre 16. HQL : langage d'interrogation d'Hibernate</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="queryhql.html#queryhql-casesensitivity">16.1. Sensibilité à la casse</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-from">16.2. La clause from</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins">16.3. Associations et jointures</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins-forms">16.4. Formes de syntaxes pour les jointures</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-identifier-property">16.5. Faire référence à la propriété identifiant </a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-select">16.6. La clause select</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-aggregation">16.7. Fonctions d'agrégation</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-polymorphism">16.8. Requêtes polymorphiques</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-where">16.9. La clause where</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-expressions">16.10. Expressions</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-ordering">16.11. La clause order by</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-grouping">16.12. La clause group by</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-subqueries">16.13. Sous-requêtes</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-examples">16.14. Exemples HQL</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-bulk">16.15. Nombreuses mises à jour et suppressions </a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tipstricks">16.16. Trucs &amp; Astuces</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-components">16.17. Composants</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tuple">16.18. Syntaxe des constructeurs de valeur de ligne</a></span></dt></dl></div><p>Hibernate fournit un langage d'interrogation extrêmement puissant qui ressemble (et c'est voulu) au SQL. Mais ne soyez pas dupe de la syntaxe ; HQL est totalement orienté objet, cernant des notions comme l'héritage, le polymorphisme et les associations.  </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>16.1. Sensibilité à la casse</h2></div></div></div><p>Les requêtes sont insensibles à la casse, à l'exception des noms de classes Java et des propriétés. Ainsi, <code class="literal">SeLeCT</code> est identique à <code class="literal">sELEct</code> et à <code class="literal">SELECT</code> mais <code class="literal">net.sf.hibernate.eg.FOO</code> n'est pas identique <code class="literal">net.sf.hibernate.eg.Foo</code> et <code class="literal">foo.barSet</code> n'est pas identique à <code class="literal">foo.BARSET</code>.  </p><p>Ce guide utilise les mots clés HQL en minuscules. Certains utilisateurs trouvent les requêtes écrites avec les mots clés en majuscules plus lisibles, mais nous trouvons cette convention pénible lorsqu'elle est lue dans du code Java.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>16.2. La clause from</h2></div></div></div><p>La requête Hibernate la plus simple est de la forme : </p><pre class="programlisting">from eg.Cat</pre><p>Retourne toutes les instances de la classe <code class="literal">eg.Cat</code>. Nous n'avons pas besoin de qualifier le nom de la classe, puisque <code class="literal">auto-import</code> est la valeur par défaut. Donc nous écrivons presque toujours : </p><pre class="programlisting">from Cat</pre><p>Pour pouvoir nous référer à <code class="literal">Cat</code> dans des autres parties de la requête, vous aurez besoin d'y assigner un <span class="emphasis"><em>alias</em></span>. Ainsi : </p><pre class="programlisting">from Cat as cat</pre><p>Cette requête assigne l'alias <code class="literal">cat</code> à l'instance <code class="literal">Cat</code>, nous pouvons donc utiliser cet alias ailleurs dans la requête. Le mot clé <code class="literal">as</code> est optionnel. Nous aurions pu écrire : </p><pre class="programlisting">from Cat cat</pre><p>Plusieurs classes peuvent apparaître, ce qui conduira à un produit cartésien (encore appelé jointures croisées).  </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>C'est une bonne pratique que de nommer les alias dans les requêtes en utilisant l'initiale en miniscule, ce qui correspond aux standards de nommage Java pour les variables locales (par ex. <code class="literal">domesticCat</code>). </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>16.3. Associations et jointures</h2></div></div></div><p>On peut aussi assigner des alias à des entités associées, ou même aux éléments d'une collection de valeurs, en utilisant un <code class="literal">join</code> (jointure). Par exemple : </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>Les types de jointures supportées sont empruntées de ANSI SQL : </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">inner join</code>
                </p></li><li><p>
                    <code class="literal">left outer join</code>
                </p></li><li><p>
                    <code class="literal">right outer join</code>
                </p></li><li><p><code class="literal">full join</code> (jointure ouverte totalement - généralement inutile) </p></li></ul></div><p>Les constructions des jointures <code class="literal">inner join</code>, <code class="literal">left outer join</code> et <code class="literal">right outer join</code> peuvent être abrégées. </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>Nous pouvons soumettre des conditions de jointure supplémentaires en utilisant le mot-clef HQL <code class="literal">with</code>. </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight 
&gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a class="xref" href="performance.html#performance-fetching" title="21.1. Stratégies de chargement">Section 21.1, « Stratégies de chargement »</a> for more information. </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>Une jointure "fetch" (rapportée) n'a généralement pas besoin de se voir assigner un alias puisque les objets associés ne doivent pas être utilisés dans la clause <code class="literal">where</code> ou toute autre clause. Notez aussi que les objets associés ne sont pas retournés directement dans le résultat de la requête mais l'on peut y accéder via l'objet parent. La seule raison pour laquelle nous pourrions avoir besoin d'un alias est si nous récupérons récursivement une collection supplémentaire : </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>Notez que la construction de <code class="literal">fetch</code> ne peut pas être utilisée dans les requêtes appelées par <code class="literal">scroll()</code> ou <code class="literal">iterate()</code>. De même <code class="literal">Fetch</code> ne devrait pas être utilisé avec <code class="literal">setMaxResults()</code> ou <code class="literal">setFirstResult()</code>, ces opérations étant basées sur le nombre de résultats contenant généralement des doublons dès que des collections sont chargées agressivement, par conséquent le nombre de lignes est imprévisible. <code class="literal">Fetch</code> ne peut pas non plus être utilisé avec une condition <code class="literal">with</code> ad hoc. Il est possible de créer un produit cartésien par jointure en récupérant plus d'une collection dans une requête, donc faites attention dans ce cas. Récupérer par jointure de multiples collections donne aussi parfois des résultats inattendus pour des mappages de sac, donc soyez prudent lorsque vous formulez vos requêtes dans de tels cas. Finalement, notez que <code class="literal">full join fetch</code> et <code class="literal">right join fetch</code> ne sont pas utiles en général. </p><p>Si vous utilisez un chargement retardé pour les propriétés (avec une instrumentation par bytecode), il est possible de forcer Hibernate à récupérer les propriétés non encore chargées immédiatement (dans la première requête) en utilisant <code class="literal">fetch all properties</code>.  </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>16.4. Formes de syntaxes pour les jointures</h2></div></div></div><p>HQL supporte deux formes pour joindre les associations : <code class="literal">implicit</code> et <code class="literal">explicit</code>. </p><p>Les requêtes présentes dans la section précédente utilisent la forme <code class="literal">explicit</code> où le mot clé join est explicitement utilisé dans la clause from. C'est la forme recommandée.  </p><p>La forme <code class="literal">implicit</code> n'utilise pas le mot clé join. En revanche, les associations sont "déréférencées" en utilisant la notation. Ces jointures <code class="literal">implicit</code> peuvent apparaître dans toutes les clauses HQL. Les jointures <code class="literal">implicit</code> résultent en des jointures internes dans le SQL généré. </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>16.5. Faire référence à la propriété identifiant </h2></div></div></div><p>Il y a en général deux façons de faire référence à une propriété d'identifiant d'une entité : </p><div class="itemizedlist"><ul compact="compact"><li><p>La propriété particulière (minuscule) <code class="literal">id</code> peut être utilisée pour référencer la propriété d'identifiant d'une entité <span class="emphasis"><em>du moment que l'entité ne définisse pas une propriété de non-identifiant appelée id</em></span>. </p></li><li><p>Si l'identité définit une propriété d'identifiant nommée, vous pouvez utiliser ce nom de propriété. </p></li></ul></div><p>Les références aux propriétés d'identifiant composites suivent les mêmes règles de nommage. Si l'entité a une propriété de non-identifiant appelée id, la propriété d'identifiant composite ne peut être référencée que par son nom défini ; sinon la propriété spéciale <code class="literal">id</code> peut être utilisée pour référencer la propriété d'identifiant.  </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Note : cela a changé de façon significative depuis la version 3.2.2. Dans les versions précédentes, <code class="literal">id</code> référait <span class="emphasis"><em>toujours</em></span> à la propriété identifiant quel que soit son nom réel. Une des conséquences de cette décision fut que les propriétés de non-identifiant appelées <code class="literal">id</code> ne pouvaient jamais être référencées dans les requêtes Hibernate. </p></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>16.6. La clause select</h2></div></div></div><p>La clause <code class="literal">select</code> sélectionne les objets et propriétés qui doivent être retournés dans le résultat de la requête. Soit :  </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>La requête recherchera les <code class="literal">mate</code> s liés aux <code class="literal">Cat</code> s. Vous pouvez exprimer cette requête de manière plus compacte :  </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>Les requêtes peuvent retourner des propriétés de n'importe quel type de valeur, même celles de type composant :  </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>Les requêtes peuvent retourner de multiples objets et/ou propriétés sous la forme d'un tableau du type <code class="literal">Object[]</code> : </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Ou sous la forme d'une <code class="literal">List</code> : </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Ou bien - à condition que la classe <code class="literal">Family</code> possède le constructeur approprié - en tant qu'objet typesafe Java : </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>Vous pouvez assigner des alias aux expressions sélectionnées en utilisant <code class="literal">as</code> :  </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>C'est surtout utile lorsque c'est utilisé avec <code class="literal">select new map</code> : </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>Cette requête retourne une <code class="literal">Map</code> à partir des alias vers les valeurs sélectionnées. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>16.7. Fonctions d'agrégation</h2></div></div></div><p>Les requêtes HQL peuvent aussi retourner les résultats de fonctions d'agrégation sur les propriétés :  </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>Les fonctions d'agrégation supportées sont : </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>Vous pouvez utiliser des opérateurs arithmétiques, la concaténation, et des fonctions SQL reconnues dans la clause select :  </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>Les mots clé <code class="literal">distinct</code> et <code class="literal">all</code> peuvent être utilisés et ont la même sémantique qu'en SQL.  </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>16.8. Requêtes polymorphiques</h2></div></div></div><p>Une requête comme : </p><pre class="programlisting">from Cat as cat</pre><p>retourne non seulement les instances de <code class="literal">Cat</code>, mais aussi celles des sous classes comme <code class="literal">DomesticCat</code>. Les requêtes Hibernate peuvent nommer n'importe quelle classe ou interface Java dans la clause <code class="literal">from</code>. La requête retournera les instances de toutes les classes persistantes qui étendent cette classe ou implémente cette interface. La requête suivante retournera tous les objets persistants :  </p><pre class="programlisting">from java.lang.Object o</pre><p>L'interface <code class="literal">Named</code> peut être implémentée par plusieurs classes persistantes : </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>Notez que ces deux dernières requêtes nécessitent plus d'un SQL <code class="literal">SELECT</code>. Ce qui signifie que la clause <code class="literal">order by</code> ne trie pas correctement la totalité des résultats (cela signifie aussi que vous ne pouvez exécuter ces requêtes en appelant <code class="literal">Query.scroll()</code>).  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>16.9. La clause where</h2></div></div></div><p>La clause <code class="literal">where</code> vous permet de réduire la liste des instances retournées. Si aucun alias n'existe, vous pouvez vous référer aux propriétés par leur nom :  </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>S'il y a un alias, utilisez un nom de propriété qualifié : </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>Retourne les instances de <code class="literal">Cat</code> appelé  'Fritz'. </p><p>La requête suivante : </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p>retournera les instances de <code class="literal">Foo</code> pour lesquelles il existe une instance de <code class="literal">bar</code> avec la propriété <code class="literal">date</code> égale à la propriété <code class="literal">startDate</code> de <code class="literal">Foo</code>. Les expressions de chemin composées rendent la clause <code class="literal">where</code> extrêmement puissante. Soit :  </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>Cette requête se traduit en une requête SQL par une jointure interne de table. Si vous souhaitez écrire quelque chose comme : </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>vous finiriez avec une requête qui nécessiterait quatre jointures de table en SQL.  </p><p>L'opérateur <code class="literal">=</code> peut être utilisé pour comparer aussi bien des propriétés que des instances :  </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. Faire référence à la propriété identifiant">Section 16.5, « Faire référence à la propriété identifiant  »</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>La seconde requête est particulièrement efficace. Aucune jointure n'est nécessaire !  </p><p>Les propriétés d'identifiants composites peuvent aussi être utilisées. Supposez que <code class="literal">Person</code> ait un identifiant composite composé de  <code class="literal">country</code> et <code class="literal">medicareNumber</code>.  </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>Une fois de plus, la seconde requête ne nécessite pas de jointure de table.  </p><p>See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. Faire référence à la propriété identifiant">Section 16.5, « Faire référence à la propriété identifiant  »</a> for more information regarding referencing identifier properties) </p><p>De même, la propriété spéciale <code class="literal">class</code> accède à la valeur discriminante d'une instance dans le cas d'une persistance polymorphique. Le nom d'une classe Java incorporée dans la clause where sera traduite par sa valeur discriminante.  </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a class="xref" href="queryhql.html#queryhql-components" title="16.17. Composants">Section 16.17, « Composants »</a> for more information. </p><p>Un type "any" possède les propriétés particulières <code class="literal">id</code> et <code class="literal">class</code>, qui nous permettent d'exprimer une jointure de la manière suivante (là où <code class="literal">AuditLog.item</code> est une propriété mappée avec <code class="literal">&lt;any&gt;</code>) : </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>Dans la requête précédente, notez que <code class="literal">log.item.class</code> et <code class="literal">payment.class</code> feraient référence à des valeurs de colonnes de la base de données complètement différentes.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>16.10. Expressions</h2></div></div></div><p>Les expressions permises dans la clause <code class="literal">where</code> incluent : </p><div class="itemizedlist"><ul compact="compact"><li><p>opérateurs mathématiques : <code class="literal">+, -, *, /</code>  </p></li><li><p>opérateurs de comparaison binaire : <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code> </p></li><li><p>opérations logiques : <code class="literal">and, or, not</code> </p></li><li><p>Parenthèses <code class="literal">( )</code>, indiquant un regroupement  </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> et <code class="literal">not member of</code> </p></li><li><p>Cas simple <code class="literal">case ... when ... then ... else ... end</code>, et cas "searched", <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>concaténation de chaîne de caractères <code class="literal">...||...</code> ou <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code>, and <code class="literal">current_timestamp()</code> </p></li><li><p><code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code>, <code class="literal">year(...)</code>, </p></li><li><p>N'importe quelle fonction ou opérateur défini par EJB-QL 3.0 : <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</code> </p></li><li><p><code class="literal">coalesce()</code> et <code class="literal">nullif()</code> </p></li><li><p><code class="literal">str()</code> pour convertir des valeurs numériques ou temporelles vers une chaîne de caractères lisible </p></li><li><p><code class="literal">cast(... as ...)</code>, où le second argument est le nom d'un type Hibernate, et <code class="literal">extract(... from ...)</code> si le <code class="literal">cast()</code> ANSI et <code class="literal">extract()</code> sont supportés par la base de données sous-jacente </p></li><li><p>La fonction HQL <code class="literal">index()</code>, qui s'applique aux alias d'une collection indexée jointe </p></li><li><p>Les fonctions HQL qui prennent des expressions de chemin représentant des collections : <code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>, ainsi que les fonctions particulières <code class="literal">elements()</code> et <code class="literal">indices</code> qui peuvent être quantifiées en utilisant <code class="literal">some, all, exists, any, in</code>.  </p></li><li><p>N'importe quelle fonction scalaire SQL supportée par la base de données comme <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code>, et <code class="literal">sin()</code> </p></li><li><p>Les paramètres de position de JDBC <code class="literal">?</code> </p></li><li><p>paramètres nommés <code class="literal">:name</code>, <code class="literal">:start_date</code>, et <code class="literal">:x1</code> </p></li><li><p>SQL textuel <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">6.66E+2</code>, <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>Constantes Java <code class="literal">public static final</code><code class="literal">eg.Color.TABBY</code> </p></li></ul></div><p><code class="literal">in</code> et <code class="literal">between</code> peuvent être utilisés comme suit :  </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>Les formes négatives peuvent être écrites ainsi : </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>De même, <code class="literal">is null</code> et <code class="literal">is not null</code> peuvent être utilisés pour tester les valeurs nulles. </p><p>Les booléens peuvent être facilement utilisés en déclarant les substitutions de requêtes HQL dans la configuration Hibernate :  </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"
&gt;true 1, false 0&lt;/property
&gt;</pre><p>Ce qui remplacera les mots clés <code class="literal">true</code> et <code class="literal">false</code> par <code class="literal">1</code> et <code class="literal">0</code> dans la traduction SQL du HQL suivant : </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>Vous pouvez tester la taille d'une collection par la propriété particulière  <code class="literal">size</code>, ou la fonction spéciale <code class="literal">size()</code>.  </p><pre class="programlisting">from Cat cat where cat.kittens.size 
&gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) 
&gt; 0</pre><p>Pour les collections indexées, vous pouvez faire référence aux indices minimum et maximum en utilisant les fonctions <code class="literal">minindex</code> et <code class="literal">maxindex</code>. De manière similaire, vous pouvez faire référence aux éléments minimum et maximum d'une collection de type basique en utilisant les fonctions <code class="literal">minelement</code> et <code class="literal">maxelement</code>. Par exemple :  </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) 
&gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) 
&gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) 
&gt; 10000</pre><p>Les fonctions SQL <code class="literal">any, some, all, exists, in</code> sont supportées quand l'élément ou l'ensemble des indexes d'une collection (les fonctions <code class="literal">elements</code> et <code class="literal">indices</code>) ou le résultat d'une sous requête sont passés (voir ci dessous) : </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 
&gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>Notez que l'écriture de - <code class="literal">size</code>, <code class="literal">elements</code>, <code class="literal">indices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>, <code class="literal">minelement</code>, <code class="literal">maxelement</code> - peut seulement être utilisée dans la clause where dans Hibernate3.  </p><p>Les éléments de collections indexées (arrays, lists, maps) peuvent être référencés via index dans une clause where seulement : </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>L'expression entre <code class="literal">[]</code> peut même être une expression arithmétique : </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>HQL propose aussi une fonction <code class="literal">index()</code> interne, pour les éléments d'une association un-à-plusieurs ou d'une collection de valeurs. </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>Les fonctions SQL scalaires supportées par la base de données utilisée peuvent être utilisées : </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>Si vous n'êtes pas encore convaincu par tout cela, imaginez la taille et l'illisibilité qui caractériseraient la requête suivante en SQL : </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>Un indice :</em></span> cela donne quelque chose comme </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>16.11. La clause order by</h2></div></div></div><p>La liste retournée par la requête peut être triée par n'importe quelle propriété de la classe ou des composants retournés :  </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>Le mot optionnel <code class="literal">asc</code> ou <code class="literal">desc</code> indique respectivement si le tri doit être croissant ou décroissant. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>16.12. La clause group by</h2></div></div></div><p>Si la requête retourne des valeurs agrégées, celles-ci peuvent être groupées par propriété d'une classe retournée ou par des composants :  </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p>Une clause <code class="literal">having</code> est aussi permise. </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>Les fonctions SQL et les fonctions d'agrégat sont permises dans les clauses <code class="literal">having</code> et <code class="literal">order by</code>, si elles sont prises en charge par la base de données sous-jacente (ce que ne fait pas MySQL par exemple).  </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.name, cat.other, cat.properties
having avg(kitten.weight) 
&gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>Notez que ni la clause <code class="literal">group by</code> ni la clause <code class="literal">order by</code> ne peuvent contenir d'expressions arithmétiques. Notez aussi qu'Hibernate ne développe pas actuellement une entité faisant partie du regroupement, donc vous ne pouvez pas écrire <code class="literal">group by cat</code> si toutes les propriétés de <code class="literal">cat</code> sont non-agrégées. Vous devez lister toutes les propriétés non-agrégées explicitement. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>16.13. Sous-requêtes</h2></div></div></div><p>Pour les bases de données supportant les sous-selects, Hibernate supporte les sous requêtes dans les requêtes. Une sous-requête doit être entre parenthèses (souvent pour un appel à une fonction d'agrégation SQL). Même les sous-requêtes corrélées (celles qui font référence à un alias de la requête principale) sont supportées. </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight 
&gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>Notez que les sous-requêtes HQL peuvent survenir uniquement dans les clauses select ou where.  </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a class="xref" href="queryhql.html#queryhql-tuple" title="16.18. Syntaxe des constructeurs de valeur de ligne">Section 16.18, « Syntaxe des constructeurs de valeur de ligne »</a> for more information. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>16.14. Exemples HQL</h2></div></div></div><p>Les requêtes Hibernate peuvent être relativement puissantes et complexes. En fait, la puissance du langage d'interrogation est l'un des arguments principaux de vente de Hibernate. Voici quelques exemples très similaires aux requêtes que nous avons utilisées lors d'un récent projet. Notez que la plupart des requêtes que vous écrirez seront plus simples que les exemples qui suivent. </p><p>La requête suivante retourne l'id de commande, le nombre d'articles et la valeur totale de la commande pour toutes les commandes non payées d'un client particulier pour une valeur totale minimum donnée, ces résultats étant triés par la valeur totale. La requête SQL générée sur les tables <code class="literal">ORDER</code>, <code class="literal">ORDER_LINE</code>, <code class="literal">PRODUCT</code>, <code class="literal">CATALOG</code> et <code class="literal">PRICE</code> est composée de quatre jointures internes ainsi que d'un sous-select (non corrélé). </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate 
&gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>Quel monstre ! En principe, dans des situations réelles, nous n'approuvons pas les sous-requêtes, notre requête ressemblait donc plutôt à ce qui suit : </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>La requête suivante compte le nombre de paiements pour chaque statut, en excluant tout paiement dans le statut <code class="literal">AWAITING_APPROVAL</code> où le changement de statut le plus récent à été fait par l'utilisateur courant. En SQL, cette requête effectue deux jointures internes et un sous-select corrélé sur les tables <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code> et <code class="literal">PAYMENT_STATUS_CHANGE</code>. </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;
&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>Si nous avions mappé la collection <code class="literal">statusChanges</code> comme une liste, au lieu d'un ensemble, la requête aurait été plus facile à écrire.  </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;
&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>La prochaine requête utilise la fonction de serveur MS SQL <code class="literal">isNull()</code> pour retourner tous les comptes et paiements impayés pour l'organisation à laquelle l'utilisateur courant appartient. Elle est traduite en SQL par trois jointures internes, une jointure externe ainsi qu'un sous-select sur les tables <code class="literal">ACCOUNT</code>, <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">ACCOUNT_TYPE</code>, <code class="literal">ORGANIZATION</code> et <code class="literal">ORG_USER</code>. </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>Pour certaines bases de données, nous devons éliminer le sous-select (corrélé). </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>16.15. Nombreuses mises à jour et suppressions </h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a class="xref" href="batch.html#batch-direct" title="15.4. Opérations de style DML">Section 15.4, « Opérations de style DML »</a> for more information. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>16.16. Trucs &amp; Astuces</h2></div></div></div><p>Vous pouvez compter le nombre de résultats d'une requête sans les retourner :  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p>Pour trier les résultats par la taille d'une collection, utilisez la requête suivante : </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>Si votre base de données supporte les sous-selects, vous pouvez placer des conditions sur la taille de la sélection dans la clause where de votre requête : </p><pre class="programlisting">from User usr where size(usr.messages) 
&gt;= 1</pre><p>Si votre base de données ne supporte pas les sous-selects, utilisez la requête suivante :  </p><pre class="programlisting">select usr.id, usr.name
from User usr
    join usr.messages msg
group by usr.id, usr.name
having count(msg) 
&gt;= 1</pre><p>Cette solution ne peut pas retourner un <code class="literal">User</code> avec zéro message à cause de la jointure interne, la forme suivante peut donc être utile :  </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>Les propriétés d'un JavaBean peuvent être injectées dans les paramètres nommés d'une requête : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;foo&nbsp;Foo&nbsp;as&nbsp;foo&nbsp;where&nbsp;foo.name=:name&nbsp;and&nbsp;foo.size=:size&quot;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setProperties</span><span class="java_separator">(</span><span class="java_plain">fooBean</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;fooBean&nbsp;has&nbsp;getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;and&nbsp;getSize</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;foos&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>Les collections sont paginables via l'utilisation de l'interface <code class="literal">Query</code> avec un filtre : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;the&nbsp;trivial&nbsp;filter</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setFirstResult</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE&nbsp;</span><span class="java_operator">*</span><span class="java_plain">&nbsp;pageNumber</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;page&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>Les éléments d'une collection peuvent être triés ou groupés en utilisant un filtre de requête :  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Collection</span><!-- <br/> --><span class="java_plain">&nbsp;orderedCollection&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">filter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;order&nbsp;by&nbsp;this.amount&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Collection</span><span class="java_plain">&nbsp;counts&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">filter</span><span class="java_separator">(</span><span class="java_plain">&nbsp;collection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;select&nbsp;this.type,&nbsp;count(this)&nbsp;group&nbsp;by&nbsp;this.type&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span></pre><p>Vous pouvez récupérer la taille d'une collection sans l'initialiser : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>16.17. Composants</h2></div></div></div><p>Les composants peuvent être utilisés dans presque tous les cas comme les types de valeur dans les requêtes HQL. Ils peuvent apparaître dans la clause <code class="literal">select</code> comme ce qui suit : </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>où la propriété de nom de Person est un composant. Des composants peuvent aussi être utilisés dans la clause <code class="literal">where</code> : </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>Des composants peuvent être utilisés dans la clause <code class="literal">order by</code> : </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>Another common use of components is in <a class="link" href="queryhql.html#queryhql-tuple" title="16.18. Syntaxe des constructeurs de valeur de ligne">row value constructors</a>. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>16.18. Syntaxe des constructeurs de valeur de ligne</h2></div></div></div><p>HQL supporte l'utilisation de la syntaxe <code class="literal">row value constructor</code> SQL ANSI (aussi appelée syntaxe <code class="literal">tuple</code>), bien que la base de données sous-jacente ne supporte pas nécessairement cette notion. Là, nous faisons généralement référence à des comparaisons multi-valuées, typiquement associées à des composants. Considérez une entité Person qui définit un composant de nom : </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>Voici une syntaxe valide, bien que quelque peu fastidieuse. Pour la rendre plus concise, utilisez la syntaxe <code class="literal">row value constructor</code> : </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p>Il est utile de spécifier cela dans la clause <code class="literal">select</code> : </p><pre class="programlisting">select p.name from Person p</pre><p>Alternativement, utiliser la syntaxe <code class="literal">row value constructor</code> peut être avantageux quand vous utilisez des sous-requêtes nécessitant une comparaison avec des valeurs multiples :  </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>Si vous décidez d'utiliser cette syntaxe, il vous faudra prendre en considération le fait que la requête sera dépendante de la commande des sous-propriétés du composant dans les métadonnées.  </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>Précédent</strong>Chapitre 15. Traitement par lot</a></li><li class="up"><a accesskey="u" href="#"><strong>Niveau supérieur</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Sommaire</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>Suivant</strong>Chapitre 17. Requêtes par critères</a></li></ul></body></html>