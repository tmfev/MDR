<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapitre 13. Transactions et Accès concurrents</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="readonly.html" title="Chapitre 12. Read-only entities"/><link rel="next" href="events.html" title="Chapitre 14. Intercepteurs et événements"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>Précédent</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>Suivant</strong></a></li></ul><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>Chapitre 13. Transactions et Accès concurrents</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="transactions.html#transactions-basics">13.1. Portées des sessions et des transactions</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-basics-uow">13.1.1. Unité de travail</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-apptx">13.1.2. Longue conversation</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-identity">13.1.3. L'identité des objets</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-issues">13.1.4. Problèmes communs</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-demarcation">13.2. Démarcation des transactions de base de données</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-demarcation-nonmanaged">13.2.1. Environnement non gérés</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-jta">13.2.2. Utilisation de JTA</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-exceptions">13.2.3. Gestion des exceptions</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-timeout">13.2.4. Timeout de transaction</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-optimistic">13.3. Contrôle de concurrence optimiste</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-optimistic-manual">13.3.1. Vérification du versionnage au niveau applicatif</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-longsession">13.3.2. Les sessions longues et le versionnage automatique.</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-detached">13.3.3. Les objets détachés et le versionnage automatique</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-customizing">13.3.4. Personnaliser le versionnage automatique</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-locking">13.4. Verrouillage pessimiste </a></span></dt><dt><span class="section"><a href="transactions.html#transactions-connection-release">13.5. Modes de libération de connexion</a></span></dt></dl></div><p>L'un des principaux avantages du mécanisme de contrôle des accès concurrents de Hibernate est qu'il est très facile à comprendre. Hibernate utilise directement les connexions JDBC ainsi que les ressources JTA sans y ajouter davantage de mécanisme de blocage. Nous vous recommandons de vous familiariser avec les spécifications JDBC, ANSI et d'isolement de transaction du système de gestion de la base de données que vous utilisez.  </p><p>Hibernate ne verrouille pas vos objets en mémoire. Votre application peut suivre le comportement défini par le niveau d'isolation de vos transactions de base de données. Notez que grâce à la <code class="literal">Session</code>, qui est aussi un cache de portée de transaction, Hibernate fournit des lectures répétées pour les recherches par identifiants et les requêtes d'entités (ne rapporte pas les requêtes qui retournent des valeurs scalaires).  </p><p>En plus du versioning, pour le contrôle automatique optimiste de concurrence, Hibernate fournit également une API (mineure) pour le verrouillage pessimiste des lignes, en générant une syntaxe <code class="literal">SELECT FOR UPDATE</code>. Le contrôle de concurrence optimiste et cette API seront approfondis ultérieurement dans ce chapitre.  </p><p>Nous abordons la gestion des accès concurrents en discutant de la granularité des objets <code class="literal">Configuration</code>, <code class="literal">SessionFactory</code>, et <code class="literal">Session</code>, ainsi que des transactions de la base de données et des longues transactions applicatives.  </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>13.1. Portées des sessions et des transactions</h2></div></div></div><p>Il est important de savoir qu'un objet <code class="literal">SessionFactory</code> est un objet complexe et optimisé pour fonctionner avec les threads(thread- safe). Il est coûteux à créer et est ainsi prévu pour n'être instancié qu'une seule fois via une instance <code class="literal">Configuration</code> en général au démarrage de l'application.  </p><p>Une <code class="literal">Session</code> n'est pas coûteuse, et c'est un objet non-threadsafe qui ne devrait être utilisé qu'une seule fois pour une requête unique, une conversation, une unité de travail unique et devrait être relâché ensuite. Un objet <code class="literal">Session</code> ne tentera pas d'obtenir une <code class="literal">Connection</code>JBDC (ou une <code class="literal">Datasource</code>) si ce n'est pas nécessaire, par conséquent il ne consommera pas de ressource jusqu'à son utilisation. </p><p>Afin de compléter ce tableau, vous devez également penser aux transactions de base de données. Une transaction de base de données doit être aussi courte que possible afin de réduire les risques de contention de verrou dans la base de données. De longues transactions à la base de données nuiront à l'extensibilité de vos applications lorsque confrontées à de hauts niveaux de charge. Par conséquent, ce n'est un bon design que de maintenir une transaction ouverte pendant la durée de reflexion de l'utilisateur, jusqu'à ce que l'unité de travail soit achevée.  </p><p>Quelle est la portée d'une unité de travail? Est-ce qu'une <code class="literal">Session</code> unique de Hibernate peut avoir une durée de vie dépassant plusieurs transactions à la base de données, ou bien est-ce une relation un-à-un des portées? Quand faut-il ouvrir et fermer une <code class="literal">Session</code> et comment définir les démarcations de vos transactions à la base de données ?  </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>13.1.1. Unité de travail</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as « <span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span> »[<a class="citation" href="bi01.html#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a class="xref" href="transactions.html#transactions-basics-apptx" title="13.1.2. Longue conversation">Section 13.1.2, « Longue conversation »</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>Tout d'abord n'utilisez pas l'anti-pattern <span class="emphasis"><em>session-par-operation</em></span> et n'ouvrez et ne fermez pas la <code class="literal">Session</code> à chacun de vos accès simples à la base de données dans un même thread ! Par conséquent, le même raisonnement est applicable à la gestion des transactions dans la base de données. Dans une application, les appels à la base de données doivent être effectués selon une séquence ordonnée et sont regroupés en unités de travail atomiques. (Notez que l'utilisation d'une connexion auto-commit après chaque déclaration SQL est inutile dans une application. Ce mode de fonctionnement existe pour les applications émettant des commandes SQL ad-hoc à partir d'une console. Hibernate désengage le mode auto-commit et s'attend à ce qu'un serveur d'applications le fasse également.) Les transactions avec la base de données ne sont jamais optionnelles. Toute communication avec une base de données doit se dérouler dans une transaction, peu importe si vous lisez ou écrivez des données. Comme déjà mentionné, le comportement auto-commit pour lire les données devrait être évité, puisque plusieurs petites transactions ne seront jamais aussi efficaces qu'une seule plus grosse clairement définie comme unité de travail. Ce dernier choix est de plus beaucoup plus facile à maintenir et plus extensible. </p><p>Le modèle d'utilisation le plus fréquemment rencontré dans des applications clients serveur multi-usagers est la <span class="emphasis"><em>session-par-requête</em></span>. Dans ce modèle, la requête d'un client est envoyée au serveur (où la couche de persistance est implémentée via Hibernate), une nouvelle <code class="literal">Session</code> Hibernate est ouverte et toutes les opérations d'accès à la base de données sont exécutées à l'intérieur de celle-ci. Lorsque le travail est terminé (et que les réponses à envoyer au client ont été préparées), la session est flushée et fermée. Une seule transaction à la base de données peut être utilisée pour répondre à la requête du client. La transaction est démarrée et validée au même moment où la Session est ouverte et fermée. La relation entre la <code class="literal">Session</code> et la <code class="literal">Transaction</code> est donc un-à-un. Cette relation entre les deux est un-à-un et ce modèle permet de répondre parfaitement aux attentes de la grande majorité des applications.  </p><p>Le défi réside dans l'implémentation. Hibernate fournit une fonction de gestion intégrée de la "session courante" pour simplifier ce pattern. Il vous suffit de démarrer une transaction lorsqu'une requête est traitée par le serveur, et la terminer avant que la réponse ne soit envoyée au client. Vous pouvez choisir la manière de l'effectuer, les solutions communes sont un <code class="literal">ServletFilter</code>, l'interception via AOP avec une coupe transverse (pointcut) sur les méthodes de type "service", ou un conteneur avec interception/proxy. Un conteneur EJB est un moyen standard d'implémenter ce genre d'acpect transverse comme la démarcation des transactions sur les EJB  session, de manière déclarative avec CMT. Si vous décidez d'utiliser la démarcation programmatique des transactions, préferrez l'API Hibernate <code class="literal">Transaction</code> traitée plus tard dans ce chapitre, afin de faciliter l'utilisation et la portabilité du code.  </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sessions contextuelles">Section 2.3, « Sessions contextuelles  »</a>. </p><p>Il est parfois utile d'étendre la portée d'une <code class="literal">Session</code> et d'une transaction à la base de données jusqu'à ce que "la vue soit rendue". Ceci est particulièrement utile dans des applications à base de servlet qui utilisent une phase de rendue séparée une fois que la réponse a été préparée. Étendre la transaction avec la base de données jusqu'à la fin du rendering de la vue est aisé si vous implémentez votre propre intercepteur. Cependant, ce n'est pas facile si vous vous appuyez sur les EJB avec CMT, puisqu'une transaction sera achevée au retour de la méthode EJB, avant le rendu de la vue. Rendez vous sur le site Hibernate et sur le forum pour des astuces et des exemples sur le pattern <span class="emphasis"><em>Open Session in View</em></span> .  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>13.1.2. Longue conversation</h3></div></div></div><p>Le paradigme "session-per-request" n'est pas le seul élément à utiliser dans le design de vos unités de travail. Plusieurs processus d'affaire requièrent toute une série d'interactions avec l'utilisateur, entrelacées d'accès à la base de donnée. Dans une application Web ou une application d'entreprise, il serait inacceptable que la durée de vie d'une transaction s'étale sur plusieurs interactions avec l'usager. Considérez l'exemple suivant : </p><div class="itemizedlist"><ul><li><p>Un écran s'affiche. Les données vues par l'usager ont été chargées dans l'instance d'un objet <code class="literal">Session</code> , dans le cadre d'une transaction de base de données. L'usager est libre de modifier ces objets.  </p></li><li><p>L'usager clique "Sauvegarder" après 5 minutes et souhaite persister les modifications qu'il a apportées. Il s'attend à être la seule personne a avoir modifié ces données et qu'aucune modification conflictuelle ne se soit produite durant ce laps de temps.  </p></li></ul></div><p>Ceci s'appelle une unité de travail. Du point de vue de l'utilisateur: une <span class="emphasis"><em>conversation</em></span> (ou <span class="emphasis"><em>transaction d'application</em></span>). Il y a plusieurs façon de mettre ceci en place dans votre application.  </p><p>Une première implémentation naïve pourrait consister à garder la <code class="literal">Session</code> et la transaction à la base de données ouvertes durant le temps de travail de l'usager, à maintenir les enregistrements verrouillés dans la base de données afin d'éviter des modifications concurrentes et de maintenir l'isolation et l'atomicité de la transaction de l'usager. Ceci est un anti-pattern à éviter, puisque le verrouillage des enregistrements dans la base de données ne permettrait pas à l'application de gérer un grand nombre d'usagers concurrents.  </p><p>Il apparaît donc évident qu'il faille utiliser plusieurs transactions BDD afin d'implémenter la conversation. Dans ce cas, maintenir l'isolation des processus d'affaire devient partiellement la responsabilité de la couche applicative. Ainsi, la durée de vie d'une conversation devrait englober celle d'une ou de plusieurs transactions de base de données. Celle-ci sera atomique seulement si l'écriture des données mises à jour est faite exclusivement par la dernière transaction BDD la composant. Toutes les autres sous transactions BD ne doivent faire que la lecture de données. Ceci est relativement facile à mettre en place, surtout avec l'utilisation de certaines fonctionnalités d'Hibernate : </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Versionnage Automatique</em></span> - Hibernate peut gérer automatiquement les accès concurrents de manière optimiste et détecter si une modification concurrente s'est produite durant le temps de réflexion d'un usager. A vérifier en fin de conversation. </p></li><li><p><span class="emphasis"><em>Objets Détachés</em></span> - Si vous décidez d'utiliser le paradigme <span class="emphasis"><em>session-par-requête</em></span> discuté plus haut, toutes les entités chargées en mémoire deviendront des objets détachés durant le temps de réflexion de l'usager. Hibernate vous permet de rattacher ces objets et de persister les modifications y ayant été apportées. Ce pattern est appelé: <span class="emphasis"><em>session-per- request-with-detached-objects</em></span> (littéralement: session- par-requête-avec-objets-détachés). Le versionnage automatique est utilisé afin d'isoler les modifications concurrentes.  </p></li><li><p><span class="emphasis"><em>Session Longues (conversation)</em></span> - Une <code class="literal">Session</code> Hibernate peut être déconnectée de la couche JDBC sous-jacente après que commit() ait été appelé sur une transaction à la base de données et reconnectée lors d'une nouvelle requête-client. Ce pattern s'appelle: <span class="emphasis"><em>session-per-conversation</em></span> (Littéralement: session-par- conversation) et rend superflu le rattachement des objets. Le versionnage automatique est utilisé afin d'isoler les modifications concurrentes.  </p></li></ul></div><p>Les deux patterns <span class="emphasis"><em>session-per-request-with- detached- objects</em></span> (session-par-requête-avec-objets- détachés) et <span class="emphasis"><em>session-per-conversation</em></span> (session-par-conversation) ont chacun leurs avantages et désavantages qui seront exposés dans ce même chapitre, dans la section au sujet du contrôle optimiste de concurrence.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>13.1.3. L'identité des objets</h3></div></div></div><p>Une application peut accéder à la même entité persistante de manière concurrente dans deux <code class="literal">Session</code> s différentes. Toutefois, une instance d'une classe persistante n'est jamais partagée par deux instances distinctes de la classe <code class="literal">Session</code>. Il existe donc deux notions de l'identité d'un objet : </p><div class="variablelist"><dl><dt><span class="term">Identité de database</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">Identité JVM</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>Ainsi, pour des objets attachés à une <code class="literal">Session</code><span class="emphasis"><em>particulière</em></span> (c'est-à-dire dans la portée d'une instance de <code class="literal">Session</code>), ces deux notions d'identité sont équivalentes et l'identité JVM pour l'identité de la base de données sont  garanties par Hibernate. Cependant, alors qu'une application peut accéder de manière concurrente au "même" objet métier (identité persistante) dans deux sessions différentes, les deux instances seront en fait "différentes" (en ce qui a trait à l'identité JVM). Les conflits sont résolus automatiquement par approche optimiste grâce au système de versionnage automatique au moment du flush/sauvegarde.  </p><p>Cette approche permet de reléguer à Hibernate et à la base de données sous-jacente le soin de gérer les problèmes d'accès concurrents. Cette manière de faire assure également une meilleure extensibilité de l'application puisque assurer l'identité JVM dans un thread ne nécessite pas de mécanismes de verrouillage coûteux ou d'autres dispositifs de synchronisation. Une application n'aura jamais besoin de synchroniser des objets d'affaire tant qu'elle peut garantir qu'un seul thread aura accès à une instance de <code class="literal">Session</code> . Dans le cadre d'exécution d'un objet <code class="literal">Session</code>, l'application peut utiliser en toute sécurité <code class="literal">== </code> pour comparer des objets.  </p><p>Une application qui utiliserait <code class="literal">==</code> à l'extérieur du cadre d'exécution d'une <code class="literal">Session</code> pourrait obtenir des résultats inattendus. Par exemple, si vous mettez deux objets dans le même <code class="literal">Set</code> , ceux-ci pourraient avoir la même identité de base de données (c'est-à-dire ils représentent le même enregistrement), mais leur identité JVM pourrait être différente (elle ne peut, par définition, pas être garantie sur deux objets détachés). Le développeur doit donc redéfinir l'implémentation des méthodes <code class="literal">equals()</code> et <code class="literal">hashcode()</code> dans les classes persistantes et y adjoindre sa propre notion d'identité. Il existe toutefois une restriction : il ne faut jamais utiliser uniquement l'identifiant de la base de données dans l'implémentation de l'égalité; il faut utiliser une clé d'affaire, généralement une combinaison de plusieurs attributs uniques, si possible immuables. Les identifiants de base de données vont changer si un objet transitoire (transient) devient persistant. Si une instance transitoire (en général avec des instances dégachées) est contenue dans un <code class="literal">Set</code>, changer le hashcode brisera le contrat du <code class="literal">Set</code> . Les attributs pour les clés d'affaire n'ont pas à être aussi stables que des clés primaires de bases de données. Il suffit simplement qu'elles soient stables tant et aussi longtemps que les objets sont dans le même <code class="literal">Set</code> . Veuillez consulter le site web Hibernate pour des discussions plus pointues à ce sujet. Notez que ce concept n'est pas propre à Hibernate mais bien général à l'implémentation de l'identité et de l'égalité en Java.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>13.1.4. Problèmes communs</h3></div></div></div><p>Bien qu'il puisse y avoir quelques rares exceptions à cette règle, il est recommandé de ne jamais utiliser les anti-modèles <span class="emphasis"><em>session-par- utilisateur-session</em></span> ou <span class="emphasis"><em>session-par-application</em></span> . Notez que certains des problèmes suivants pourraient néanmoins survenir avec des modèles recommandés, assurez-vous de bien comprendre les implications de chacun des modèles avant de prendre une décision concernant votre design : </p><div class="itemizedlist"><ul><li><p>L'objet <code class="literal">Session</code> n'est pas conçu pour être utilisé par de multiples threads. En conséquence, les objets potentiellement multi-thread comme les requêtes HTTP, les EJB Session et Swing Worker, risquent de provoquer des conditions de course dans la <code class="literal">Session</code> si celle-ci est partagée. Si vous gardez votre <code class="literal">Session</code> Hibernate dans la <code class="literal">HttpSession</code> (le sujet sera traité ultérieurement), il serait préférable de synchroniser les accès à la session Http afin d'éviter qu'un usager ne recharge une page assez rapidement pour que deux requêtes exécutant dans des threads concurrents n'utilisent la même <code class="literal">Session</code>. </p></li><li><p>Lorsque Hibernate lance une exception, le rollback de la transaction en cours dans la base de données, doit être effectué et la <code class="literal">Session</code> immédiatement fermée. (Nous approfondirons le sujet plus loin) Si votre <code class="literal">Session</code> est liée à l'application, il faut arrêter l'application. Le rollback de la transaction de base de données ne remettra pas les objets dans leur état du début de la transaction. Ainsi, cela signifie que l'état de la base de données et les objets d'affaires pourraient être désynchronisés d'avec les enregistrements. Généralement, cela ne cause pas de réel problème puisque la plupart des exceptions sont non traitables et de toutes façons, vous devez recommencer le processus après le rollback).  </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a class="xref" href="batch.html" title="Chapitre 15. Traitement par lot">Chapitre 15, <i>Traitement par lot</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>13.2. Démarcation des transactions de base de données</h2></div></div></div><p>La démarcation des transactions de base de données (ou système) est toujours nécessaire. Aucune communication avec la base de données ne peut être effectuée à l'extérieur du cadre d'une transaction. (Il semble que ce concept soit mal compris par plusieurs développeurs trop habitués à utiliser le mode auto-commit.) Utilisez toujours la démarcation des des transactions, même pour des opérations en lecture seule. Certains niveaux d'isolation et certaines possibilités offertes par les bases de données permettent de l'éviter, il n'est jamais désavantageux de toujours explicitement indiquer les bornes de transaction. Il est certain qu'une transaction unique de base de données sera plus performante que de nombreuses petites transactions, même pour les opérations simples de lecture.  </p><p>Une application utilisant Hibernate peut s'exécuter dans un environnement léger n'offrant pas la gestion automatique des transactions (application autonome, application web simple ou applications Swing) ou dans un environnement J2EE offrant des services de gestion automatiques des transactions JTA. Dans un environnement simple, Hibernate a généralement la responsabilité de la gestion de son propre pool de connexions à la base de données. Le développeur de l'application doit manuellement délimiter les transactions. En d'autres mots, il appartient au développeur de gérer les appels à <code class="literal">Transaction.begin()</code> , <code class="literal">Transaction.commit()</code> et <code class="literal">Transaction.rollback()</code>. Un environnement transactionnel J2EE (serveur d'application J2EE) doit offrir la gestion des transactions au niveau du conteneur J2EE. Les bornes de transaction peuvent normalement être définies de manière déclarative dans les descripteurs de déploiement d'EJB Session, par exemple. La gestion programmatique des transactions n'y est donc plus nécessaire. </p><p>Cependant, il est souvent préférable d'avoir une couche de persistance portable entre les environnements non gérés de ressources locales et les systèmes qui s'appuient sur JTA mais utilisent BMT à la place de CMT. Dans les deux cas, vous utiliserez la démarcation de transaction programmatique. Hibernate offre donc une API appelée <code class="literal">Transaction</code> qui sert d'enveloppe pour le système de transaction natif de l'environnement de déploiement. Il n'est pas obligatoire d'utiliser cette API, mais il est fortement conseillé de le faire, sauf lors de l'utilisation de CMT Session Bean. </p><p>Il existe quatre étapes distinctes lors de la fermeture d'une <code class="literal">Session</code> : </p><div class="itemizedlist"><ul compact="compact"><li><p>flush de la session </p></li><li><p>commit de la transaction </p></li><li><p>fermeture de la session  </p></li><li><p>gestion des exceptions </p></li></ul></div><p>La notion de "Flushing" a déjà été expliquée, nous abordons maintenant la démarcation des transactions et la gestion des exceptions dans les environnements gérés et non-gérés. </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>13.2.1. Environnement non gérés</h3></div></div></div><p>Si la couche de persistance Hibernate s'exécute dans un environnement non géré, les connexions à la base de données seront généralement prises en charge par le mécanisme de pool d'Hibernate qui obtient les connexions. La gestion de la session et de la transaction se fera donc de la manière suivante :  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>You do not have to <code class="literal">flush()</code> the <code class="literal">Session</code> explicitly: the call to <code class="literal">commit()</code> automatically triggers the synchronization depending on the <a class="link" href="objectstate.html#objectstate-flushing" title="11.10. Flush de la session">FlushMode</a> for the session. A call to <code class="literal">close()</code> marks the end of a session. The main implication of <code class="literal">close()</code> is that the JDBC connection will be relinquished by the session. This Java code is portable and runs in both non-managed and JTA environments. </p><p>Une solution plus flexible est la gestion par contexte de la session courante intégrée, fournie par Hibernate que nous avons déjà rencontrée : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Vous ne verrez probablement jamais ces exemples de code dans les applications ; les exceptions fatales (exceptions du système) ne devraient être traitées que dans la couche la plus "haute". En d'autres termes, le code qui exécute les appels à Hibernate (à la couche de persistance) et le code qui gère les <code class="literal">RuntimeException</code> (qui ne peut généralement effectuer qu'un nettoyage et une sortie) sont dans des couches différentes. La gestion du contexte courant par Hibernate peut simplifier notablement ce design, puisqu'il vous suffit d'accéder à la <code class="literal">SessionFactory</code>. La gestion des exceptions est traitée plus loin dans ce chapitre.  </p><p>Notez que vous devriez sélectionner <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code> (le défaut), pour le second exemple <code class="literal">"thread"</code> comme votre <code class="literal">hibernate.current_session_context_class</code>.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>13.2.2. Utilisation de JTA</h3></div></div></div><p>Si votre couche de persistance s'exécute dans un serveur d'applications (par exemple, derrière un EJB Session Bean), toutes les datasources utilisées par Hibernate feront automatiquement partie de transactions JTA globales. Vous pouvez également installer une implémentation autonome JTA et l'utiliser sans l'EJB.Hibernate propose deux stratégies pour réussir l'intégration JTA.  </p><p>Si vous utilisez des transactions gérées par un EJB (bean managed transactions - BMT), Hibernate informera le serveur d'applications du début et de la fin des transactions si vous utilisez l'API <code class="literal">Transaction</code>. Ainsi, le code de gestion des transactions sera identique dans les environnements non gérés.  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Si vous souhaitez utiliser une <code class="literal">Session</code> couplée à la transaction, c'est à dire, utiliser la fonctionnalité <code class="literal">getCurrentSession()</code> pour la propagation facile du contexte, vous devez utiliser l'API JTA <code class="literal">UserTransaction</code> directement : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">UserTransaction</span><span class="java_separator">)</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;java:comp/UserTransaction&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Do</span><span class="java_plain">&nbsp;some&nbsp;work&nbsp;on&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;bound&nbsp;to&nbsp;transaction</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">load</span><span class="java_separator">(...);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">persist</span><span class="java_separator">(...);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Avec CMT, la démarcation des transactions est faite dans les descripteurs de déploiement des Beans Sessions et non de manière programmatique, par conséquent le code est réduit à :  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;CMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</pre><p>Dans un EJB CMT, le rollback aussi intervient automatiquement, puisqu'une <code class="literal">RuntimeException</code> non traitée et soulevée par une méthode d'un bean session indique au conteneur d'annuler la transaction globale. <span class="emphasis"><em>Ceci veut donc dire que vous n'avez pas à utiliser l'API <code class="literal">Transaction</code> de Hibernate dans CMT ou BMT et vous obtenez la propagation automatique de la session courante liée à la transaction.</em></span> </p><p>Notez que le fichier de configuration Hibernate devrait contenir les valeurs <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> dans un environnement BMT ou <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> dans un environnement CMT là où vous configurez votre fabrique de transaction Hibernate. N'oubliez pas non plus de spécifier le paramètre <code class="literal">org.hibernate.transaction.manager_lookup_class</code> . De plus, assurez vous de fixer votre <code class="literal">hibernate.current_session_context_class</code> soit à <code class="literal">"jta"</code> ou de ne pas le configurer (compatibilité avec les versions précédentes).  </p><p>La méthode <code class="literal">getCurrentSession()</code> a un inconvénient dans les environnements JTA. Il y a une astuce qui est d'utiliser un mode de libération de connexion <code class="literal">after_statement</code> , qui est alors utilisé par défaut. Du à une étrange limitation de la spec JTA, il n'est pas possible à Hibernate de nettoyer automatiquement un <code class="literal">ScrollableResults</code> ouvert ou une instance d'<code class="literal">Iterator</code> retournés <code class="literal">scroll()</code> ou <code class="literal">iterate()</code>. Vous <span class="emphasis"><em>devez</em></span> libérer le curseur base de données sous jacent ou invoquer <code class="literal">Hibernate.close(Iterator)</code> explicitement depuis un bloc <code class="literal">finally</code>. (Bien sur, la plupart des applications peuvent éviter d'utiliser <code class="literal">scroll()</code> ou <code class="literal">iterate()</code> dans un code JTA ou CMT.)  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>13.2.3. Gestion des exceptions</h3></div></div></div><p>Si une <code class="literal">Session</code> lance une exception (incluant les exceptions du type <code class="literal">SQLException</code> ou d'un sous-type), vous devez immédiatement effectuer le rollback de la transaction, appeler <code class="literal">Session.close()</code> et relâcher les références sur l'objet <code class="literal">Session</code> . La <code class="literal">Session</code> contient des méthodes pouvant la mettre dans un état inutilisable. Vous devez considérer qu'<span class="emphasis"><em>aucune</em></span> exception lancée par Hibernate n'est traitable comme recouvrable. Assurez-vous de fermer la session en appelant <code class="literal">close()</code> dans un bloc <code class="literal">finally</code> .  </p><p>L'exception <code class="literal">HibernateException</code>, qui englobe la plupart des exceptions pouvant survenir dans la couche de persistance Hibernate, est une exception non vérifiée (Ceci n'était pas le cas dans des versions antérieures de Hibernate.) Nous pensons que nous ne devrions pas forcer un développeur à gérer une exception qu'il ne peut de toute façon pas traiter dans une couche technique. Dans la plupart des systèmes, les exceptions non vérifiées et les exceptions fatales sont gérées en amont du processus (dans les couches hautes) et un message d'erreur est alors affiché à l'usager (ou un traitement alternatif est invoqué.) Veuillez noter que Hibernate peut également lancer des exceptions non vérifiées d'un autre type que <code class="literal">HibernateException</code>. Celles-ci sont également non traitables et vous devez les traiter comme telles.  </p><p>Hibernate englobe les <code class="literal">SQLException</code> s lancées lors des interactions directes avec la base de données dans des exceptions de type: <code class="literal">JDBCException</code>. En fait, Hibernate essaiera de convertir l'exception dans un sous-type plus significatif de <code class="literal">JDBCException</code>. L'exception <code class="literal">SQLException</code> sous-jacente est toujours disponible via la méthode <code class="literal">JDBCException.getCause()</code>. Hibernate convertit le <code class="literal">SQLExceptionConverter</code> en une sous-classe <code class="literal">JDBCException</code>, en utilisant le <code class="literal">SQLExceptionConverter</code> qui est rattaché à l'objet <code class="literal">SessionFactory</code>. Par défaut, le <code class="literal">SQLExceptionConverter</code> est défini par le dialecte configuré dans Hibernate. Toutefois, il est possible de fournir sa propre implémentation de l'interface. (Veuillez vous référer à la javadoc sur la classe <code class="literal">SQLExceptionConverterFactory</code> pour plus de détails. Les sous-types standard de <code class="literal">JDBCException</code> sont : </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code> - indique une erreur de communication avec la couche JDBC sous-jacente.  </p></li><li><p><code class="literal">SQLGrammarException</code> - indique un problème de grammaire ou de syntaxe avec la requête SQL envoyée.  </p></li><li><p><code class="literal">ConstraintViolationException</code> - indique une violation de contrainte d'intégrité.  </p></li><li><p><code class="literal">LockAcquisitionException</code> - indique une erreur de verrouillage lors de l'exécution de la requête.  </p></li><li><p><code class="literal">GenericJDBCException</code> - indique une erreur générique ne correspondant à aucune autre catégorie.  </p></li></ul></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>13.2.4. Timeout de transaction</h3></div></div></div><p>Une des caractéristiques extrêmement importante fournie dans les environnements gérés tels les EJB, est la gestion du timeout de transaction qui n'est jamais fournie pour le code non géré. La gestion des dépassements de temps de transaction vise à s'assurer qu'une transaction agissant incorrectement ne viendra pas bloquer indéfiniment les ressources de l'application et ne retourner aucune réponse à l'utilisateur. Hibernate ne peut fournir cette fonctionnalité dans un environnement transactionnel non-JTA. Par contre, Hibernate gère les opérations d'accès aux données en allouant un temps maximal aux requêtes pour s'exécuter. Ainsi, une requête créant de l'inter blocage ou retournant de très grandes quantités d'informations pourrait être interrompue. Dans un environnement géré, Hibernate peut déléguer au gestionnaire de transaction JTA, le soin de gérer les dépassements de temps. Cette fonctionnalité est abstraite par l'objet <code class="literal">Transaction</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">set&nbsp;transaction&nbsp;timeout&nbsp;to&nbsp;</span><span class="java_literal">3</span><span class="java_plain">&nbsp;seconds</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">setTimeout</span><span class="java_separator">(</span><span class="java_literal">3</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Notez que <code class="literal">setTimeout()</code> ne peut pas être appelé d'un EJB CMT, puisque le timeout des transaction doit être spécifié de manière déclarative.  </p></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>13.3. Contrôle de concurrence optimiste</h2></div></div></div><p>La gestion optimiste des accès concurrents avec versionnage est la seule approche pouvant garantir l'extensibilité des applications à haut niveau de charge. Le système de versionnage utilise des numéros de version ou l'horodatage pour détecter les mise à jour causant des conflits avec d'autres actualisations antérieures (et pour éviter la perte de mise à jour). Hibernate propose trois approches possibles pour l'écriture de code applicatif utilisant la gestion optimiste d'accès concurrents. Le cas d'utilisation décrit plus bas fait mention de longues conversations, mais le versionnage peut également améliorer la qualité d'une application en prévenant la perte de mise à jour dans les transactions uniques de base de données.  </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>13.3.1. Vérification du versionnage au niveau applicatif</h3></div></div></div><p>Dans cet exemple d'implémentation utilisant peu les fonctionnalités de Hibernate, chaque interaction avec la base de données se fait en utilisant une nouvelle <code class="literal">Session</code> et le développeur doit recharger les données persistantes à partir de la base de données avant de les manipuler. Cette implémentation force l'application à vérifier la version des objets afin de maintenir l'isolation transactionnelle. Cette approche, semblable à celle retrouvée pour les EJB, est la moins efficace parmi celles qui sont présentées dans ce chapitre.  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">int</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">,</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getKey</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;load&nbsp;the&nbsp;current&nbsp;state</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StaleObjectStateException</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>Le mappage de la propriété <code class="literal">version</code> est fait via <code class="literal">&lt;version&gt;</code> et Hibernate l'incrémentera automatiquement à chaque flush() si l'entité doit être mise à jour. </p><p>Bien sûr, si votre application ne fait pas face à beaucoup d'accès concurrents et ne nécessite pas l'utilisation du versionnage, cette approche peut également être utilisée, il n'y a qu'à ignorer le code relié au versionnage. Dans ce cas, la stratégie du <span class="emphasis"><em>last commit wins</em></span> (littéralement: le dernier commit l'emporte) sera utilisée pour les conversations (longues transactions applicatives). Gardez à l'esprit que cette approche pourrait rendre perplexe les utilisateurs de l'application car ils pourraient perdre des données mises à jour sans qu'aucun message d'erreur ne leur soit présenté et sans avoir la possibilité de fusionner les données.  </p><p>Il est clair que la gestion manuelle de la vérification du versionnage des objets ne peut être effectuée que dans certains cas triviaux et que cette approche n'est pas valable pour la plupart des applications. De manière générale, les applications ne cherchent pas à actualiser de simples objets sans relations, elles le font généralement pour de larges graphes d'objets. Hibernate peut gérer automatiquement la vérification des versions d'objets en utilisant soit une <code class="literal">Session</code> longue, soit des instances détachées comme paradigme des conversations.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>13.3.2. Les sessions longues et le versionnage automatique.</h3></div></div></div><p>Dans ce scénario, une seule instance de <code class="literal">Session</code> et des objets persistants est utilisée pour toute la conversation, connue sous <span class="emphasis"><em>session-par-conversation</em></span>. Hibernate vérifie la version des objets persistants avant d'effectuer le flush() et lance une exception si une modification concurrente est détectée. Il appartient alors au développeur de gérer l'exception. Les traitements alternatifs généralement proposés sont alors de permettre à l'usager de faire la fusion des données ou de lui offrir de recommencer son travail à partie des données les plus récentes dans la base de données.  </p><p>Notez que lorsqu'une application est en attente d'une action de la part de l'usager, la <code class="literal">Session</code> n'est pas connectée à la couche JDBC sous-jacente. C'est la manière la plus efficace de gérer les accès à la base de données. L'application ne devrait pas se préoccuper du versionnage des objets, ou du rattachement des objets détachés, ni du rechargement de tous les objets à chaque transaction.  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;earlier&nbsp;by&nbsp;the&nbsp;old&nbsp;session</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Obtain</span><span class="java_plain">&nbsp;a&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;start&nbsp;transaction</span>
</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Also</span><span class="java_plain">&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span></pre><p>L'objet <code class="literal">foo</code> sait quel objet <code class="literal">Session</code> l'a chargé. <code class="literal">Session.reconnect()</code> obtient une nouvelle connexion (celle-ci peut être également fournie) et permet à la session de continuer son travail. La méthode <code class="literal">Session.disconnect()</code> déconnecte la session de la connexion JDBC et retourne celle-ci au pool de connexion (à moins que vous ne lui ayez fourni vous même la connexion.) Après la reconnexion, afin de forcer la vérification du versionnage de certaines entités que vous ne cherchez pas à actualiser, vous pouvez faire un appel à <code class="literal">Session.lock()</code> en mode <code class="literal">LockMode.READ</code> pour tout objet ayant pu être modifié par une autre transaction. Il n'est pas nécessaire de verrouiller les données que vous désirez mettre à jour. En général, vous configurerez<code class="literal">FlushMode.NEVER</code> sur une <code class="literal">Session</code> étendue, de façon que seul le dernier cycle de transaction de la base de données puissent persister toutes les modifications effectuées dans cette conversation. Par conséquent, cette dernière transaction inclura l'opération <code class="literal">flush()</code>, de même que <code class="literal">close()</code> la session pour finir la conversation. </p><p>Ce modèle peut présenter des problèmes si la <code class="literal">Session</code> est trop volumineuse pour être stockée entre les actions de l'usager. Plus spécifiquement, une session <code class="literal">HttpSession</code> se doit d'être la plus petite possible. Puisque la <code class="literal">Session</code> joue obligatoirement le rôle de mémoire cache de premier niveau et contient à ce titre tous les objets chargés, il est préférable de n'utiliser une <code class="literal">Session</code> que pour une seule conversation, car les objets risquent d'y être rapidement périmés. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Remarque</h2><p>Notez que des versions précédentes de Hibernate exigeaient une déconnexion explicite et une reconnexion d'une <code class="literal">Session</code>. Ces méthodes sont périmées, puisque commencer et terminer une transaction a le même effet. </p></div><p>Notez que la <code class="literal">Session</code> déconnectée devrait être conservée près de la couche de persistance. Autrement dit, utilisez un EJB stateful pour conserver la <code class="literal">Session</code> dans un environnement 3 niveaux et évitez de la sérialiser et de la transférer à la couche de présentation (c'est-à-dire qu'il est préférable de ne pas la conserver dans la session <code class="literal">HttpSession</code> .)  </p><p>Le modèle de session étendue, ou <span class="emphasis"><em>session-par-conversation</em></span>, est plus difficile à implémenter avec la gestion automatique de contexte de session courante. À cet effet, vous devez fournir votre propre implémentation de<code class="literal">CurrentSessionContext</code>, pour des exemples consultez Hibernate Wiki.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>13.3.3. Les objets détachés et le versionnage automatique</h3></div></div></div><p>Chaque interaction avec le système de persistance se fait via une nouvelle <code class="literal">Session</code> . Toutefois, les mêmes instances d'objets persistants sont réutilisées pour chacune de ces interactions. L'application doit pouvoir manipuler l'état des instances détachées ayant été chargées antérieurement via une autre session. Pour ce faire, ces objets persistants doivent être rattachés à la <code class="literal">Session</code> courante en utilisant <code class="literal">Session.update()</code>, <code class="literal">Session.saveOrUpdate()</code>, ou <code class="literal">Session.merge()</code> . </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">saveOrUpdate</span><span class="java_separator">(</span><span class="java_plain">foo</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Use</span><span class="java_plain">&nbsp;merge</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;foo&quot;</span><span class="java_plain">&nbsp;might&nbsp;have&nbsp;been&nbsp;loaded&nbsp;already</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>Encore une fois, Hibernate vérifiera la version des instances devant être actualisées durant le flush(). Une exception sera lancée si des conflits sont détectés.  </p><p>Vous pouvez également utiliser <code class="literal">lock()</code> au lieu de <code class="literal">update()</code> et utiliser le mode <code class="literal">LockMode.READ</code> (qui lancera une vérification de version, en ignorant tous les niveaux de mémoire cache) si vous êtes certain que l'objet n'a pas été modifié.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>13.3.4. Personnaliser le versionnage automatique</h3></div></div></div><p>Vous pouvez désactiver l'incrémentation automatique du numéro de version de certains attributs et collections en mettant la valeur du paramètre de mapping <code class="literal">optimistic-lock</code> à <code class="literal">false</code>. Hibernate cessera ainsi d'incrémenter leur numéro de version si la propriété est dirty.  </p><p>Certaines entreprises possèdent de vieux systèmes dont les schémas de bases de données sont statiques et ne peuvent être modifiés. Il existe aussi des cas où plusieurs applications doivent accéder à la même base de données, mais certaines d'entre elles ne peuvent gérer les numéros de version ou les champs horodatés. Dans les deux cas, le versionnage ne peut se fier à une colonne particulière dans une table. Afin de forcer la vérification de version dans un système sans en faire le mappage, mais en forçant une comparaison des états de tous les attributs d'une entité, vous pouvez utiliser l'attribut <code class="literal">optimistic- lock="all"</code> dans le mappage <code class="literal">&lt;class&gt;</code>. Veuillez noter que cette manière de gérer le versionnage ne peut être utilisée que si l'application utilise de longues sessions, lui permettant de comparer l'ancien état et le nouvel état d'une entité. L'utilisation d'un modèle <code class="literal">session-per-request-with-detached- objects</code> devient alors impossible.  </p><p>Il peut être souhaitable de permettre les modifications concurrentes du moment que les modifications ne se chevauchent pas. En configurant la propriété à <code class="literal">optimistic-lock="dirty"</code> quand vous mappez le <code class="literal">&lt;class&gt;</code>, Hibernate ne fera la comparaison que des champs devant être actualisés lors du flush. </p><p>Dans les deux cas: en utilisant une colonne de version/horodatée ou via la comparaison de l'état complet de l'objet ou de ses champs modifiés, Hibernate ne créera qu'une seule commande <code class="literal">UPDATE</code> par entité avec la clause <code class="literal">WHERE</code> appropriée pour vérifier la version et mettre à jour les informations. Si vous utilisez la persistance transitive pour propager l'évènement de rattachement à des entités associées, il est possible que Hibernate génère des commandes de mise à jour inutiles. Ceci n'est généralement pas un problème, mais certains déclencheurs <span class="emphasis"><em>on update</em></span> dans la base de données pourraient être activés même si aucun changement n'était réellement persisté sur des objets détachés. Vous pouvez personnaliser ce comportement en indiquant <code class="literal">select-before- update="true"</code> dans l'élément de mappage <code class="literal">&lt;class&gt;</code>. Ceci forcera Hibernate à faire le <code class="literal">SELECT</code> de l'instance afin de s'assurer que l'entité doit réellement être actualisée avant de lancer la commande de mise à jour de l'enregistrement.  </p></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>13.4. Verrouillage pessimiste </h2></div></div></div><p>Il n'est nécessaire de s'attarder à la stratégie de verrouillage des entités dans une application utilisant Hibernate. Il est généralement suffisant de définir le niveau d'isolation pour les connexions JDBC et de laisser ensuite la base de donnée effectuer son travail. Toutefois, certains utilisateurs avancés peuvent vouloir obtenir un verrouillage pessimiste exclusif sur un enregistrement, ou le ré-obtenir au lancement d'une nouvelle transaction.  </p><p>Hibernate utilisera toujours le mécanisme de verrouillage de la base de données et ne verrouillera jamais les objets en mémoire. </p><p>La classe <code class="literal">LockMode</code> définit les différents niveaux de verrouillage pouvant être obtenus par Hibernate. Le verrouillage est obtenu par les mécanismes suivants :  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode.WRITE</code> est obtenu automatiquement quand Hibernate actualise ou insère un enregistrement. </p></li><li><p><code class="literal">LockMode.UPGRADE</code> peut être obtenu de manière explicite via la requête en utilisant <code class="literal">SELECT ... FOR UPDATE</code> sur une base de données supportant cette syntaxe.  </p></li><li><p><code class="literal">LockMode.UPGRADE_NOWAIT</code> peut être obtenu de manière explicite en utilisant <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> sur Oracle.  </p></li><li><p><code class="literal">LockMode.READ</code> est obtenu automatiquement quand Hibernate lit des données dans un contexte d'isolation <code class="literal">Repeatable Read</code> ou <code class="literal">Serializable</code>. Peut être ré-obtenu explicitement via une requête d'utilisateur.  </p></li><li><p><code class="literal">LockMode.NONE</code> représente l'absence de verrouillage. Tous les objets migrent vers ce mode à la fin d'une <code class="literal">Transaction</code> . Les objets associés à une session via un appel à <code class="literal">saveOrUpdate()</code> commencent également leur cycle de vie dans ce mode verrouillé.  </p></li></ul></div><p>Les requêtes explicites d'utilisateur sont exprimées d'une des manières suivantes : </p><div class="itemizedlist"><ul compact="compact"><li><p>Un appel à <code class="literal">Session.load()</code>, en spécifiant un niveau verrouillage <code class="literal">LockMode</code> . </p></li><li><p>Un appel à <code class="literal">Session.lock()</code>. </p></li><li><p>Une appel à <code class="literal">Query.setLockMode()</code>. </p></li></ul></div><p>Si <code class="literal">Session.load()</code> est appelé avec le paramètre de niveau de verrouillage <code class="literal">UPGRADE</code> ou <code class="literal">UPGRADE_NOWAIT</code> et que l'objet demandé n'est pas présent dans la session, celui-ci sera chargé à l'aide d'une requête <code class="literal">SELECT ... FOR UPDATE</code> . Si la méthode <code class="literal">load()</code> est appelée pour un objet déjà en session avec un verrouillage moindre que celui demandé, Hibernate appellera la méthode <code class="literal">lock()</code> pour cet objet. </p><p><code class="literal">Session.lock()</code> effectue une vérification de version si le niveau de verrouillage est <code class="literal">READ</code> , <code class="literal">UPGRADE</code> ou <code class="literal">UPGRADE_NOWAIT</code> . Dans le cas des niveaux <code class="literal">UPGRADE</code> ou <code class="literal">UPGRADE_NOWAIT</code> , une requête <code class="literal">SELECT ... FOR UPDATE</code> sera utilisée. </p><p>Si une base de données ne supporte pas le niveau de verrouillage demandé, Hibernate utilisera un niveau alternatif convenable au lieu de lancer une exception. Ceci assurera la portabilité de vos applications. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>13.5. Modes de libération de connexion</h2></div></div></div><p>Le comportement original (2.x) de Hibernate pour la gestion des connexions JDBC était que la <code class="literal">Session</code> obtenait une connexion dès qu'elle en avait besoin et la libérait une fois la session fermée. Hibernate 3.x a introduit les modes de libération de connexion pour indiquer à la session comment gérer les transactions JDBC. Notez que la discussion suivante n'est pertinente que pour des connexions fournies par un <code class="literal">ConnectionProvider</code>, celles gérées par l'utilisateur dépassent l'objectif de cette discussion. Les différents modes de libération sont identifiés par les valeurs énumérées de <code class="literal">org.hibernate.ConnectionReleaseMode</code> : </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code> - est essentiellement le comportement passé décrit ci-dessus. La session Hibernate obtient une connexion lorsqu'elle en a besoin et la garde jusqu'à ce que la session se ferme.  </p></li><li><p><code class="literal">AFTER_TRANSACTION</code> - indique de relâcher la connexion après qu'une <code class="literal">org.hibernate.Transaction</code> soit achevée.  </p></li><li><p><code class="literal">AFTER_STATEMENT</code> (aussi appelé libération brutale) - indique de relâcher les connexions après chaque exécution d'un statement. Ce relâchement agressif est annulé si ce statement laisse des ressources associées à une session donnée ouvertes, actuellement ceci n'arrive que lors de l'utilisation de <code class="literal">org.hibernate.ScrollableResults</code>.  </p></li></ul></div><p>Le paramètre de configuration <code class="literal">hibernate.connection.release_mode</code> est utilisé pour spécifier quel mode de libération doit être utilisé. Les valeurs possibles sont :  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code> (valeur par défaut) - ce choix délègue le choix de libération à la méthode <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code> Pour la JTATransactionFactory, elle retourne ConnectionReleaseMode.AFTER_STATEMENT; pour JDBCTransactionFactory, elle retourne ConnectionReleaseMode.AFTER_TRANSACTION. C'est rarement une bonne idée de changer ce comportement par défaut puisque les erreurs soulevées par ce paramétrage tend à indiquer la présence de bogues et/ou d'erreurs dans le code de l'utilisateur.  </p></li><li><p><code class="literal">on_close</code> - indique d'utiliser ConnectionReleaseMode.ON_CLOSE. Ce paramétrage existe pour garantir la compatibilité avec les versions précédentes, mais ne devrait plus être utilisé.  </p></li><li><p><code class="literal">after_transaction</code> - indique d'utiliser ConnectionReleaseMode.AFTER_TRANSACTION. Ne devrait pas être utilisé dans les environnements JTA. Notez aussi qu'avec ConnectionReleaseMode.AFTER_TRANSACTION, si une session est considérée comme étant en mode auto-commit les connexions seront relâchées comme si le mode était AFTER_STATEMENT.  </p></li><li><p><code class="literal">after_statement</code> - indique d'utiliser ConnectionReleaseMode.AFTER_STATEMENT. De plus, le <code class="literal">ConnectionProvider</code> utilisé est consulté pour savoir s'il supporte ce paramétrage (<code class="literal">supportsAggressiveRelease()</code>). Si ce n'est pas le cas, le mode de libération est ré-initialisé à ConnectionReleaseMode.AFTER_TRANSACTION. Ce paramétrage n'est sûr que dans les environnements où il est possible d'obtenir à nouveau la même connexion JDBC à chaque fois que l'on fait un appel de <code class="literal">ConnectionProvider.getConnection()</code> ou dans les environnements auto-commit où il n'est pas important d'obtenir plusieurs fois la même connexion.  </p></li></ul></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>Précédent</strong>Chapitre 12. Read-only entities</a></li><li class="up"><a accesskey="u" href="#"><strong>Niveau supérieur</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Sommaire</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>Suivant</strong>Chapitre 14. Intercepteurs et événements</a></li></ul></body></html>