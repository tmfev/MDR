<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第27章 ベストプラクティス</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="example-mappings.html" title="第26章 例： いろいろなマッピング"/><link rel="next" href="portability.html" title="第28章 Database Portability Considerations"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="example-mappings.html"><strong>前のページ</strong></a></li><li class="next"><a accesskey="n" href="portability.html"><strong>次のページ</strong></a></li></ul><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="best-practices"/>第27章 ベストプラクティス</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">クラスは細かい粒度で書き <code class="literal">&lt;component&gt;</code> でマッピングしましょう。</span></dt><dd><p><code class="literal">street</code> （通り）、 <code class="literal">suburb</code> （都市）、 <code class="literal">state</code> （州）、 <code class="literal">postcode</code> （郵便番号）をカプセル化する <code class="literal">Address</code> （住所）クラスを使いましょう。そうすればコードが再利用しやすくなり、リファクタリングも簡単になります。 </p></dd><dt><span class="term">永続クラスには識別子プロパティを定義しましょう。</span></dt><dd><p>Hibernate では識別子プロパティはオプションですが、使用すべき理由がたくさんあります。識別子は「人工的」（生成された、業務的な意味を持たない）なものにすることをおすすめします。 </p></dd><dt><span class="term">自然キーを見つけましょう。</span></dt><dd><p>すべてのエンティティに対して自然キーを見つけて、 <code class="literal">&lt;natural-id&gt;</code> でマッピングしましょう。自然キーを構成するプロパティを比較するために、 <code class="literal">equals()</code> と <code class="literal">hashCode()</code> を実装しましょう。 </p></dd><dt><span class="term">クラスのマッピングはそれぞれのクラス専用のファイルに書きましょう。</span></dt><dd><p>単一の巨大なマッピングドキュメントを使用しないでください。 <code class="literal">com.eg.Foo</code> クラスなら <code class="literal">com/eg/Foo.hbm.xml</code> ファイルにマッピングしましょう。このことは、特にチームでの開発に意味があります。 </p></dd><dt><span class="term">リソースとしてマッピングをロードしましょう。</span></dt><dd><p>マッピングを、それらがマッピングするクラスと一緒に配置しましょう。 </p></dd><dt><span class="term">クエリ文字列を外部に置くことを考えましょう</span></dt><dd><p>クエリが ANSI 標準でない SQL 関数を呼んでいるなら、これはよいプラクティスです。クエリ文字列をマッピングファイルへ外出しすればアプリケーションがポータブルになります。 </p></dd><dt><span class="term">バインド変数を使いましょう。</span></dt><dd><p>JDBC の場合と同じように、定数でない値は必ず "?" で置き換えましょう。定数でない値をバインドするために、クエリで文字列操作を使ってはいけません。名前付きのパラメータを使うようにするとさらに良いです。 </p></dd><dt><span class="term">JDBC コネクションを管理してはいけません。</span></dt><dd><p>Hibernate ではアプリケーションが JDBC コネクションを管理することが許されています。しかしこれは最終手段だと思ってください。組み込みのコネクションプロバイダを使うことができなければ、 <code class="literal">org.hibernate.connection.ConnectionProvider</code> を実装することを考えてください。 </p></dd><dt><span class="term">カスタム型の使用を考えましょう。</span></dt><dd><p>あるライブラリから持ってきた Java 型を永続化する必要があるとしましょう。しかしその型には、コンポーネントとしてマッピングするために必要なアクセサがないとします。このような場合は <code class="literal">org.hibernate.UserType</code> の実装を考えるべきです。そうすれば Hibernate 型との実装変換を心配せずにアプリケーションのコードを扱えます。 </p></dd><dt><span class="term">ボトルネックを解消するには JDBC をハンドコードしましょう。</span></dt><dd><p>In performance-critical areas of the system, some kinds of operations might benefit from direct JDBC. Do not assume, however, that JDBC is necessarily faster. Please wait until you <span class="emphasis"><em>know</em></span> something is a bottleneck. If you need to use direct JDBC, you can open a Hibernate <code class="literal">Session</code>, wrap your JDBC operation as a <code class="literal">org.hibernate.jdbc.Work</code> object and using that JDBC connection. This way you can still use the same transaction strategy and underlying connection provider. </p></dd><dt><span class="term"><code class="literal">Session</code> のフラッシュを理解しましょう。</span></dt><dd><p>Session が永続状態をデータベースと同期させることがときどきあります。しかしこれがあまりに頻繁に起こるようだと、パフォーマンスに影響が出てきます。自動フラッシュを無効にしたり、特定のトランザクションのクエリや操作の順番を変更することで、不必要なフラッシュを最小限にできます。 </p></dd><dt><span class="term">3層アーキテクチャでは分離オブジェクトの使用を考えましょう。</span></dt><dd><p>サーブレット / セッション Bean アーキテクチャを使うとき、サーブレット層 / JSP 層間でセッション Bean でロードした永続オブジェクトをやり取りできます。その際リクエストごとに新しい Session を使ってください。また <code class="literal">Session.merge()</code> や <code class="literal">Session.saveOrUpdate()</code> を使って、オブジェクトとデータベースを同期させてください。 </p></dd><dt><span class="term">2層アーキテクチャでは長い永続コンテキストの使用を考えましょう。</span></dt><dd><p>最高のスケーラビリティを得るには、データベーストランザクションをできるだけ短くしなければなりません。しかし長い間実行する <span class="emphasis"><em>アプリケーショントランザクション</em></span> の実装が必要なことはしばしばです。これはユーザーの視点からは1個の作業単位（unit of work）になります。アプリケーショントランザクションはいくつかのクライアントのリクエスト/レスポンスサイクルにまたがります。アプリケーショントランザクションの実装に分離オブジェクトを使うのは一般的です。そうでなければ、2層アーキテクチャの場合は特に適切なことですが、アプリケーショントランザクションのライフサイクル全体に対して単一のオープンな永続化コンテキスト（セッション）を維持してください。そして単純にリクエストの最後に JDBC コネクションから切断し、次のリクエストの最初に再接続します。決して複数のアプリケーショントランザクションユースケースに渡って1個の Session を使い回さないでください。そうでなければ、古いデータで作業することになります。 </p></dd><dt><span class="term">例外を復帰可能なものとして扱ってはいけません。</span></dt><dd><p>これは「ベスト」プラクティス以上の、必須のプラクティスです。例外が発生したときは <code class="literal">Transaction</code> をロールバックして、 <code class="literal">Session</code> をクローズしてください。そうしないと Hibernate はメモリの状態が永続状態を正確に表現していることを保証できません。この特別な場合として、与えられた識別子を持つインスタンスがデータベースに存在するかどうかを判定するために、 <code class="literal">Session.load()</code> を使うことはやめてください。その代わりに <code class="literal">Session.get()</code> かクエリを使ってください。 </p></dd><dt><span class="term">関連にはなるべく遅延フェッチを使いましょう。</span></dt><dd><p>即時フェッチは控えめにしましょう。二次キャッシュには完全に保持されないようなクラスの関連には、プロキシと遅延コレクションを使ってください。キャッシュされるクラスの関連、つまりキャッシュがヒットする可能性が非常に高い関連は、 <code class="literal">lazy="false"</code> で積極的なフェッチを明示的に無効にしてください。結合フェッチが適切な特定のユースケースには、クエリで <code class="literal">left join fetch</code> を使ってください。 </p></dd><dt><span class="term">フェッチされていないデータに関わる問題を避けるために、 <span class="emphasis"><em>ビューの中でオープンセッションを使う (open session in view) </em></span> パターンか、統制された <span class="emphasis"><em>組み立てフェーズ (assembly phase) </em></span> を使いましょう。 </span></dt><dd><p>Hibernate は <span class="emphasis"><em>Data Transfer Objects</em></span> (DTO) を書く退屈な作業から開発者を解放します。伝統的な EJB アーキテクチャでは DTO は2つ目的があります： 1つ目は、エンティティ Bean がシリアライズされない問題への対策です。2つ目は、プレゼンテーション層に制御が戻る前に、ビューに使われるすべてのデータがフェッチされて、 DTO に復元されるような組み立てフェーズを暗黙的に定義します。 Hibernate では1つ目の目的が不要になります。しかしビューのレンダリング処理の間、永続コンテキスト（セッション）をオープンにしたままにしなければ、組み立てフェーズはまだ必要です（分離オブジェクトの中のどのデータが利用可能かについて、プレゼンテーション層と厳密な取り決めをしているビジネスメソッドを考えてみてください）。これは Hibernate 側の問題ではありません。トランザクション内で安全にデータアクセスするための基本的な要件です。 </p></dd><dt><span class="term">Hibernate からビジネスロジックを抽象化することを考えましょう。</span></dt><dd><p>インターフェースで（Hibernate の）データアクセスコードを隠蔽しましょう。 <span class="emphasis"><em>DAO</em></span> と <span class="emphasis"><em>Thread Local Session</em></span> パターンを組み合わせましょう。 <code class="literal">UserType</code> で Hibernate に関連付けると、ハンドコードした JDBC で永続化するクラスを持つこともできます。（このアドバイスは「十分大きな」アプリケーションに対してのものです。テーブルが5個しかないようなアプリケーションには当てはまりません。） </p></dd><dt><span class="term">珍しい関連マッピングは使わないようにしましょう。</span></dt><dd><p>よいユースケースに本当の多対多関連があることは稀です。ほとんどの場合「リンクテーブル」の付加的な情報が必要になります。この場合、リンククラスに2つの一対多関連を使う方がずっとよいです。実際ほとんどの場合、関連は一対多と多対一なので、他のスタイルの関連を使うときは本当に必要かどうかを考えてみてください。 </p></dd><dt><span class="term">なるべく双方向関連にしましょう。</span></dt><dd><p>単方向関連は双方向に比べて検索が難しくなります。大きなアプリケーションでは、ほとんどすべての関連が双方向にナビゲーションできなければなりません。 </p></dd></dl></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">製作著作 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="example-mappings.html"><strong>前のページ</strong>第26章 例： いろいろなマッピング</a></li><li class="up"><a accesskey="u" href="#"><strong>上に戻る</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>ホーム</strong></a></li><li class="next"><a accesskey="n" href="portability.html"><strong>次のページ</strong>第28章 Database Portability Considerations</a></li></ul></body></html>