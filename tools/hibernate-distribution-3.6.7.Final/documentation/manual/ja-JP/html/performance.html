<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第21章 パフォーマンスの改善</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="xml.html" title="第20章 XML マッピング"/><link rel="next" href="toolsetguide.html" title="第22章 ツールセットガイド"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>前のページ</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>次のページ</strong></a></li></ul><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>第21章 パフォーマンスの改善</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance.html#performance-fetching">21.1. フェッチ戦略</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-fetching-lazy">21.1.1. 遅延関連の働き</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-custom">21.1.2. フェッチ戦略のチューニング</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-proxies">21.1.3. 単一端関連プロキシ</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-initialization">21.1.4. コレクションとプロキシの初期化</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-batch">21.1.5. バッチフェッチの使用</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-subselect">21.1.6. サブセレクトフェッチの使用</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-profiles">21.1.7. Fetch profiles</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-lazyproperties">21.1.8. 遅延プロパティフェッチの使用</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-cache">21.2. 第2レベルキャッシュ</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-cache-mapping">21.2.1. キャッシュのマッピング</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-readonly">21.2.2. read only 戦略</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-readwrite">21.2.3. read/write 戦略</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-nonstrict">21.2.4. 厳密ではない read/write 戦略</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-transactional">21.2.5. transactional 戦略</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-compat-matrix">21.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-sessioncache">21.3. キャッシュの管理</a></span></dt><dt><span class="section"><a href="performance.html#performance-querycache">21.4. クエリキャッシュ</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-querycache-enable">21.4.1. Enabling query caching</a></span></dt><dt><span class="section"><a href="performance.html#performance-querycache-regions">21.4.2. Query cache regions</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-collections">21.5. コレクションのパフォーマンスの理解</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-collections-taxonomy">21.5.1. 分類</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-mostefficientupdate">21.5.2. 更新にもっとも効率的なコレクション list、map、idbag、set</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-mostefficentinverse">21.5.3. inverse コレクションにもっとも最適な bag と list</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-oneshotdelete">21.5.4. 一括削除</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-monitoring">21.6. パフォーマンスのモニタリング</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-monitoring-sf">21.6.1. SessionFactory のモニタリング</a></span></dt><dt><span class="section"><a href="performance.html#performance-monitoring-metrics">21.6.2. メトリクス</a></span></dt></dl></dd></dl></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>21.1. フェッチ戦略</h2></div></div></div><p><span class="emphasis"><em>フェッチ戦略</em></span> は、アプリケーションが関連をナビゲートする必要があるときに、 Hibernate が関連オブジェクトを復元するために使用する戦略です。フェッチ戦略は O/R マッピングのメタデータに宣言するか、特定の HQL 、 <code class="literal">Criteria</code> クエリでオーバーライドします。</p><p>Hibernate3 は次に示すフェッチ戦略を定義しています:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>結合フェッチ</em></span> - Hibernate は <code class="literal">OUTER JOIN</code> を使って、関連するインスタンスやコレクションを１つの <code class="literal">SELECT</code> で復元します。</p></li><li><p><span class="emphasis"><em>セレクトフェッチ</em></span> - 2回目の <code class="literal">SELECT</code> で関連するエンティティやコレクションを復元します。 <code class="literal">lazy="false"</code> で明示的に遅延フェッチを無効にしなければ、この2回目の select は実際に関連にアクセスしたときのみ実行されるでしょう。</p></li><li><p><span class="emphasis"><em>サブセレクトフェッチ</em></span> - 2回目の <code class="literal">SELECT</code> で、直前のクエリやフェッチで復元したすべての要素に関連するコレクションを復元します。 <code class="literal">lazy="false"</code> で明示的に遅延フェッチを無効にしなければ、この2回目の select は実際に関連にアクセスしたときのみ実行されるでしょう。</p></li><li><p><span class="emphasis"><em>バッチフェッチ</em></span> - セレクトフェッチのための最適化された戦略 - Hibernate はエンティティのインスタンスやコレクションの一群を1回の <code class="literal">SELECT</code> で復元します。これは主キーや外部キーのリストを指定することにより行います。</p></li></ul></div><p>Hibernate は次に示す戦略とも区別をします: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>即時フェッチ</em></span> - 所有者のオブジェクトがロードされたときに、関連、コレクションは即時にフェッチされます。</p></li><li><p><span class="emphasis"><em>遅延コレクションフェッチ</em></span> - アプリケーションがコレクションに対して操作を行ったときにコレクションをフェッチします。(これはコレクションに対するデフォルトの動作です)</p></li><li><p><span class="emphasis"><em>「特別な遅延」コレクションフェッチ</em></span> - コレクションの要素１つ１つが独立して、必要なときにデータベースから取得されます。 Hibernate は必要ないならば、コレクション全体をメモリにフェッチすることは避けます（とても大きなコレクションに適しています）。</p></li><li><p><span class="emphasis"><em>プロキシフェッチ</em></span> - 単一値関連は、識別子の getter 以外のメソッドが関連オブジェクトで呼び出されるときにフェッチされます。</p></li><li><p><span class="emphasis"><em>「プロキシなし」フェッチ</em></span> - 単一値関連は、インスタンス変数にアクセスされたときにフェッチされます。プロキシフェッチと比較すると、この方法は遅延の度合いが少ない（関連は識別子にアクセスしただけでもフェッチされます）ですが、より透過的で、アプリケーションにプロキシが存在しないように見せます。この方法はビルド時のバイトコード組み込みが必要になり、使う場面はまれです。</p></li><li><p><span class="emphasis"><em>遅延属性フェッチ</em></span> - 属性や単一値関連は、インスタンス変数にアクセスしたときにフェッチされます。この方法はビルド時のバイトコード組み込みが必要になり、使う場面はまれです。</p></li></ul></div><p>二つの直行する概念があります: <span class="emphasis"><em>いつ</em></span> 関連をフェッチするか、そして、 <span class="emphasis"><em>どうやって</em></span> フェッチするか（どんな SQL を使って）。これらを混同しないでください。 <code class="literal">fetch</code> はパフォーマンスチューニングに使います。 <code class="literal">lazy</code> はあるクラスの分離されたインスタンスのうち、どのデータを常に使用可能にするかの取り決めを定義します。</p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>21.1.1. 遅延関連の働き</h3></div></div></div><p>デフォルトでは、 Hibernate3 はコレクションに対しては遅延セレクトフェッチを使い、単一値関連には遅延プロキシフェッチを使います。これらのデフォルト動作はほぼすべてのアプリケーションのほぼすべての関連で意味があります。</p><p><span class="emphasis"><em>注:</em></span><code class="literal">hibernate.default_batch_fetch_size</code> をセットしたときは、 Hibernate は遅延フェッチのためのバッチフェッチ最適化を使うでしょう（この最適化はより細かいレベルで有効にすることも出来ます）。</p><p>しかし、遅延フェッチは知っておかなければならない一つの問題があります。 Hibernate の session をオープンしているコンテキストの外から遅延関連にアクセスすると、例外が発生します。例：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">s&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessions</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">openSession</span><!-- <br/> --><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_type">User</span><span class="java_plain">&nbsp;u&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">User</span><span class="java_separator">)</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;from&nbsp;User&nbsp;u&nbsp;where&nbsp;u.name=:userName&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setString</span><span class="java_separator">(</span><span class="java_literal">&quot;userName&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;userName</span><span class="java_separator">).</span><span class="java_plain">uniqueResult</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Map</span><span class="java_plain">&nbsp;permissions&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;u</span><span class="java_separator">.</span><span class="java_plain">getPermissions</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">s</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">Integer</span><span class="java_plain">&nbsp;accessLevel&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Integer</span><span class="java_separator">)</span><span class="java_plain">&nbsp;permissions</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">&quot;accounts&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Error</span><span class="java_operator">!</span></pre><p><code class="literal">Session</code> がクローズされたとき、 permissions コレクションは初期化されていないため、このコレクションは自身の状態をロードできません。 <span class="emphasis"><em>Hibernate は切り離されたオブジェクトの遅延初期化はサポートしていません</em></span> 。修正方法として、コレクションから読み込みを行うコードをトランザクションをコミットする直前に移動させます。</p><p>一方で、 <code class="literal">lazy="false"</code> を関連マッピングに指定することで、遅延処理をしないコレクションや関連を使うことが出来ます。しかしながら、遅延初期化はほぼすべてのコレクションや関連で使われることを意図しています。もしあなたのオブジェクトモデルの中に遅延処理をしない関連を多く定義してしまうと、 Hibernate は最終的にはトランザクション毎にほぼ完全なデータベースをメモリの中にフェッチすることになるでしょう。</p><p>他方では、特定のトランザクションにおいてセレクトフェッチの代わりに結合フェッチ（当然これは遅延処理ではなくなります）を選択したいことが時々あります。これからフェッチ戦略をカスタマイズする方法をお見せします。 Hibernate3 では、フェッチ戦略を選択する仕組みは単一値関連とコレクションで変わりはありません。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>21.1.2. フェッチ戦略のチューニング</h3></div></div></div><p>セレクトフェッチ（デフォルト）は N+1 セレクト問題という大きな弱点があるため、マッピング定義で結合フェッチを有効にすることができます:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;permissions&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">fetch</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;userId&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Permission&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;mother&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">fetch</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>マッピング定義で定義した <code class="literal">フェッチ</code> 戦略は次のものに影響します:</p><div class="itemizedlist"><ul><li><p><code class="literal">get()</code> や <code class="literal">load()</code> による復元</p></li><li><p>関連にナビゲートしたときに発生する暗黙的な復元</p></li><li><p><code class="literal">Criteria</code> クエリ</p></li><li><p><code class="literal">サブセレクト</code> フェッチを使う HQL クエリ</p></li></ul></div><p>たとえどんなフェッチ戦略を使ったとしても、遅延ではないグラフはメモリに読み込まれることが保証されます。つまり、特定の HQL クエリを実行するためにいくつかの SELECT 文が即時実行されることがあるので注意してください。</p><p>通常は、マッピング定義でフェッチのカスタマイズは行いません。代わりに、デフォルトの動作のままにしておいて、 HQL で <code class="literal">left join fetch</code> を指定することで特定のトランザクションで動作をオーバーライドします。これは Hibernate に初回のセレクトで外部結合を使って関連を先にフェッチするように指定しています。 <code class="literal">Criteria</code> クエリの API では、 <code class="literal">setFetchMode(FetchMode.JOIN)</code> を使うことが出来ます。</p><p>もし <code class="literal">get()</code> や <code class="literal">load()</code> で使われるフェッチ戦略を変えたいと感じたときには、単純に <code class="literal">Criteria</code> クエリを使ってください。例：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_plain">&nbsp;user&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createCriteria</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setFetchMode</span><span class="java_separator">(</span><span class="java_literal">&quot;permissions&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">FetchMode</span><span class="java_separator">.</span><span class="java_plain">JOIN</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Restrictions</span><span class="java_separator">.</span><span class="java_plain">idEq</span><span class="java_separator">(</span><span class="java_plain">userId</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">uniqueResult</span><span class="java_separator">();</span></pre><p>（これはいくつかの ORM ソリューションが "fetch plan" と呼んでいるものと同じです。）</p><p>N+1 セレクト問題を避けるためのまったく違う方法は、第2レベルキャッシュを使うことです。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>21.1.3. 単一端関連プロキシ</h3></div></div></div><p>コレクションの遅延フェッチは、 Hibernate 自身の実装による永続コレクションを使って実現しています。しかし、単一端関連における遅延処理では、違う仕組みが必要です。対象の関連エンティティはプロキシでなければなりません。 Hibernate は（すばらしい CGLIB ライブラリによる）実行時のバイトコード拡張を使って永続オブジェクトの遅延初期化プロキシを実現しています。</p><p>デフォルトでは、 Hibernate3 は（開始時に）すべての永続クラスのプロキシを生成し、それらを使って、 <code class="literal">many-to-one</code> や <code class="literal">one-to-one</code> 関連の遅延フェッチを可能にしています。</p><p>マッピングファイルで <code class="literal">proxy</code> 属性によって、クラスのプロキシインターフェースとして使うインターフェースを宣言できます。デフォルトでは、 Hibernate はそのクラスのサブクラスを使います。 <span class="emphasis"><em>プロキシクラスは少なくともパッケージ可視でデフォルトコンストラクタを実装しなければならないことに注意してください。すべての永続クラスにこのコンストラクタを推奨します。</em></span></p><p>ポリモーフィズムのクラスに対してこの方法を適用するときにいくつか考慮することがあります。例：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>第一に、 <code class="literal">Cat</code> のインスタンスは <code class="literal">DomesticCat</code> にキャストできません。たとえ基となるインスタンスが <code class="literal">DomesticCat</code> であったとしてもです:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;instantiate&nbsp;a&nbsp;proxy&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">does&nbsp;not&nbsp;hit&nbsp;the&nbsp;db</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cat</span><span class="java_separator">.</span><span class="java_plain">isDomesticCat</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;hit&nbsp;the&nbsp;db&nbsp;to&nbsp;initialize&nbsp;the&nbsp;proxy</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;dc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cat</span><span class="java_separator">;</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Error</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">....</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>第二に、プロキシの <code class="literal">==</code> は成立しないことがあります。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;instantiate&nbsp;a&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;proxy</span>
<!--  --><br/><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;dc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;id</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;acquire&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;proxy</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_operator">==</span><span class="java_plain">dc</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span></pre><p>しかし、これは見かけほど悪い状況というわけではありません。たとえ異なったプロキシオブジェクトへの二つの参照があったとしても、基となるインスタンスは同じオブジェクトです:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">setWeight</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">11.0</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;hit&nbsp;the&nbsp;db&nbsp;to&nbsp;initialize&nbsp;the&nbsp;proxy</span>
<!--  --><br/><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">&nbsp;dc</span><span class="java_separator">.</span><span class="java_plain">getWeight</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_literal">11.0</span></pre><p>第三に、 <code class="literal">final</code> クラスや <code class="literal">final</code> メソッドを持つクラスに CGLIB プロキシを使えません。</p><p>最後に、もし永続オブジェクトのインスタンス化時 (例えば、初期化処理やデフォルトコンストラクタの中で) になんらかのリソースが必要となるなら、そのリソースもまたプロキシを通して取得されます。実際には、プロキシクラスは永続クラスのサブクラスです。</p><p>これらの問題は Java の単一継承モデルの原理上の制限のためです。もしこれらの問題を避けたいのなら、ビジネスメソッドを宣言したインターフェースをそれぞれ永続クラスで実装しなければなりません。マッピングファイルでこれらのインターフェースを指定する必要があります。例：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CatImpl&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCatImpl&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Then proxies for instances of <code class="literal">Cat</code> and <code class="literal">DomesticCat</code> can be returned by <code class="literal">load()</code> or <code class="literal">iterate()</code>.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">CatImpl</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Iterator</span><span class="java_plain">&nbsp;iter&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;from&nbsp;CatImpl&nbsp;as&nbsp;cat&nbsp;where&nbsp;cat.name='fritz'&quot;</span><span class="java_separator">).</span><span class="java_plain">iterate</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Cat</span><span class="java_plain">&nbsp;fritz&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;iter</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">();</span></pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">list()</code> does not usually return proxies.</p></div><p>関連も遅延初期化されます。これはプロパティを <code class="literal">Cat</code> 型で宣言しなければならないことを意味します。 <code class="literal">CatImpl</code> ではありません。</p><p>プロキシの初期化を <span class="emphasis"><em>必要としない</em></span> 操作も存在します。</p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code> （永続クラスが <code class="literal">equals()</code> をオーバーライドしないとき）</p></li><li><p><code class="literal">hashCode()</code> （永続クラスが <code class="literal">hashCode()</code> をオーバーライドしないとき）</p></li><li><p>識別子の getter メソッド</p></li></ul></div><p>Hibernate は <code class="literal">equals()</code> や <code class="literal">hashCode()</code> をオーバーライドした永続クラスを検出します。</p><p>デフォルトの <code class="literal">lazy="proxy"</code> の代わりに、 <code class="literal">lazy="no-proxy"</code> を選んだことで、型変換に関連する問題を回避することが出来ます。しかし、ビルド時のバイトコード組み込みが必要になり、どのような操作であっても、ただちにプロキシの初期化を行うことになるでしょう。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>21.1.4. コレクションとプロキシの初期化</h3></div></div></div><p><code class="literal">LazyInitializationException</code> は、 <code class="literal">Session</code> のスコープ外から初期化していないコレクションやプロキシにアクセスされたときに、 Hibernate によってスローされます。すなわち、コレクションやプロキシへの参照を持つエンティティが分離された状態の時です。</p><p><code class="literal">Session</code> をクローズする前にプロキシやコレクションの初期化を確実に行いたいときがあります。もちろん、 <code class="literal">cat.getSex()</code> や <code class="literal">cat.getKittens().size()</code> などを常に呼び出すことで初期化を強制することはできます。しかしこれはコードを読む人を混乱させ、汎用的なコードという点からも不便です。</p><p>static メソッドの <code class="literal">Hibernate.initialize()</code> や <code class="literal">Hibernate.isInitialized()</code> は遅延初期化のコレクションやプロキシを扱うときに便利な方法をアプリケーションに提供します。 <code class="literal">Hibernate.initialize(cat)</code> は、 <code class="literal">Session</code> がオープンしている限りは <code class="literal">cat</code> プロキシを強制的に初期化します。 <code class="literal">Hibernate.initialize( cat.getKittens() )</code> は kittens コレクションに対して同様の効果があります。</p><p>別の選択肢として、必要なすべてのコレクションやプロキシがロードされるまで <code class="literal">Session</code> をオープンにしておく方法があります。いくつかのアプリケーションのアーキテクチャでは、特に Hibernate によるデータアクセスを行うコードと、それを使うコードが異なるアプリケーションのレイヤーや、物理的に異なるプロセッサのときには、コレクションが初期化されるときに <code class="literal">Session</code> がオープンしていることを保証する問題があります。この問題に対しては2つの基本的な方法があります:</p><div class="itemizedlist"><ul><li><p>Web ベースのアプリケーションでは、ビューのレンダリングが完了し、リクエストが終わる一番最後で <code class="literal">Session</code> をクローズするために、サーブレットフィルタを使うことができます（ <span class="emphasis"><em>Open Session in View</em></span> パターンです）。もちろん、アプリケーション基盤の例外処理の正確性が非常に重要になります。ビューのレンダリング中に例外が発生したときでさえ、ユーザーに処理が戻る前に <code class="literal">Session</code> のクローズとトランザクションの終了を行うことが不可欠になります。 Hibernate の Wiki に載っている "Open Session in View" パターンの例を参照してください。</p></li><li><p>ビジネス層が分離しているアプリケーションでは、ビジネスロジックは Web 層で必要になるすべてのコレクションを事前に「準備」する必要があります。これは特定のユースケースで必要となるプレゼンテーション/ Web 層に対し、ビジネス層がすべてのデータをロードし、すべてのデータを初期化して返すべきということを意味しています。通常は、アプリケーションは Web 層で必要なコレクションそれぞれに対して <code class="literal">Hibernate.initialize()</code> を呼び出すか（この呼び出しはセッションをクローズする前に行う必要があります）、 Hibernate クエリの <code class="literal">FETCH</code> 節や <code class="literal">Criteria</code> の <code class="literal">FetchMode.JOIN</code> を使ってコレクションを先に復元します。普通は <span class="emphasis"><em>Session Facade</em></span> パターンの代わりに <span class="emphasis"><em>Command</em></span> パターンを採用するほうがより簡単です。</p></li><li><p>初期化されていないコレクション（もしくは他のプロキシ）にアクセスする前に、 <code class="literal">merge()</code> や <code class="literal">lock()</code> を使って新しい <code class="literal">Session</code> に以前にロードされたオブジェクトを追加することも出来ます。アドホックなトランザクションのセマンティクスを導入したので、 Hibernate はこれを自動的に行わず、 <span class="emphasis"><em>行うべきでもありません</em></span> 。</p></li></ul></div><p>大きなコレクションを初期化したくはないが、コレクションについてのなんらかの情報（サイズのような）やデータのサブセットを必要とすることがあります。</p><p>コレクションフィルタを使うことで、初期化せずにコレクションのサイズを取得することが出来ます：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">list</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">get</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">0</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p><code class="literal">createFilter()</code> メソッドは、コレクション全体を初期化する必要なしに、コレクションのサブセットを復元するために効果的に使えます:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;lazyCollection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">setFirstResult</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">0</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">setMaxResults</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">10</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">list</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>21.1.5. バッチフェッチの使用</h3></div></div></div><p>Hibernate はバッチフェッチを効率的に使用できます。一つのプロキシ（もしくはコレクション）がアクセスされると、 Hibernate はいくつかの初期化していないプロキシをロードすることができます。バッチフェッチは遅延セレクトフェッチ戦略に対する最適化です。バッチフェッチの調整には２つの方法があります。クラスレベルとコレクションレベルです。</p><p>クラス、要素のバッチフェッチは理解が簡単です。実行時の次の場面を想像してください。 <code class="literal">Session</code> にロードされた25個の <code class="literal">Cat</code> インスタンスが存在し、それぞれの <code class="literal">Cat</code> は <code class="literal">owner</code> である <code class="literal">Person</code> への関連を持ちます。 <code class="literal">Person</code> クラスは <code class="literal">lazy="true"</code> のプロキシでマッピングされています。もし今すべての Cat に対して繰り返し <code class="literal">getOwner()</code> を呼び出すと、 Hibernate はデフォルトでは25回の <code class="literal">SELECT</code> を実し、 owner プロキシの復元をします。この振る舞いを <code class="literal">Person</code> のマッピングの <code class="literal">batch-size</code> の指定で調整できます。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">batch-size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;10&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">...</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Hibernate はクエリを３回だけを実行するようになります。パターンは 10, 10, 5 です。</p><p>コレクションのバッチフェッチも有効にすることが出来ます。例として、それぞれの <code class="literal">Person</code> が <code class="literal">Cat</code> の遅延コレクションを持っており、 10 個の Person が <code class="literal">Sesssion</code> にロードされたとすると、すべての Person に対して繰り返し <code class="literal">getCats()</code> を呼び出すことで、計10回の <code class="literal">SELECT</code> が発生します。もし <code class="literal">Person</code> のマッピングで <code class="literal">cats</code> コレクションのバッチフェッチを有効にすれば、 Hibernate はコレクションの事前フェッチが出来ます。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cats&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">batch-size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;3&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p><code class="literal">batch-size</code> が 3 なので、 Hibernate は 4 回の <code class="literal">SELECT</code> で 3 個、 3 個、 3 個、 1 個をロードします。繰り返すと、属性の値は特定の <code class="literal">Session</code> の中の初期化されていないコレクションの期待数に依存します。</p><p>コレクションのバッチフェッチはアイテムのネストしたツリー、すなわち、代表的な部品表のパターンがある場合に特に有用です。（しかし、読み込みが多いツリーでは <span class="emphasis"><em>ネストした set</em></span> や <span class="emphasis"><em>具体化したパス</em></span> がよりよい選択になります。）</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>21.1.6. サブセレクトフェッチの使用</h3></div></div></div><p>一つの遅延コレクションや単一値プロキシがフェッチされなければいけないとき、 Hibernate はそれらすべてをロードし、サブセレクトのオリジナルクエリが再度実行されます。これはバッチフェッチと同じ方法で動き、少しずつのロードは行いません。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-profiles"/>21.1.7. Fetch profiles</h3></div></div></div><p>Another way to affect the fetching strategy for loading associated objects is through something called a fetch profile, which is a named configuration associated with the <code class="interfacename">org.hibernate.SessionFactory</code> but enabled, by name, on the <code class="interfacename">org.hibernate.Session</code>. Once enabled on a <code class="interfacename">org.hibernate.Session</code>, the fetch profile will be in affect for that <code class="interfacename">org.hibernate.Session</code> until it is explicitly disabled.</p><p>So what does that mean? Well lets explain that by way of an example which show the different available approaches to configure a fetch profile:</p><div class="example"><a id="d0e18659"/><p class="title"><b>例21.1 Specifying a fetch profile using <code class="classname">@FetchProfile</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">@Entity</span><br />
<span class="xml_plain">@FetchProfile(name&nbsp;=&nbsp;&quot;customer-with-orders&quot;,&nbsp;fetchOverrides&nbsp;=&nbsp;{</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@FetchProfile.FetchOverride(entity&nbsp;=&nbsp;Customer.class,&nbsp;association&nbsp;=&nbsp;&quot;orders&quot;,&nbsp;mode&nbsp;=&nbsp;FetchMode.JOIN)</span><br />
<span class="xml_plain">})</span><br />
<span class="xml_plain">public&nbsp;class&nbsp;Customer&nbsp;{</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@Id</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@GeneratedValue</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;id;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;customerNumber;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@OneToMany</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;Set</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">Order</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;orders;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;//&nbsp;standard&nbsp;getter/setter</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">}</span><br />
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e18666"/><p class="title"><b>例21.2 Specifying a fetch profile using <code class="literal">&lt;fetch-profile&gt;</code> outside <code class="literal">&lt;class&gt;</code> node</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cust_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch-profile</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;customer-with-orders&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">entity</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">association</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">style</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetch-profile</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e18677"/><p class="title"><b>例21.3 Specifying a fetch profile using <code class="literal">&lt;fetch-profile&gt;</code> inside <code class="literal">&lt;class&gt;</code> node</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cust_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch-profile</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;customer-with-orders&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">association</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">style</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetch-profile</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>Now normally when you get a reference to a particular customer, that customer's set of orders will be lazy meaning we will not yet have loaded those orders from the database. Normally this is a good thing. Now lets say that you have a certain use case where it is more efficient to load the customer and their orders together. One way certainly is to use "dynamic fetching" strategies via an HQL or criteria queries. But another option is to use a fetch profile to achieve that. The following code will load both the customer <span class="emphasis"><em>and</em></span>their orders:</p><div class="example"><a id="d0e18693"/><p class="title"><b>例21.4 Activating a fetch profile for a given <code class="classname">Session</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Session</span><!-- <br/> --><span class="java_plain">&nbsp;session&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">...;</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">enableFetchProfile</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;customer-with-orders&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;name&nbsp;matches&nbsp;from&nbsp;mapping</span>
<!--  --><br/><span class="java_type">Customer</span><span class="java_plain">&nbsp;customer&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Customer</span><span class="java_separator">)</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Customer</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;customerId&nbsp;</span><span class="java_separator">);</span>
</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p><code class="classname">@FetchProfile </code>definitions are global and it does not matter on which class you place them. You can place the <code class="classname">@FetchProfile</code> annotation either onto a class or package (package-info.java). In order to define multiple fetch profiles for the same class or package <code class="classname">@FetchProfiles</code> can be used.</p></div><p>Currently only join style fetch profiles are supported, but they plan is to support additional styles. See <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-3414">HHH-3414</a> for details.</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>21.1.8. 遅延プロパティフェッチの使用</h3></div></div></div><p>Hibernate3 はプロパティごとの遅延フェッチをサポートしています。この最適化手法は <span class="emphasis"><em>グループのフェッチ</em></span> としても知られています。これはほとんど要望から出た機能であることに注意してください。実際には列読み込みの最適化よりも、行読み込みの最適化が非常に重要です。しかし、クラスのいくつかのプロパティだけを読み込むことは、既存のテーブルが何百もの列を持ち、データモデルを改善できないなどの極端な場合には有用です。</p><p>遅延プロパティ読み込みを有効にするには、対象のプロパティのマッピングで <code class="literal">lazy</code> 属性をセットしてください:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Document&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;native&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;50&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;summary&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;200&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">lazy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;text&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;2000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">lazy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>遅延プロパティ読み込みはビルド時のバイトコード組み込みを必要とします。もし永続クラスに組み込みがされていないなら、 Hibernate は黙って遅延プロパティの設定を無視して、即時フェッチに戻します。</p><p>バイトコード組み込みは以下の Ant タスクを使ってください: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">target</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;instrument&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">depends</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;compile&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">taskdef</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;instrument&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">classname</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.tool.instrument.InstrumentTask&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">path</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${jar.path}&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">path</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${classes.dir}&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">refid</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;lib.class.path&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">taskdef</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">instrument</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">verbose</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fileset</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">dir</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${testclasses.dir}/org/hibernate/auction/model&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">include</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;*.class&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fileset</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">instrument</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">target</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>不要な列を読み込まないための、別の（よりよい？）方法は、少なくとも読み込みのみのトランザクションにおいては、 HQL や Criteria クエリの射影機能を使うことです。この方法はビルド時のバイトコード組み込みが不要になり、より良い解決方法です。</p><p>HQL で <code class="literal">fetch all properties</code> を使うことで、普通どおりのプロパティの即時フェッチングを強制することが出来ます。</p></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>21.2. 第2レベルキャッシュ</h2></div></div></div><p>Hibernate の <code class="literal">Session</code> は永続データのトランザクションレベルのキャッシュです。 class-by-class と collection-by-collection ごとの、クラスタレベルや JVM レベル （ <code class="literal">SessionFactory</code> レベル）のキャッシュを設定することが出来ます。クラスタ化されたキャッシュにつなぐことさえ出来ます。しかし注意してください。キャッシュは他のアプリケーションによる永続層の変更を考慮しません（キャッシュデータを定期的に期限切れにする設定は出来ます）。</p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed in <a class="xref" href="performance.html#cacheproviders" title="表21.1 キャッシュプロバイダ">表21.1「キャッシュプロバイダ」</a>. You can also implement your own and plug it in as outlined above. Note that versions prior to Hibernate 3.2 use EhCache as the default cache provider.</p><div class="table"><a id="cacheproviders"/><p class="title"><b>表21.1 キャッシュプロバイダ</b></p><div class="table-contents"><table summary="キャッシュプロバイダ" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">キャッシュ</th><th align="left">プロバイダクラス</th><th align="left">タイプ</th><th align="left">クラスタセーフ</th><th align="left">クエリキャッシュのサポート</th></tr></thead><tbody><tr><td align="left">Hashtable（製品用として意図していません）</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">メモリ</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">memory, disk, transactional, clustered</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">メモリ、ディスク</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">クラスタ（ip マルチキャスト）</td><td align="left">yes（クラスタ無効化）</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">クラスタ（ip マルチキャスト）、トランザクショナル</td><td align="left">yes（複製）</td><td align="left">yes（時刻同期が必要）</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc.JBossCacheRegionFactory</code></td><td align="left">クラスタ（ip マルチキャスト）、トランザクショナル</td><td align="left">yes (replication or invalidation)</td><td align="left">yes（時刻同期が必要）</td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>21.2.1. キャッシュのマッピング</h3></div></div></div><p>As we have done in previous chapters we are looking at the two different possibiltites to configure caching. First configuration via annotations and then via Hibernate mapping files.</p><p>By default, entities are not part of the second level cache and we recommend you to stick to this setting. However, you can override this by setting the <code class="literal">shared-cache-mode</code> element in your <code class="filename">persistence.xml</code> file or by using the <code class="literal">javax.persistence.sharedCache.mode </code>property in your configuration. The following values are possible:</p><div class="itemizedlist"><ul><li><p><code class="literal">ENABLE_SELECTIVE</code> (Default and recommended value): entities are not cached unless explicitly marked as cacheable.</p></li><li><p><code class="literal">DISABLE_SELECTIVE</code>: entities are cached unless explicitly marked as not cacheable.</p></li><li><p><code class="literal">ALL</code>: all entities are always cached even if marked as non cacheable.</p></li><li><p><code class="literal">NONE</code>: no entity are cached even if marked as cacheable. This option can make sense to disable second-level cache altogether.</p></li></ul></div><p>The cache concurrency strategy used by default can be set globaly via the <code class="literal">hibernate.cache.default_cache_concurrency_strategy</code> configuration property. The values for this property are:</p><div class="itemizedlist"><ul><li><p><code class="literal">read-only</code></p></li><li><p><code class="literal">read-write</code></p></li><li><p><code class="literal">nonstrict-read-write</code></p></li><li><p><code class="literal">transactional</code></p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>It is recommended to define the cache concurrency strategy per entity rather than using a global one. Use the <code class="classname">@org.hibernate.annotations.Cache</code> annotation for that.</p></div><div class="example"><a id="example-cache-concurrency-with-cache-annotation"/><p class="title"><b>例21.5 Definition of cache concurrency strategy via <code class="classname">@Cache</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Entity</span><!-- <br/> --><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cacheable</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">Forest</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>Hibernate also let's you cache the content of a collection or the identifiers if the collection contains other entities. Use the <code class="classname">@Cache</code> annotation on the collection property.</p><div class="example"><a id="d0e18933"/><p class="title"><b>例21.6 Caching collections using annotations</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">OneToMany</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">cascade</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">CascadeType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">ALL</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;fetch</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">FetchType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">EAGER</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">JoinColumn</span><span class="java_separator">(</span><span class="java_plain">name</span><span class="java_operator">=</span><span class="java_literal">&quot;CUST_ID&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">SortedSet</span><span class="java_operator">&lt;</span><span class="java_type">Ticket</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;getTickets</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;tickets</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p><a class="xref" href="performance.html#example-cache-annotation-with-attributes" title="例21.7 @Cache annotation with attributes">例21.7「@Cache annotation with attributes」</a>shows the<code class="literal"> @org.hibernate.annotations.Cache</code> annotations with its attributes. It allows you to define the caching strategy and region of a given second level cache.</p><div class="example"><a id="example-cache-annotation-with-attributes"/><p class="title"><b>例21.7 <code class="classname">@Cache</code> annotation with attributes</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">@Cache(
    CacheConcu<span xmlns="" class="co" id="cache-hm1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>rrencyStrategy usage();
    String reg<span xmlns="" class="co" id="cache-hm2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>ion() default "";
    String inc<span xmlns="" class="co" id="cache-hm3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>lude() default "all";
)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>usage: the given cache concurrency strategy (NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>region (optional): the cache region (default to the fqcn of the class or the fq role name of the collection)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code> (optional): all to include all properties, non-lazy to only include non lazy properties (default all).</p></td></tr></table></div></div></div></div><br class="example-break"/><p>Let's now take a look at Hibernate mapping files. There the <code class="literal">&lt;cache&gt;</code> element of a class or collection mapping is used to configure the second level cache. Looking at <a class="xref" href="performance.html#example-hibernate-cache-mapping-element" title="例21.8 The Hibernate &lt;cache&gt; mapping element">例21.8「The Hibernate &lt;cache&gt; mapping element」</a> the parallels to anotations is obvious.</p><div class="example"><a id="example-hibernate-cache-mapping-element"/><p class="title"><b>例21.8 The Hibernate <code class="literal">&lt;cache&gt;</code> mapping element</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">&lt;cache
    usage="tra<span xmlns="" class="co" id="cache1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>nsactional|read-write|nonstrict-read-write|read-only"
    region="Re<span xmlns="" class="co" id="cache2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>gionName"
    include="a<span xmlns="" class="co" id="cache3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>ll|non-lazy"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">usage</code> (必須) キャッシング戦略を指定します： <code class="literal">transactional</code>、 <code class="literal">read-write</code>、 <code class="literal">nonstrict-read-write</code> または <code class="literal">read-only</code></p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">region</code> (オプション、クラスまたはコレクションのロールネームのデフォルト) 2次レベルのキャッシュ領域の名前を指定します</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code> (オプション、 <code class="literal">all</code> に対してデフォルト) <code class="literal">non-lazy</code> は、 属性レベルの lazy フェチが有効になっている場合 <code class="literal">lazy="true"</code> でマッピングされるエンティティのプロパティはキャッシュされなくてもよいことを指定します。</p></td></tr></table></div></div></div></div><br class="example-break"/><p>Alternatively to <code class="literal">&lt;cache&gt;</code>, you can use <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>.</p><p>Let's now have a closer look at the different usage strategies</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>21.2.2. read only 戦略</h3></div></div></div><p>もしアプリケーションが読み込みのみ必要で、永続クラスのインスタンスを変更しないなら、 <code class="literal">read-only</code> キャッシュを使うことが出来ます。これはもっとも単純でもっともパフォーマンスの良い戦略です。クラスタでの使用も完全に安全です。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>21.2.3. read/write 戦略</h3></div></div></div><p>アプリケーションがデータを更新する必要があるなら、 <code class="literal">read-write</code> キャッシュが適当かもしれません。このキャッシュ戦略は、シリアライザブルなトランザクション分離レベルが要求されるなら、決して使うべきではありません。もしキャッシュが JTA 環境で使われるなら、 JTA <code class="literal">TransactionManager</code> を取得するための方法を示す <code class="literal">hibernate.transaction.manager_lookup_class</code> プロパティを指定しなければなりません。他の環境では、 <code class="literal">Session.close()</code> や <code class="literal">Session.disconnect()</code> が呼ばれたときに、確実にトランザクションが完了していなければなりません。もしクラスタでこの戦略を使いたいなら、基となるキャッシュの実装がロックをサポートしていることを保証しなければなりません。組み込みのキャッシュプロバイダは <span class="emphasis"><em>サポートしていません</em></span> 。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>21.2.4. 厳密ではない read/write 戦略</h3></div></div></div><p>アプリケーションがたまにしかデータを更新する必要はなく（すなわち二つのトランザクションが同時に同じアイテムを更新しようとすることはほとんど起こらない）、厳密なトランザクション分離が要求されないなら、 <code class="literal">nonstrict-read-write</code> キャッシュが適当かもしれません。もしキャッシュが JTA 環境で使われるなら、 <code class="literal">hibernate.transaction.manager_lookup_class</code> を指定しなければなりません。他の環境では、 <code class="literal">Session.close()</code> や <code class="literal">Session.disconnect()</code> が呼ばれたときに、確実にトランザクションが完了していなければなりません。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>21.2.5. transactional 戦略</h3></div></div></div><p><code class="literal">transactional</code> キャッシュ戦略は JBoss TreeCache のような完全なトランザクショナルキャッシュプロバイダのサポートを提供します。このようなキャッシュは JTA 環境でのみ使用可能で、 <code class="literal">hibernate.transaction.manager_lookup_class</code> を指定しなければなりません。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>21.2.6. Cache-provider/concurrency-strategy compatibility</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>すべての同時並行性キャッシュ戦略をサポートしているキャッシュプロバイダはありません。</p></div><p>以下の表はどのプロバイダがどの同時並列性戦略に対応するかを表しています。</p><div class="table"><a id="d0e19106"/><p class="title"><b>表21.2 同時並行性キャッシュ戦略のサポート</b></p><div class="table-contents"><table summary="同時並行性キャッシュ戦略のサポート" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">キャッシュ</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable（製品用として意図していません）</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>21.3. キャッシュの管理</h2></div></div></div><p>オブジェクトを <code class="literal">save()</code> 、 <code class="literal">update()</code> 、 <code class="literal">saveOrUpdate()</code> に渡すとき、そして <code class="literal">load()</code> 、 <code class="literal">get()</code> 、 <code class="literal">list()</code> 、 <code class="literal">iterate()</code> 、 <code class="literal">scroll()</code> を使ってオブジェクトを復元するときには常に、そのオブジェクトは <code class="literal">Session</code> の内部キャッシュに追加されます。</p><p>次に <code class="literal">flush()</code> が呼ばれると、オブジェクトの状態はデータベースと同期化されます。もしこの同期が起こることを望まないときや、膨大な数のオブジェクトを処理していてメモリを効率的に扱う必要があるときは、 <code class="literal">evict()</code> メソッドを使って一次キャッシュからオブジェクトやコレクションを削除することが出来ます。</p><div class="example"><a id="d0e19226"/><p class="title"><b>例21.9 Explcitly evicting a cached instance from the first level cache using <code class="methodname">Session.evict()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">ScrollableResult</span><!-- <br/> --><span class="java_plain">&nbsp;cats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Cat&nbsp;as&nbsp;cat&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">scroll</span><!-- <br/> --><span class="java_separator">();</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">a&nbsp;huge&nbsp;result&nbsp;set</span>
<!--  --><br/><span class="java_keyword">while</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;cat&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">0</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWithACat</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p><code class="literal">Session</code> はインスタンスがセッションキャッシュに含まれるかどうかを判断するための <code class="literal">contains()</code> メソッドも提供します。</p><p>すべてのオブジェクトをセッションキャッシュから完全に取り除くには、 <code class="literal">Session.clear()</code> を呼び出してください。</p><p>二次キャッシュのために、 <code class="literal">SessionFactory</code> にはインスタンス、クラス全体、コレクションのインスタンス、コレクション全体をキャッシュから削除するためのメソッドがそれぞれ定義されています。</p><div class="example"><a id="d0e19250"/><p class="title"><b>例21.10 Second-level cache eviction via <code class="methodname">SessionFactoty.evict() </code>and <code class="methodname">SessionFacyory.evictCollection()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">evict</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catId</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;</span><span class="java_type">Cats</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;catId</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;collection&nbsp;of&nbsp;kittens</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;kitten&nbsp;collections</span></pre></div></div><br class="example-break"/><p><code class="literal">CacheMode</code> は特定のセッションが二次キャッシュとどのように相互作用するかを指定します。</p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code> - アイテムの読み込みと書き込みで二次キャッシュを使います</p></li><li><p><code class="literal">CacheMode.GET</code> - 読み込みは二次キャッシュから行いますが、データを更新した場合を除いて二次キャッシュに書き込みをしません。</p></li><li><p><code class="literal">CacheMode.PUT</code> - 二次キャッシュにアイテムを書き込みますが、読み込みには二次キャッシュを使いません。</p></li><li><p><code class="literal">CacheMode.REFRESH</code> - 二次キャッシュにアイテムを書き込みますが、読み込みには二次キャッシュを使わず、 <code class="literal">hibernate.cache.use_minimal_puts</code> の影響を受けずに、データベースから読み込むすべてのアイテムの二次キャッシュを強制的にリフレッシュします。</p></li></ul></div><p>二次キャッシュの内容やクエリキャッシュ領域を見るために、 <code class="literal">Statistics</code> API を使ってください:</p><div class="example"><a id="d0e19293"/><p class="title"><b>例21.11 Browsing the second-level cache entries via the <code class="classname">Statistics</code> API</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Map</span><!-- <br/> --><span class="java_plain">&nbsp;cacheEntries&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getSecondLevelCacheStatistics</span><span class="java_separator">(</span><span class="java_plain">regionName</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getEntries</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>統計情報を有効にして、さらにオプションとして、キャッシュエントリを人がより理解可能な形式で保持することを Hibernate に強制します:</p><div class="example"><a id="d0e19303"/><p class="title"><b>例21.12 Enabling Hibernate statistics</b></p><div class="example-contents"><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div></div><br class="example-break"/></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>21.4. クエリキャッシュ</h2></div></div></div><p>Query result sets can also be cached. This is only useful for queries that are run frequently with the same parameters.</p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-enable"/>21.4.1. Enabling query caching</h3></div></div></div><p>Caching of query results introduces some overhead in terms of your applications normal transactional processing. For example, if you cache results of a query against Person Hibernate will need to keep track of when those results should be invalidated because changes have been committed against Person. That, coupled with the fact that most applications simply gain no benefit from caching query results, leads Hibernate to disable caching of query results by default. To use query caching, you will first need to enable the query cache:</p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>This setting creates two new cache regions: </p><div class="itemizedlist"><ul><li><p><code class="classname">org.hibernate.cache.StandardQueryCache</code>, holding the cached query results</p></li><li><p><code class="classname">org.hibernate.cache.UpdateTimestampsCache</code>, holding timestamps of the most recent updates to queryable tables. These are used to validate the results as they are served from the query cache.</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>If you configure your underlying cache implementation to use expiry or timeouts is very important that the cache timeout of the underlying cache region for the UpdateTimestampsCache be set to a higher value than the timeouts of any of the query caches. In fact, we recommend that the the UpdateTimestampsCache region not be configured for expiry at all. Note, in particular, that an LRU cache expiry policy is never appropriate.</p></div><p>As mentioned above, most queries do not benefit from caching or their results. So by default, individual queries are not cached even after enabling query caching. To enable results caching for a particular query, call <code class="literal">org.hibernate.Query.setCacheable(true)</code>. This call allows the query to look for existing cache results or add its results to the cache when it is executed.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>The query cache does not cache the state of the actual entities in the cache; it caches only identifier values and results of value type. For this reaso, the query cache should always be used in conjunction with the second-level cache for those entities expected to be cached as part of a query result cache (just as with collection caching).</p></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-regions"/>21.4.2. Query cache regions</h3></div></div></div><p>クエリキャッシュの破棄ポリシーを細かく制御したいときは、 <code class="literal">Query.setCacheRegion()</code> を呼び出して特定のクエリに対するキャッシュ領域を指定することが出来ます。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">List</span><!-- <br/> --><span class="java_plain">&nbsp;blogs&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Blog&nbsp;blog&nbsp;where&nbsp;blog.blogger&nbsp;=&nbsp;:blogger&quot;</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setEntity</span><span class="java_separator">(</span><span class="java_literal">&quot;blogger&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;blogger</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_literal">15</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheable</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheRegion</span><span class="java_separator">(</span><span class="java_literal">&quot;frontpages&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>If you want to force the query cache to refresh one of its regions (disregard any cached results it finds there) you can use <code class="literal">org.hibernate.Query.setCacheMode(CacheMode.REFRESH)</code>. In conjunction with the region you have defined for the given query, Hibernate will selectively force the results cached in that particular region to be refreshed. This is particularly useful in cases where underlying data may have been updated via a separate process and is a far more efficient alternative to bulk eviction of the region via <code class="literal">org.hibernate.SessionFactory.evictQueries()</code>.</p></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>21.5. コレクションのパフォーマンスの理解</h2></div></div></div><p>In the previous sections we have covered collections and their applications. In this section we explore some more issues in relation to collections at runtime.</p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>21.5.1. 分類</h3></div></div></div><p>Hibernate は3つの基本的なコレクションの種類を定義しています:</p><div class="itemizedlist"><ul><li><p>値のコレクション</p></li><li><p>一対多関連</p></li><li><p>多対多関連</p></li></ul></div><p>この分類はさまざまなテーブルや外部キー関連を区別しますが、私たちが知る必要のある関連モデルについてほとんどなにも教えてくれません。関連構造やパフォーマンスの特徴を完全に理解するには、 Hibernate がコレクションの行を更新、削除するために使う主キーの構造もまた考えなければなりません。これは以下の分類を提示します。</p><div class="itemizedlist"><ul><li><p>インデックス付きコレクション</p></li><li><p>set</p></li><li><p>bag</p></li></ul></div><p>すべてのインデックス付きコレクション （マップ、リスト、配列） は <code class="literal">&lt;key&gt;</code> と <code class="literal">&lt;index&gt;</code> カラムからなる主キーを持っています。この場合はコレクションの更新は非常に効率的です。主キーは有用なインデックスになり、 Hibernate が特定の行を更新または削除するときに、その行を効率的に見つけることができます。</p><p>set は <code class="literal">&lt;key&gt;</code> からなる主キーと要素のカラムを持っています。これはコレクション要素のいくつかの型については効率的ではないかもしれません。特に複合要素、大きなテキスト、バイナリフィールドでは非効率です。データベースは複合主キーに効率的にインデックスを付けることができないからです。一方、一対多や多対多関連において、特に人工識別子の場合は同じぐらい効率的です。（余談： <code class="literal">SchemaExport</code> で実際に <code class="literal">&lt;set&gt;</code> の主キーを作りたいなら、すべてのカラムで <code class="literal">not-null="true"</code> を宣言しなければなりません。）</p><p><code class="literal">&lt;idbag&gt;</code> マッピングは代理キーを定義します。そのため更新は常に非常に効率的です。事実上、これは最善のケースです。</p><p>bag は最悪のケースです。 bag は要素の値の重複が可能で、インデックスカラムを持たないため、主キーは定義されないかもしれません。 Hibernate には重複した行を区別する方法がありません。 Hibernate はこの問題の解決のために、変更があったときには常に完全な削除（一つの <code class="literal">DELETE</code> による）を行い、コレクションの再作成を行います。これは非常に非効率的かもしれません。</p><p>一対多関連では、「主キー」はデータベースのテーブルの物理的な主キーではないかもしれないことに注意してください。しかしこの場合でさえ、上記の分類はまだ有用です。（Hibernateがコレクションの個々の行をどうやって「見つけるか」を表しています。）</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>21.5.2. 更新にもっとも効率的なコレクション list、map、idbag、set</h3></div></div></div><p>上での議論から、インデックス付きコレクションと（普通の） set は要素の追加、削除、更新でもっとも効率的な操作が出来ることは明らかです。</p><p>ほぼ間違いなく、多対多関連や値のコレクションにおいて、インデックス付きコレクションが set よりも優れている点が一つ以上あります。 <code class="literal">Set</code> はその構造のために、 Hibernate は要素が「変更」されたときに行を決して <code class="literal">UPDATE</code> しません。 <code class="literal">Set</code> への変更は常に（個々の行の） <code class="literal">INSERT</code> と <code class="literal">DELETE</code> によって行います。繰り返しますが、これは一対多関連には当てはまりません。</p><p>配列は遅延処理ができないという決まりなので、結論として、list、map、idbag がもっともパフォーマンスの良い（inverse ではない）コレクションタイプとなります。 set もそれほど違いはありません。 Hibernate のアプリケーションでは、 set はコレクションのもっとも共通の種類として期待されます。 "set" の表現は関連モデルではもっとも自然だからです。</p><p>しかし、よくデザインされた Hibernate のドメインモデルでは、通常もっとも多いコレクションは事実上 <code class="literal">inverse="true"</code> を指定した一対多関連です。これらの関連では、更新は多対一の関連端で扱われ、コレクションの更新パフォーマンスの問題は当てはまりません。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>21.5.3. inverse コレクションにもっとも最適な bag と list</h3></div></div></div><p>bag を見放してしまう前に、 bag （そして list も）が set よりもずっとパフォーマンスが良い特別なケースを紹介します。 <code class="literal">inverse="true"</code> のコレクション（一般的な一対多関連の使い方など）で、 bag の要素を初期化（フェッチ）する必要なく bag や list に要素を追加できます。これは <code class="literal">Collection.add()</code> や <code class="literal">Collection.addAll()</code> は bag や <code class="literal">List</code> では常に true を返さなければならないからです （ <code class="literal">Set</code> とは異なります）。これは以下の共通処理をより速くすることができます。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">no&nbsp;need&nbsp;to&nbsp;fetch&nbsp;the&nbsp;collection</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">sess</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>21.5.4. 一括削除</h3></div></div></div><p>時々、コレクションの要素を一つ一つ削除することは極めて非効率的になることがあります。 Hibernate は愚かではないので、新しい空のコレクションの場合（ <code class="literal">list.clear()</code> を呼び出した場合など）ではこれをすべきでないことを知っています。この場合は、 Hibernate は <code class="literal">DELETE</code> を一回発行して、それですべて終わります。</p><p>サイズ20のコレクションに一つの要素を追加し、それから二つの要素を削除するとします。 Hibernate は一つの <code class="literal">INSERT</code> 文と二つの <code class="literal">DELETE</code> 文を発行します （コレクションが bag でなければ）。これは確かに望ましい動作です。</p><p>しかし、18個の要素を削除して2つを残し、それから3つ新しい要素を追加するとします。このとき二つの方法があります。</p><div class="itemizedlist"><ul><li><p>18行を一つ一つ削除して、3行を追加する</p></li><li><p>コレクション全体を削除（ <code class="literal">DELETE</code> の SQL を一回）し、そして5つの要素すべてを（一つずつ）追加する</p></li></ul></div><p>Hibernate はこの場合に2番目の方法がより速いだろうとわかるほど賢くはありません。（そして Hibernate がこのように賢いことも望ましくないでしょう。このような振る舞いはデータベースのトリガなどを混乱させるかもしれません。）</p><p>幸いにも、元のコレクションを捨て（つまり参照をやめて）、現在の要素をすべて持つ新しいコレクションのインスタンスを返すことで、いつでもこの振る舞い（2番目の戦略）を強制することが出来ます。時にこれはとても便利で強力です。</p><p>もちろん、一括削除は <code class="literal">inverse="true"</code> を指定したコレクションには行いません。</p></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>21.6. パフォーマンスのモニタリング</h2></div></div></div><p>最適化はモニタリングやパフォーマンスを示す数値がなければ十分に行えません。 Hibernate は内部処理のすべての範囲の数値を提供します。 Hibernate の統計情報は <code class="literal">SessionFactory</code> 単位で取得可能です。</p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>21.6.1. SessionFactory のモニタリング</h3></div></div></div><p><code class="literal">SessionFactory</code> のメトリクスにアクセスするには2つの方法があります。最初の方法は、 <code class="literal">sessionFactory.getStatistics()</code> を呼び出し、自分で <code class="literal">Statistics</code> の読み込みや表示を行います。</p><p><code class="literal">StatisticsService</code> MBean を有効にしていれば、 Hibernate は JMX を使ってメトリクスを発行することもできます。1つの MBean をすべての <code class="literal">SessionFactory</code> に対して有効にするか、 SessionFactory ごとに一つの MBean を有効にすることが出来ます。最小限の設定例である以下のコードを見てください:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;a&nbsp;specific&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;sessionFactory&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;myFinancialApp&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;tb</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;object&nbsp;name</span>
</span>
<!--  --><br/><span class="java_type">StatisticsService</span><span class="java_plain">&nbsp;stats&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StatisticsService</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">stats</span><span class="java_separator">.</span><span class="java_plain">setSessionFactory</span><span class="java_separator">(</span><span class="java_plain">sessionFactory</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Bind</span><span class="java_plain">&nbsp;the&nbsp;stats&nbsp;to&nbsp;a&nbsp;</span><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_plain">server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">stats</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Register</span><span class="java_plain">&nbsp;the&nbsp;</span><span class="java_type">Mbean</span><span class="java_plain">&nbsp;on&nbsp;the&nbsp;server</span></pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;all&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">'s</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;sessionFactory&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;all&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;tb</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;object&nbsp;name</span>
</span>
<!--  --><br/><span class="java_type">StatisticsService</span><span class="java_plain">&nbsp;stats&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StatisticsService</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">stats</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Register</span><span class="java_plain">&nbsp;the&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;on&nbsp;the&nbsp;server</span></pre><p><code class="literal">SessionFactory</code> に対してモニタリングの開始（終了）を行うことが出来ます。</p><div class="itemizedlist"><ul><li><p>設定時には、 <code class="literal">hibernate.generate_statistics</code> を <code class="literal">false</code> にします</p></li></ul></div><div class="itemizedlist"><ul><li><p>実行時に、 <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> または <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code> を呼び出します</p></li></ul></div><p>統計は <code class="literal">clear()</code> メソッドを使って手動でリセットすることが出来ます。サマリは <code class="literal">logSummary()</code> メソッドを使って logger に送ることが出来ます（info レベルです）。</p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>21.6.2. メトリクス</h3></div></div></div><p>多くのものがあります。すべての使用可能なカウンタは <code class="literal">Statistics</code> インターフェースの API に書かれており、3つの分類があります:</p><div class="itemizedlist"><ul><li><p>メトリクスは一般的な <code class="literal">Session</code> の使い方と関係しています。オープンしたセッションの数が JDBC コネクションと関連しているのと同じです。</p></li><li><p>メトリクスは要素、コレクション、クエリやキャッシュなど全体に関係しています（別名はグローバルメトリクスです）。</p></li><li><p>メトリクスの詳細は特定のエンティティ、コレクション、クエリ、キャッシュ領域に関係しています。</p></li></ul></div><p>例として、キャッシュのヒット、ヒットミスや、要素、コレクション、クエリの割合、クエリの実行に必要な平均時間を確認できます。ミリ秒の数値は Java の近似を受けることに注意してください。 Hibernate は JVM の精度に制限され、プラットフォームによっては10秒単位でしか正確でないかもしれません。</p><p>単純な getter はグローバルメトリクス（すなわち特定のエンティティ、コレクション、キャッシュ領域などに縛られない）にアクセスするために使います。特定のエンティティ、コレクション、キャッシュ領域のメトリクスは、それらの名前や、クエリの HQL 、 SQL 表現によってアクセスすることが出来ます。さらに詳しい情報は、 <code class="literal">Statistics</code> 、 <code class="literal">EntityStatistics</code> 、 <code class="literal">CollectionStatistics</code> 、 <code class="literal">SecondLevelCacheStatistics</code> 、 <code class="literal">QueryStatistics</code> API の javadoc を参照してください。以下のコードは簡単な例です:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Statistics</span><!-- <br/> --><span class="java_plain">&nbsp;stats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">HibernateUtil</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheHitCount&nbsp;&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getQueryCacheHitCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheMissCount&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getQueryCacheMissCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheHitRatio&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;queryCacheHitCount&nbsp;</span><span class="java_operator">/</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">queryCacheHitCount&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;queryCacheMissCount</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">log</span><span class="java_separator">.</span><span class="java_plain">info</span><span class="java_separator">(</span><span class="java_literal">&quot;Query&nbsp;Hit&nbsp;ratio:&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;queryCacheHitRatio</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_type">EntityStatistics</span><span class="java_plain">&nbsp;entityStats&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getEntityStatistics</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">long</span><span class="java_plain">&nbsp;changes&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getInsertCount</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getUpdateCount</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getDeleteCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">log</span><span class="java_separator">.</span><span class="java_plain">info</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;&nbsp;changed&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;changes&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;times&quot;</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">);</span></pre><p>すべてのエンティティ、コレクション、クエリ、キャッシュ領域に対して行う場合は、 <code class="literal">getQueries()</code> 、 <code class="literal">getEntityNames()</code>、 <code class="literal">getCollectionRoleNames()</code> 、 <code class="literal">getSecondLevelCacheRegionNames()</code> メソッドでそれぞれの名前のリストを取得することが出来ます。</p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">製作著作 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>前のページ</strong>第20章 XML マッピング</a></li><li class="up"><a accesskey="u" href="#"><strong>上に戻る</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>ホーム</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>次のページ</strong>第22章 ツールセットガイド</a></li></ul></body></html>