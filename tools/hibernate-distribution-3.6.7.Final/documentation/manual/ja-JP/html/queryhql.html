<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第16章 HQL: Hibernate クエリ言語</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="batch.html" title="第15章 バッチ処理"/><link rel="next" href="querycriteria.html" title="第17章 Criteria クエリ"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>前のページ</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>次のページ</strong></a></li></ul><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>第16章 HQL: Hibernate クエリ言語</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="queryhql.html#queryhql-casesensitivity">16.1. 大文字と小文字の区別</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-from">16.2. from 節</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins">16.3. 関連と結合</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins-forms">16.4. 結合構文の形式</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-identifier-property">16.5. 識別子プロパティの参照</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-select">16.6. Select 節</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-aggregation">16.7. 集約関数</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-polymorphism">16.8. ポリモーフィズムを使ったクエリ</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-where">16.9. where 節</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-expressions">16.10. Expressions 式</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-ordering">16.11. order by 節</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-grouping">16.12. group by 節</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-subqueries">16.13. 副問い合わせ</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-examples">16.14. HQL の例</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-bulk">16.15. 大量の UPDATE と DELETE</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tipstricks">16.16. Tips &amp; Tricks</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-components">16.17. コンポーネント</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tuple">16.18. 行値コンストラクタ構文</a></span></dt></dl></div><p>Hibernate は SQL に非常によく似た (意図的に似せた) 強力な問い合わせ言語を備えています。しかし SQL に似た構文に惑わされないでください。 HQL は完全にオブジェクト指向であり、継承、ポリモーフィズム、関連といった概念を理解します。 </p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>16.1. 大文字と小文字の区別</h2></div></div></div><p>クエリは Java のクラス名とプロパティ名を除いて大文字、小文字を区別しません。従って <code class="literal">SeLeCT</code> は <code class="literal">sELEct</code> と同じで、かつ <code class="literal">SELECT</code> とも同じですが <code class="literal">org.hibernate.eg.FOO</code> は <code class="literal">org.hibernate.eg.Foo</code> とは違い、かつ <code class="literal">foo.barSet</code> は <code class="literal">foo.BARSET</code> とも違います。 </p><p>このマニュアルでは小文字の HQL キーワードを使用します。大文字のキーワードのクエリの方が読みやすいと感じるユーザーもいると思います。ですが、 Java コード内に埋め込まれたときには見づらいと思います。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>16.2. from 節</h2></div></div></div><p>もっとも単純な Hibernate クエリは次の形式です: </p><pre class="programlisting">from eg.Cat</pre><p>This returns all instances of the class <code class="literal">eg.Cat</code>. You do not usually need to qualify the class name, since <code class="literal">auto-import</code> is the default. For example: </p><pre class="programlisting">from Cat</pre><p>In order to refer to the <code class="literal">Cat</code> in other parts of the query, you will need to assign an <span class="emphasis"><em>alias</em></span>. For example: </p><pre class="programlisting">from Cat as cat</pre><p>このクエリでは <code class="literal">Cat</code> インスタンスに <code class="literal">cat</code> という別名を付けています。そのため、後でこのクエリ内で、この別名を使うことができます。 <code class="literal">as</code> キーワードはオプションです。つまりこのように書くこともできます： </p><pre class="programlisting">from Cat cat</pre><p>直積、あるいは「クロス」結合によって多数のクラスが出現することもあります。 </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>ローカル変数の Java のネーミング基準と一致した、頭文字に小文字を使ったクエリの別名を付けることはいい習慣です (例えば <code class="literal">domesticCat</code>)。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>16.3. 関連と結合</h2></div></div></div><p>関連するエンティティあるいは値コレクションの要素にも、 <code class="literal">結合</code> を使って別名を割り当てることが出来ます。 </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>サポートしている結合のタイプは ANSI SQL と同じです。 </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">inner join</code>
                </p></li><li><p>
                    <code class="literal">left outer join</code>
                </p></li><li><p>
                    <code class="literal">right outer join</code>
                </p></li><li><p><code class="literal">full join</code> (たいていの場合使いづらい) </p></li></ul></div><p><code class="literal">inner join</code>、 <code class="literal">left outer join</code>、 <code class="literal">right outer join</code> には省略形を使うこともできます。 </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>HQL の <code class="literal">with</code> キーワードを使うと、結合条件を付け加えることができます。 </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight 
&gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a class="xref" href="performance.html#performance-fetching" title="21.1. フェッチ戦略">「フェッチ戦略」</a> for more information. </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>結合によるフェッチは関連するオブジェクトが <code class="literal">where</code> 節 (または他のどんな節でも) で使われてはならないので、通常別名を割り当てる必要がありません。また関連オブジェクトは問い合わせ結果として直接返されません。代わりに親オブジェクトを通してアクセスできます。コレクションを再帰的に結合フェッチする場合のみ、別名が必要になります: </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p><code class="literal">fetch</code> 構文は <code class="literal">iterate()</code> を使ったクエリ呼び出しで使用できないことに注意してください （一方で <code class="literal">scroll()</code> は使用できます）。また、これらの操作は結果の行に基づいているため、 <code class="literal">fetch</code> は <code class="literal">setMaxResults()</code> や <code class="literal">setFirstResult()</code> と一緒に使用すべきではありません。通常 eager なコレクションフェッチをすると重複が出てしまうため、あなたが期待するような行数にはならないのです。そしてまた <code class="literal">fetch</code> は、アドホックな <code class="literal">with</code> 条件を一緒に使うこともできません。一つのクエリで複数のコレクションを結合フェッチすることにより直積を作成できるので、この場合注意してください。また、複数のコレクションに対する結合フェッチは bag マッピングに対して予期せぬ結果をもたらすことがあるので、この場合のクエリの作成には注意してください。最後に <code class="literal">全外部結合によるフェッチ</code> と <code class="literal">右外部結合によるフェッチ</code> は有用ではないことに注意してください。 </p><p>もしプロパティレベルの遅延フェッチを使う場合（内部的にバイトコード処理をする場合）、 <code class="literal">fetch all properties</code> を使うことで Hibernate に遅延プロパティを速やかに（最初のクエリで）フェッチさせることができます。 </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>16.4. 結合構文の形式</h2></div></div></div><p>HQL は２つの関連結合形式をサポートします： <code class="literal">暗黙的</code> と <code class="literal">明示的</code>。 </p><p>これまでのセクションでお見せした使い方はすべて <code class="literal">明示的な</code> 形式で、 from 節で明示的に join キーワードを使っています。この形式をおすすめします。 </p><p><code class="literal">暗黙的</code> フォームは、 join キーワードを使いません。代わりに、参照する関連にドット表記を使います。 <code class="literal">暗黙的</code> 結合は、さまざまな HQL に出てきます。 <code class="literal">暗黙的</code> 結合の結果は、 SQL ステートメントの内部結合結果です。 </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>16.5. 識別子プロパティの参照</h2></div></div></div><p>エンティティの識別子プロパティは、一般的に2つの方法で参照されます: </p><div class="itemizedlist"><ul compact="compact"><li><p>特別なプロパティ (小文字) <code class="literal">id</code> は、 <span class="emphasis"><em>id と名付けられた非識別子プロパティを定義しないエンティティを与えられた</em></span> エンティティの識別子プロパティを参照するのに使用されます。 </p></li><li><p>もしエンティティが名付けられた識別子プロパティを定義したら、そのプロパティ名を使用できます。 </p></li></ul></div><p>複合識別子プロパティへの参照は同じ命名ルールに従います。もしエンティティが id と名付けられた非識別子プロパティを持っていたら、複合識別子プロパティはその定義された名前で参照することができます。そうでないと、特別な <code class="literal">id</code> プロパティは、識別子プロパティを参照するのに使用されます。 </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>注記: これは、バージョン 3.2.2 から大幅に変更しました。前バージョンでは、 <code class="literal">id</code> は、その実際の名前に関係なく <span class="emphasis"><em>常に</em></span> 識別子プロパティを参照していました。その結果、 <code class="literal">id</code> と名付けられた非識別子プロパティは、 Hibernate で決して参照されませんでした。 </p></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>16.6. Select 節</h2></div></div></div><p><code class="literal">select</code> 節は以下のようにどのオブジェクトと属性をクエリリザルトセットに返すかを選択します: </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>上記のクエリは他の <code class="literal">Cat</code> の <code class="literal">mate</code> を選択します。実際には次のように、より簡潔に表現できます: </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>クエリはコンポーネント型のプロパティを含む、あらゆる値型のプロパティも返せます: </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>クエリは複数のオブジェクトと (または) プロパティを <code class="literal">Object[]</code> 型の配列として返せます。 </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>もしくは <code class="literal">List</code> として、 </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>あるいは <code class="literal">Family</code> クラスが適切なコンストラクタを持っているとするならば、 </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>select 節に <code class="literal">as</code> を使って別名をつけることもできます。 </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p><code class="literal">select new map</code> と一緒に使うときに最も役立ちます： </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>このクエリは別名から select した値へ <code class="literal">Map</code> を返します。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>16.7. 集約関数</h2></div></div></div><p>HQL のクエリはプロパティの集約関数の結果も返せます： </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>サポートしている集約関数は以下のものです。 </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>select 節において算術操作、連結と承認された SQL 関数を使うことができます: </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>SQL と同じ意味を持つ <code class="literal">distinct</code> と <code class="literal">all</code> キーワードを使うことができます。 </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>16.8. ポリモーフィズムを使ったクエリ</h2></div></div></div><p>次のようなクエリ： </p><pre class="programlisting">from Cat as cat</pre><p><code class="literal">Cat</code> インスタンスだけではなく、 <code class="literal">DomesticCat</code> のようなサブクラスも返されます。 Hibernate クエリは <span class="emphasis"><em>どんな</em></span> Java クラスやインターフェースも <code class="literal">from</code> 節に入れることができます。クエリはそのクラスを拡張した、もしくはインターフェースを実装した全ての永続クラスを返します。次のクエリは永続オブジェクトをすべて返します: </p><pre class="programlisting">from java.lang.Object o</pre><p><code class="literal">Named</code> インターフェースは様々な永続クラスによって実装されます。: </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>最後の2つのクエリは、2つ以上の SQL <code class="literal">SELECT</code> を要求していることに注意してください。このことは <code class="literal">order by</code> 節がリザルトセット全体を正確には整列しないことを意味します (さらにそれは、 <code class="literal">Query.scroll()</code> を使用してこれらのクエリを呼ぶことができないことを意味します。)。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>16.9. where 節</h2></div></div></div><p><code class="literal">where</code> 節は返されるインスタンスのリストを絞ることができます。もし別名がない場合、名前でプロパティを参照します。 </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>もし別名がある場合、修飾名を使ってください: </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>名前が 'Fritz' という <code class="literal">Cat</code> のインスタンスを返します。 </p><p>The following query: </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p>上の HQL は、 <code class="literal">Foo</code> の <code class="literal">startDate</code> プロパティと等しい <code class="literal">date</code> プロパティを持った <code class="literal">bar</code> インスタンスが存在する、すべての <code class="literal">Foo</code> インスタンスを返します。コンパウンドパス式は <code class="literal">where</code> 節を非常に強力にします。注目： </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>このクエリはテーブル結合（内部結合）を持つ SQL クエリに変換されます。その代わりに以下のように書くと、 </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>もし上のクエリを記述したらクエリ内に4つのテーブル結合を必要とする SQL クエリに変換されます。 </p><p><code class="literal">=</code> 演算子は以下のように、プロパティだけでなくインスタンスを比較するためにも使われます。： </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. 識別子プロパティの参照">「識別子プロパティの参照」</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>2番目のクエリは効率的です。テーブル結合が必要ありません。 </p><p>また複合識別子のプロパティも使用できます。ここで <code class="literal">Person</code> が <code class="literal">country</code> と <code class="literal">medicareNumber</code> からなる複合識別子を持つと仮定します。識別子プロパティ参照についての詳細は、前回と同様に <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. 識別子プロパティの参照">「識別子プロパティの参照」</a> を参照ください。 </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>繰り返しますが、2番目のクエリにはテーブル結合が必要ありません。 </p><p>See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. 識別子プロパティの参照">「識別子プロパティの参照」</a> for more information regarding referencing identifier properties) </p><p>同様に <code class="literal">class</code> は特別なプロパティであり、ポリモーフィックな永続化におけるインスタンスの discriminator 値にアクセスします。 where 節に埋め込まれた Java のクラス名はその discriminator 値に変換されます。 </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a class="xref" href="queryhql.html#queryhql-components" title="16.17. コンポーネント">「コンポーネント」</a> for more information. </p><p>"any" 型は特別なプロパティである <code class="literal">id</code> と <code class="literal">class</code> を持ち、以下の方法で結合を表現することを可能にします (<code class="literal">AuditLog.item</code> は <code class="literal">&lt;any&gt;</code> でマッピングされたプロパティです)。 </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p><code class="literal">log.item.class</code> と <code class="literal">payment.class</code> が上記のクエリ中で全く異なるデータベースカラムの値を参照するということに注意してください。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>16.10. Expressions 式</h2></div></div></div><p>Expressions used in the <code class="literal">where</code> clause include the following: </p><div class="itemizedlist"><ul compact="compact"><li><p>算術演算子：<code class="literal">+, -, *, /</code> </p></li><li><p>2項比較演算子：<code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code> </p></li><li><p>論理演算子：<code class="literal">and, or, not</code> </p></li><li><p>グループ分けを表す括弧：<code class="literal">( )</code> </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> and <code class="literal">not member of</code> </p></li><li><p>"シンプル"な case <code class="literal">case ... when ... then ... else ... end</code>、 "探索的"な case <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>ストリングの連結 <code class="literal">...||...</code> または <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code>, <code class="literal">current_timestamp()</code> </p></li><li><p><code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code>, <code class="literal">year(...)</code>, </p></li><li><p>EJB-QL 3.0 で定義されている関数や演算子: <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</code> </p></li><li><p><code class="literal">coalesce()</code> と <code class="literal">nullif()</code> </p></li><li><p>数字や時間の値を String にコンバートする <code class="literal">str()</code> </p></li><li><p>2番目の引数が Hibernate 型の名前である <code class="literal">cast(... as ...)</code> と <code class="literal">extract(... from ...)</code>。ただし使用するデータベースが ANSI <code class="literal">cast()</code> と <code class="literal">extract()</code> をサポートする場合に限ります。 </p></li><li><p>結合したインデックス付きのコレクションの別名に適用される HQL の <code class="literal">index()</code> 関数。 </p></li><li><p>コレクション値のパス式を取る HQL 関数： <code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code> 。 <code class="literal">some, all, exists, any, in</code> を使って修飾することができる特別な <code class="literal">elements()</code> と <code class="literal">indices</code> 関数と一緒に使います。 </p></li><li><p><code class="literal">sign()</code>、 <code class="literal">trunc()</code>、 <code class="literal">rtrim()</code>、 <code class="literal">sin()</code> のようなデータベースがサポートする SQL スカラ関数。 </p></li><li><p>JDBC スタイルの位置パラメータ <code class="literal">?</code> </p></li><li><p>名前付きパラメータ: <code class="literal">:name</code>, <code class="literal">:start_date</code>, <code class="literal">:x1</code> </p></li><li><p>SQL リテラル： <code class="literal">'foo'</code>、 <code class="literal">69</code>、 <code class="literal">6.66E+2</code>、 <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>Java の <code class="literal">public static final</code> 定数： <code class="literal">eg.Color.TABBY</code> </p></li></ul></div><p><code class="literal">in</code> と <code class="literal">between</code> は以下のように使用できます: </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>また、否定形で記述することもできます。 </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>同様に <code class="literal">is null</code> や <code class="literal">is not null</code> は null 値をテストするために使用できます。 </p><p>Hibernate 設定ファイルで HQL query substitutions を定義すれば、 boolean 値を式の中で簡単に使用できます： </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"
&gt;true 1, false 0&lt;/property
&gt;</pre><p>こうすることで下記の HQL を SQL に変換するときに <code class="literal">true</code> 、 <code class="literal">false</code> キーワードは <code class="literal">1</code> 、 <code class="literal">0</code> に置き換えられます: </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>特別なプロパティ <code class="literal">size</code>、または特別な関数 <code class="literal">size()</code> を使ってコレクションのサイズをテストできます: </p><pre class="programlisting">from Cat cat where cat.kittens.size 
&gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) 
&gt; 0</pre><p>インデックス付きのコレクションでは、 <code class="literal">minindex</code> と <code class="literal">maxindex</code> 関数を使って、インデックスの最小値と最大値を参照できます。同様に、 <code class="literal">minelement</code> と <code class="literal">maxelement</code> を使って、基本型のコレクション要素の最小値と最大値を参照できます。 </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) 
&gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) 
&gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) 
&gt; 10000</pre><p>コレクションの要素やインデックスのセット（<code class="literal">elements</code> と <code class="literal">indices</code> 関数）、または副問い合わせ（後述）の結果が受け取れるときは、 SQL 関数 <code class="literal">any, some, all, exists, in</code> がサポートされます。 </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 
&gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p><code class="literal">size</code>、 <code class="literal">elements</code>、 <code class="literal">indices</code>、 <code class="literal">minindex</code>、 <code class="literal">maxindex</code>、 <code class="literal">minelement</code>、 <code class="literal">maxelement</code> は Hibernate3 の where 節だけで利用可能であることに注意してください。 </p><p>インデックス付きのコレクション（arrays, lists, maps）の要素は、インデックスで参照できます（where節内でのみ）： </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p><code class="literal">[]</code> 内部の式は、算術式でも構いません。 </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>一対多関連や値のコレクションの要素に対しては、 HQL は組み込みの <code class="literal">index()</code> 関数も用意しています。 </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>ベースとなるデータベースがサポートしているスカラー SQL 関数が使用できます： </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>もしまだ全てを理解していないなら、下のクエリを SQL でどれだけ長く、読みづらく出来るか考えてください: </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>ヒント:</em></span> 例えばこのように出来ます。 </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>16.11. order by 節</h2></div></div></div><p>クエリが返す list は、返されるクラスやコンポーネントの任意の属性によって並べ替えられます： </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>オプションの <code class="literal">asc</code> と <code class="literal">desc</code> はそれぞれ昇順か降順の整列を示します。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>16.12. group by 節</h2></div></div></div><p>集約値を返すクエリは、返されるクラスやコンポーネントの任意のプロパティによってグループ化できます: </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p><code class="literal">having</code> 節も使えます。 </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>もし使用するデータベースがサポートしているなら、 <code class="literal">having</code> と <code class="literal">order by</code> 節で SQL 関数と集約関数が使えます（例えば MySQL にはありません）。 </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.name, cat.other, cat.properties
having avg(kitten.weight) 
&gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p><code class="literal">group by</code> 節や <code class="literal">order by</code> 節に算術式を含むことができないことに注意してください。また、  Hibernate は今のところグループエンティティを拡張しないことにも注意してください。したがって、もし <code class="literal">cat</code> の全てのプロパティが非集合体の場合、 <code class="literal">group by cat</code> を書くことはできません。全ての非集合体のプロパティを明示的にリストする必要があります。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>16.13. 副問い合わせ</h2></div></div></div><p>サブセレクトをサポートするデータベースのため、 Hibernate は副問い合わせをサポートしています。副問い合わせは括弧で囲まなければなりません（ SQL の集約関数呼び出しによる事が多いです）。関連副問い合わせ (外部クエリ中の別名を参照する副問い合わせのこと) さえ許可されます。 </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight 
&gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>HQL 副問い合わせは、 select または where 節だけで使われることに注意してください。 </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a class="xref" href="queryhql.html#queryhql-tuple" title="16.18. 行値コンストラクタ構文">「行値コンストラクタ構文」</a> for more information. </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>16.14. HQL の例</h2></div></div></div><p>Hibernate クエリは非常に強力で複雑にできます。実際、クエリ言語の威力は Hibernate の主要なセールスポイントの一つです。ここに最近のプロジェクトで使用したクエリと非常によく似た例があります。ほとんどのクエリはこれらの例より簡単に記述できることに注意してください。 </p><p>以下のクエリは特定の顧客と与えられた最小の合計値に対する未払い注文の注文 ID 、商品の数、注文の合計を合計値で整列して返します。価格を決定する際、現在のカタログを使います。結果として返される SQL クエリは <code class="literal">ORDER</code>、 <code class="literal">ORDER_LINE</code>、 <code class="literal">PRODUCT</code>、 <code class="literal">CATALOG</code> および <code class="literal">PRICE</code> テーブルに対し4つの内部結合と (関連しない) 副問い合わせを持ちます。 </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate 
&gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>何て巨大なクエリなのでしょう。普段私は副問い合わせをあまり使いません。したがって私のクエリは実際には以下のようになります。: </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>次のクエリは各ステータスの支払い数を数えます。ただしすべての支払いが現在の利用者による最新のステータス変更である <code class="literal">AWAITING_APPROVAL</code> である場合を除きます。このクエリは2つの内部結合と <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code> および <code class="literal">PAYMENT_STATUS_CHANGE</code> テーブルに対する関連副問い合わせを備えた SQL クエリに変換されます。 </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;
&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>もし set の代わりに list として <code class="literal">statusChanges</code> コレクションをマッピングしたならば、はるかに簡単にクエリを記述できるでしょう。 </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;
&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>次のクエリは現在のユーザーが所属する組織に対するアカウントおよび未払いの支払いをすべて返す MS SQL Server の <code class="literal">isNull()</code> 関数を使用しています。このクエリは3つの内部結合と1つの外部結合、そして <code class="literal">ACCOUNT</code>、 <code class="literal">PAYMENT</code>、 <code class="literal">PAYMENT_STATUS</code>、 <code class="literal">ACCOUNT_TYPE</code>、 <code class="literal">ORGANIZATION</code> および <code class="literal">ORG_USER</code> テーブルに対する副問い合わせ持った SQL に変換されます。 </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>いくつかのデータベースについては、 (関連させられた) 副問い合わせの使用を避ける必要があるでしょう。 </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>16.15. 大量の UPDATE と DELETE</h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a class="xref" href="batch.html#batch-direct" title="15.4. DML スタイルの操作">「DML スタイルの操作」</a> for more information. </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>16.16. Tips &amp; Tricks</h2></div></div></div><p>実際に結果を返さなくてもクエリの結果数を数えることができます: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p>コレクションのサイズにより結果を並べ替えるためには以下のクエリを使用します: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>使用しているデータベースがサブセレクトをサポートする場合、クエリの where 節でサイズによる選択条件を設定できます: </p><pre class="programlisting">from User usr where size(usr.messages) 
&gt;= 1</pre><p>使用しているデータベースがサブセレクトをサポートしない場合は、次のクエリを使用してください: </p><pre class="programlisting">select usr.id, usr.name
from User usr
    join usr.messages msg
group by usr.id, usr.name
having count(msg) 
&gt;= 1</pre><p>内部結合をしているせいで上の解決法が message の件数がゼロの <code class="literal">User</code> を返すことができないならば、以下の形式が使えます: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>JavaBean のプロパティは、名前付きのクエリパラメータに結びつけることが出来ます： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;foo&nbsp;Foo&nbsp;as&nbsp;foo&nbsp;where&nbsp;foo.name=:name&nbsp;and&nbsp;foo.size=:size&quot;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setProperties</span><span class="java_separator">(</span><span class="java_plain">fooBean</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;fooBean&nbsp;has&nbsp;getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;and&nbsp;getSize</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;foos&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>コレクションはフィルタ付き <code class="literal">Query</code> インターフェースを使用することでページをつけることができます: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;the&nbsp;trivial&nbsp;filter</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setFirstResult</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE&nbsp;</span><span class="java_operator">*</span><span class="java_plain">&nbsp;pageNumber</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;page&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>コレクションの要素はクエリフィルタを使って、並べ替えやグループ分けが出来ます: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Collection</span><!-- <br/> --><span class="java_plain">&nbsp;orderedCollection&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">filter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;order&nbsp;by&nbsp;this.amount&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Collection</span><span class="java_plain">&nbsp;counts&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">filter</span><span class="java_separator">(</span><span class="java_plain">&nbsp;collection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;select&nbsp;this.type,&nbsp;count(this)&nbsp;group&nbsp;by&nbsp;this.type&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span></pre><p>コレクションを初期化せずにコレクションのサイズを得ることができます: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>16.17. コンポーネント</h2></div></div></div><p>HQL クエリでシンプルな値型を使用できるので、コンポーネントは、あらゆる点で使用できます。これは <code class="literal">select</code> 節の中に現われます: </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>人名のプロパティがコンポーネントの場所。コンポーネントは、 <code class="literal">where</code> 節でも使用可能です: </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>コンポーネントは <code class="literal">order by</code> 節でも使用可能です: </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>Another common use of components is in <a class="link" href="queryhql.html#queryhql-tuple" title="16.18. 行値コンストラクタ構文">row value constructors</a>. </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>16.18. 行値コンストラクタ構文</h2></div></div></div><p>下に位置するデータベースが ANSI SQL <code class="literal">row value constructor</code> 構文 (<code class="literal">tuple</code> 構文とよばれることもあります) をサポートしていないとしても、 HQL はその使用をサポートしています。ここでは、一般的にコンポーネントと連繋するマルチバリュー比較について触れます。ネームコンポーネントを定義する Person エンティティを考えましょう: </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>それは少々詳細になりますが、有効な構文です。より簡潔にし、 <code class="literal">row value constructor</code> 構文を使用するのがよいでしょう: </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p>それを <code class="literal">select</code> 節で指定するのも効果的です。 </p><pre class="programlisting">select p.name from Person p</pre><p>次に <code class="literal">row value constructor</code> 構文の使用が有効なときは、サブクエリを使用して複数の値と比較する必要があるときです: </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>この構文を使用するかどうか決定するときに考慮しなければならないことは、クエリがメタデータ内のコンポーネントのサブプロパティの順番に依存していることです。 </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">製作著作 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>前のページ</strong>第15章 バッチ処理</a></li><li class="up"><a accesskey="u" href="#"><strong>上に戻る</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>ホーム</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>次のページ</strong>第17章 Criteria クエリ</a></li></ul></body></html>