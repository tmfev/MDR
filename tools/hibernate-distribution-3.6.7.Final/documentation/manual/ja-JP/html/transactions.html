<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第13章 Transactions and Concurrency</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="readonly.html" title="第12章 Read-only entities"/><link rel="next" href="events.html" title="第14章 インターセプタとイベント"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>前のページ</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>次のページ</strong></a></li></ul><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>第13章 Transactions and Concurrency</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="transactions.html#transactions-basics">13.1. session スコープと transaction スコープ</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-basics-uow">13.1.1. 作業単位（Unit of work）</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-apptx">13.1.2. 長い対話</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-identity">13.1.3. オブジェクト識別子を考える</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-issues">13.1.4. 一般的な問題</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-demarcation">13.2. データベーストランザクション境界</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-demarcation-nonmanaged">13.2.1. 管理されていない環境</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-jta">13.2.2. JTA を使用する</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-exceptions">13.2.3. 例外ハンドリング</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-timeout">13.2.4. トランザクションのタイムアウト</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-optimistic">13.3. 楽観的同時実行制御</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-optimistic-manual">13.3.1. アプリケーションによるバージョンチェック</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-longsession">13.3.2. 拡張セッションと自動バージョニング</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-detached">13.3.3. デタッチされたオブジェクトと自動バージョニング</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-customizing">13.3.4. 自動バージョニングのカスタマイズ</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-locking">13.4. 悲観的ロック</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-connection-release">13.5. コネクション開放モード</a></span></dt></dl></div><p>Hibernate と同時実行制御について最も重要な点は、容易に理解できることです。 Hibernate は新たなロックの振る舞いを追加しておらず、直接 JDBC コネクションと JTA リソースを使用します。 JDBC 、 ANSI 、およびデータベース管理システム（DBMS）のトランザクション分離の仕様を少し時間をかけて勉強することを強く推奨します。 </p><p>Hibernate はメモリ内のオブジェクトをロックしません。アプリケーションは、データベーストランザクションの分離レベルで定義した振る舞いを期待できます。トランザクションスコープのキャッシュでもある <code class="literal">Session</code> のお陰で、識別子やクエリにより検索したエンティティはリピータブルリードになります（スカラー値を返すようなレポートクエリは違います）。 </p><p>バージョニングによる自動的な楽観的同時実行制御に加えて、 <code class="literal">SELECT FOR UPDATE</code> 文を使用して、行を悲観的ロックするための（マイナーな） API も提供します。楽観的同時実行制御とこの API については、この章の後のほうで議論します。 </p><p>データベーストランザクションや長い対話（conversation、ロングトランザクション）だけでなく、 <code class="literal">Configuration</code>、<code class="literal">SessionFactory</code>、および <code class="literal">Session</code> という粒度で Hibernate が行う同時実行制御の議論を始めます。 </p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>13.1. session スコープと transaction スコープ</h2></div></div></div><p><code class="literal">SessionFactory</code> は生成することが高価で、スレッドセーフなオブジェクトです。よって、アプリケーションのすべてのスレッドで共有すべきです。通常、アプリケーションの起動時に、 <code class="literal">Configuration</code> インスタンスから１度だけ生成します。 </p><p><code class="literal">Session</code> は高価ではなく、スレッドセーフなオブジェクトでもありません。よって、１つの要求や１つの対話、１つの作業単位（unit of work）に対して１度だけ使い、その後で捨てるべきです。 <code class="literal">Session</code> は必要になるまで、 JDBC <code class="literal">Connection</code>（もしくは <code class="literal">DataSource</code>）を獲得しません。ゆえに、実際に使用するときまでリソースを消費しません。 </p><p>この状況を完了させるために、データベーストランザクションについても考えなければなりません。データベース内のロックの競合を少なくするために、データベーストランザクションは可能な限り短くするべきです。長いデータベーストランザクションは、アプリケーションの高い並列実行性を阻害します。ゆえに、ユーザーが考えている間（作業単位が完了するまで）データベーストランザクションを開いたままにするのは、たいていの場合よい設計とはいえません。 </p><p>作業単位というスコープとは何でしょうか？１つの Hibernate <code class="literal">Session</code> は、いくつかのデータベーストランザクションをまたがることができるでしょうか？または、スコープと一対一の関係でしょうか？いつ <code class="literal">Session</code> を開き、閉じるべきでしょうか？そして、データベーストランザクション境界をどのように分けるのでしょうか？ </p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>13.1.1. 作業単位（Unit of work）</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as 「<span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span>」[<a class="citation" href="bi01.html#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a class="xref" href="transactions.html#transactions-basics-apptx" title="13.1.2. 長い対話">「長い対話」</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>１つ目は、 <span class="emphasis"><em>session-per-operation</em></span> アンチパターンを使ってはいけません。すなわち、１つのスレッドの中で、単純なデータベース呼び出しの度に <code class="literal">Session</code> を開いて、閉じてはいけません。もちろん、データベーストランザクションについても同様です。アプリケーション中のデータベース呼び出しは、計画されたシーケンス（planned sequence）を使い、アトミックな作業単位に分類されます。（１つの SQL 文ごとにコミットする自動コミットが、使われないという意味でもあることに注意してください。自動コミットは、 SQL コンソールでアドホックな作業をする際に使うものです。 Hibernate は直ちに自動コミットモードを無効にします。もしくは、アプリケーションサーバーが無効化することを期待します。）データベーストランザクションはオプションではありません。データベースとのすべての通信は、データの読み込みであっても、書き込みであっても、トランザクションの中で行わなければなりません。説明すると、データ読み込みに対して、自動コミットは避けるべきです。なぜなら、多数の小さなトランザクションは、明確に定義された１つの作業単位と比べて、パフォーマンスがよくなることはありません。後者は保守性や拡張性もよりすぐれています。 </p><p>マルチユーザーのクライアント／サーバーアプリケーションの中で、最もよく使われるパターンは、 <span class="emphasis"><em>session-per-request</em></span> です。このモデルの中では、クライアントから（ Hibernate 永続化層が動作する）サーバーへリクエストが送られ、新しい Hibernate <code class="literal">Session</code> が開かれます。そして、この作業単位の中ですべてのデータベース処理が実行されます。作業が完了した（そして、クライアントへのレスポンスが準備できた）時点で、 session をフラッシュし、閉じます。クライアントの要求を処理するために、１つのデータベーストランザクションを使用するでしょう。 <code class="literal">Session</code> を開き、閉じる際に、データベーストランザクションを開始し、コミットします。二つの関係は一対一です。このモデルは多くのアプリケーションに完全に適合します。 </p><p>以降の実装にチャレンジしてください。 Hibernate は単純なこのパターンのために、予め組み込まれた "current session" の管理を提供します。サーバーリクエストを処理する際はトランザクションを開始しなければなりません。そして、レスポンスをクライアントに送信する前にトランザクションを終わらせます。好きな方法で実現できます。一般的な解決策は <code class="literal">ServletFilter</code> やサービスメソッドをポイントカットして AOP インターセプター、 proxy/interception コンテナです。 EJB コンテナは EJB セッション Bean をトランザクション境界としてアスペクトをクロスカットする実装の標準的な方法です（ CMT による宣言的）。プログラムによるトランザクション境界を使うと決めた場合、簡単に使うため、互換性のあるコードにするために、この章の後のほうにある Hibernate <code class="literal">Transaction</code> API のほうがよいです。 </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. コンテキスト上のセッション">「コンテキスト上のセッション」</a>. </p><p>ときどき、「ビューを描画する」まで <code class="literal">セッション</code> とデータベーストランザクションのスコープを拡張すると便利なことがあります。これは、要求の処理と描画のフェーズを分けているサーブレットアプリケーションにおいて特に役立ちます。独自のインターセプタを実装すれば、ビューを描画するまでデータベーストランザクションを拡張するのは簡単です。しかし、コンテナ管理トランザクションの EJB に頼る場合は、簡単にはできません。なぜなら、ビューの描画を開始する前に、 EJB のメソッドがリターンした際に、トランザクションが完了するためです。この <span class="emphasis"><em>Open Session in View</em></span> パターンに関連するヒントと例については、 Hibernate の Web サイトやフォーラムを参照してください。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>13.1.2. 長い対話</h3></div></div></div><p>session-per-request パターンは、作業単位を設計する際に役立つ考えというだけではありません。多くのビジネスプロセスは、ユーザーとの一連の相互作用全体を要求します。その相互作用には、データベースアクセスが含まれます。 Web とエンタープライズアプリケーションでは、データベーストランザクションがユーザーとの相互作用にまで渡ることは許されません。次の例をよく考えてみてください:  </p><div class="itemizedlist"><ul><li><p>ダイアログの最初の画面が開き、個々の <code class="literal">Session</code> とデータベーストランザクションの中でロードされたデータをユーザーに見せます。ユーザーはオブジェクトを自由に修正できます。 </p></li><li><p>5分後にユーザーは "Save" をクリックし、修正が永続化されるのを期待します。また、この情報を編集したのは自分１人だけで、修正のコンフリクトは発生しないと期待します。 </p></li></ul></div><p>この作業単位を（ユーザーの視点で）長期の <span class="emphasis"><em>対話</em></span> （もしくは、<span class="emphasis"><em>アプリケーショントランザクション</em></span> ）と呼びます。アプリケーションにこれを実装する方法はたくさんあります。 </p><p>最初に思いつく実装は、ユーザーが考えている間、 <code class="literal">Session</code> とデータベーストランザクションを開いたままにしておくことです。同時に修正されず、分離と原子性が保証されるように、データベース内のロックは保持したままにします。もちろん、これはアンチパターンです。なぜなら、ロックの競合が発生すると、アプリケーションが同時ユーザー数に応じてスケールアップできなくなるからです。 </p><p>明らかに、対話を実装するためには、いくつかのデータベーストランザクションを使用するべきです。この場合、ビジネスプロセスの分離を維持することは、アプリケーション層の責務の１つになります。１つの対話は、通常いくつかのデータベーストランザクションに及びます。データベーストランザクションの１つのみ（最後の１つ）が更新したデータを保存し、他はデータを読むだけであれば、それはアトミックです（例えば、いくつかの要求／応答を繰り返すウィザード形式のダイアログ）。これは聞くより、実装したほうが簡単です。 Hibernate の機能を使うのであれば、特に簡単です: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>自動バージョニング</em></span> - Hibernate は自動的に楽観的同時実行制御ができます。ユーザーが考えている間に同時に修正がおきた場合、自動的に検出できます。通常、対話の終了時にチェックするだけです。 </p></li><li><p><span class="emphasis"><em>分離（Detached）オブジェクト</em></span> - すでに議論した <span class="emphasis"><em>session-per-request</em></span> パターンを使うと決定した場合、ロードされたすべてのインスタンスは、ユーザーが考えている間は、セッションから分離された状態になります。オブジェクトをセッションに再追加し、修正を永続化できます。これを <span class="emphasis"><em>session-per-request-with-detached-objects</em></span> パターンと呼びます。自動バージョニングを使うことで、同時に行われる修正を分離できます。 </p></li><li><p><span class="emphasis"><em>拡張（もしくは、長い）セッション</em></span> - Hibernate の <code class="literal">Session</code> は、データベーストランザクションをコミットした後、裏で結びついている JDBC コネクションを切断できます。そして、クライアントからの新しい要求が発生した際に、再接続できます。このパターンは、 <span class="emphasis"><em>session-per-conversation</em></span> という名で知られており、オブジェクトをセッションへ再追加することさえ不要にします。自動バージョニングを使うことで、同時に行われる修正を分離できます。通常 <code class="literal">Session</code> を自動的にフラッシュさせず、明示的にフラッシュします。 </p></li></ul></div><p><span class="emphasis"><em>session-per-request-with-detached-objects</em></span> と <span class="emphasis"><em>session-per-conversation</em></span> の２つは、利点と欠点を持っています。これについては、この章の後のほうで、楽観的同時実行制御の文脈の中で議論します。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>13.1.3. オブジェクト識別子を考える</h3></div></div></div><p>アプリケーションは、２つの異なる <code class="literal">Session</code> から同じ永続状態に同時にアクセスできます。しかし、２つの <code class="literal">Session</code> インスタンスが永続性クラスの１つのインスタンスを共有することはできません。ゆえに、識別子には２つの異なる概念があるということになります。 </p><div class="variablelist"><dl><dt><span class="term">データベース識別子</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">JVM 識別子</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p><span class="emphasis"><em>特定の</em></span><code class="literal">Session</code> に追加されたオブジェクトにとって （すなわち、１つの <code class="literal">Session</code> のスコープの中では） 、２つの概念は同じです。データベース同一性と JVM 同一性が一致することを、 Hibernate が保証します。しかし、アプリケーションが２つの異なるセッションから「同じ」（永続性識別子の）ビジネスオブジェクトに同時にアクセスする限り、２つのインスタンスは実際に（ JVM 識別子が）「異なり」ます。楽観的アプローチによって、 （自動バージョニングの） フラッシュ／コミット時にコンフリクトが解決されます。 </p><p>このアプローチでは、 Hibernate とデータベースに同時実行についての心配が残ります。一方で、最高のスケーラビリティが提供されます。なぜなら、１スレッドの作業単位の中で一意性が保証されれば、高価なロックや同期化が不要になるためです。 <code class="literal">Session</code> ごとに１つのスレッドを貼り付ける限り、アプリケーションはビジネスオブジェクトを synchronize する必要はありません。 <code class="literal">Session</code> 内では、アプリケーションはオブジェクトを比較するために、 <code class="literal">==</code> を安全に使用できます。 </p><p>けれども、 <code class="literal">Session</code> の外で <code class="literal">==</code> を使うアプリケーションは、予期しない結果に遭遇します。これは予期しない場所で起こりえます。例えば、２つの分離インスタンスを同じ <code class="literal">Set</code> に put したときなどです。両方とも同じデータベース識別子を持ちます（すなわち、同じ行を表します）。しかし、分離状態のインスタンスの JVM 識別子は当然保証されません。開発者は、永続性クラスの <code class="literal">equals()</code> と <code class="literal">hashCode()</code> メソッドをオーバーライドし、オブジェクト等価性の概念を実装すべきです。警告が１つあります。等価性の実装にデータベース識別子を使わないでください。ユニークな（普通は不変の）属性の組み合わせであるビジネスキーを使ってください。もし、一時オブジェクトが永続化された場合、データベース識別子が変わります。一時オブジェクトを（通常分離インスタンスと共に） <code class="literal">Set</code> に保持する場合、ハッシュコードが変わるということは、 <code class="literal">Set</code> の契約を破るということです。ビジネスキーのための属性は、データベースの主キーほど安定すべきではないです。オブジェクトが同じ <code class="literal">Set</code> の中にいる間だけ、安定を保証すべきです。この問題のより徹底的な議論は、 Hibernate の Web サイトを参照してください。また、これは Hibernate の問題ではなく、単に Java オブジェクトの識別子や等価性をどのように実装すべきかということです。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>13.1.4. 一般的な問題</h3></div></div></div><p><span class="emphasis"><em>session-per-user-session</em></span> と <span class="emphasis"><em>session-per-application</em></span> アンチパターンは使ってはいけません（もちろん、まれに例外があります）。注記：下記の問題のいくつかは、推奨されるパターンとしても出現します。設計を決定する前に、裏の意味を理解するようにしてください。 </p><div class="itemizedlist"><ul><li><p><code class="literal">Session</code> はスレッドセーフではありません。 HTTP リクエスト、セッション Bean 、 Swing ワーカーのように、同時実行が可能なものが <code class="literal">Session</code> インスタンスを共有すると、競合状態を引き起こします。（後で議論する） <code class="literal">HttpSession</code> の中で Hibernate <code class="literal">Session</code> を保持する場合、 HttpSession へのアクセスを同期化することを考慮すべきです。さもなければ、ユーザーが十分早くリロードをクリックすると、同時に走る２つのスレッドの中で、同じ <code class="literal">Session</code> が使われます。 </p></li><li><p>Hibernate が例外を投げた場合は、データベーストランザクションをロールバックし、直ちに <code class="literal">Session</code> を閉じるべきです （詳細を後で議論します） 。 <code class="literal">Session</code> がアプリケーションに結び付けられているのであれば、アプリケーションを停止すべきです。データベーストランザクションをロールバックしても、ビジネスオブジェクトはトランザクションを開始したときの状態に戻りません。これは、データベースの状態とビジネスオブジェクトは同期していないことを意味します。通常これは問題になりません。なぜなら、例外は回復できないからです。とにかくロールバックした後にやり直すべきです。 </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a class="xref" href="batch.html" title="第15章 バッチ処理">15章<i>バッチ処理</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>13.2. データベーストランザクション境界</h2></div></div></div><p>データベース （もしくはシステム） トランザクションの境界は、常に必要です。データベーストランザクションの外で、データベースとの通信は起きません （これは自動コミットモードに慣れている多くの開発者を混乱させるかもしれません） 。読み込むだけの操作にでも、いつも明確なトランザクション境界を使用してください。分離レベルとデータベースの能力次第で、これは必要ないかもしれませんが、常にトランザクション境界を明示的に指定しても、マイナス面は全くありません。確かに、１つのデータベーストランザクションは多数の小さなトランザクションより （データの読み込みであっても） パフォーマンスがすぐれています。 </p><p>J2EE 環境に管理されていない状態 （すなわち、スタンドアロン、単純な Web や Swing アプリケーション）でも、管理された状態でも、 Hibernate アプリケーションを実行できます。管理されていない環境では、 Hiberante がデータベースのコネクションプールを提供します。アプリケーション開発者は、トランザクション境界を手動で設定しなければなりません。言い換えると、データベーストランザクションの開始、コミット、ロールバックを開発者自身が設定する必要があるということです。通常、管理された環境では、コンテナ管理によるトランザクション （CMT） が提供されます。例えば、セッション Bean のデプロイメントディスクリプタで宣言的に定義し、トランザクションを組み立てます。プログラムによるトランザクション境界はもう必要ありません。 </p><p>しかしながら、管理されていないリソースローカルな環境と JTA に依存したシステム （CMT ではなく BMT） の両方に、永続化層をポータブルに保つのは、しばしば望ましいことです。デプロイ環境のネイティブのトランザクションシステムを呼び出す <code class="literal">Transaction</code> というラッパー API を Hibernate が提供します。この API を使うかは任意ですが、 CMT のセッション Bean を使わないのであれば、使うことを強く推奨します。 </p><p>通常、 <code class="literal">Session</code> 終了は、４つの異なるフェーズを含みます: </p><div class="itemizedlist"><ul compact="compact"><li><p>セッションのフラッシュ </p></li><li><p>トランザクションのコミット </p></li><li><p>セッションのクローズ </p></li><li><p>例外のハンドリング </p></li></ul></div><p>セッションのフラッシュについては、前の方で既に議論しました。管理された環境と管理されていない環境の両方について、トランザクション境界と例外ハンドリングをもっと詳しく見ていきましょう。 </p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>13.2.1. 管理されていない環境</h3></div></div></div><p>Hibernate 永続化層を管理されていない環境で実装する場合は、通常単純なコネクションプール （すなわち DataSource ではない） によって、データベースコネクションを制御します。 Hibernate はそのコネクションプールから必要なコネクションを取得します。セッション／トランザクション制御のイディオムは次のようになります： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>You do not have to <code class="literal">flush()</code> the <code class="literal">Session</code> explicitly: the call to <code class="literal">commit()</code> automatically triggers the synchronization depending on the <a class="link" href="objectstate.html#objectstate-flushing" title="11.10. セッションのフラッシュ">FlushMode</a> for the session. A call to <code class="literal">close()</code> marks the end of a session. The main implication of <code class="literal">close()</code> is that the JDBC connection will be relinquished by the session. This Java code is portable and runs in both non-managed and JTA environments. </p><p>より適応性のある解決策は、 Hibernate に予め組み込まれている "current session" コンテキスト管理です。言葉で説明するより下記を見たほうが速いでしょう。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>正規のアプリケーションの中では、このようなコードの切れ端を決して見ないでしょう。致命的な （システム） 例外は、常に「最上位」でキャッチすべきです。言い換えれば、 （永続化層で） Hibernate 呼び出しを実行するコードと、 <code class="literal">RuntimeException</code> を制御する （通常はクリーンアップと終了のみ行うことができる） コードは、別々の層の中にあります。 Hibernate によるカレントコンテキスト管理は、この設計をかなり単純にします。必要なのは、 <code class="literal">SessionFactory</code> にアクセスすることだけです。例外処理は、この章の後のほうで議論します。 </p><p>注記：（デフォルトですが） <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code> を選択するべきです。第2の用例としては、 <code class="literal">hibernate.current_session_context_class</code> を <code class="literal">"thread"</code> とするとよいでしょう。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>13.2.2. JTA を使用する</h3></div></div></div><p>永続化層をアプリケーションサーバー （例えば、 EJB セッション Bean の背後） で実行する場合、 Hibernate から取得するすべてのデータソースコネクションは、自動的にグローバル JTA トランザクションの一部になります。 EJB を使わずに、スタンドアロンの JTA 実装を導入することもできます。 JTA 統合のために、 Hibernate は２つの戦略を提供します。 </p><p>Bean 管理トランザクション（BMT）を使い、 <code class="literal">Transaction</code> API を使う場合、 Hibernate はアプリケーションサーバーに BMT トランザクションの開始と終わりを告げます。すなわち、トランザクション管理のコードは、管理されない環境と同じになります。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>トランザクション境界として <code class="literal">Session</code> を使いたい場合、簡単にコンテキストを伝播する機能である <code class="literal">getCurrentSession()</code> があるので、 JTAの <code class="literal">UserTransaction</code> API を直接使用すべきでしょう。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">UserTransaction</span><span class="java_separator">)</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;java:comp/UserTransaction&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Do</span><span class="java_plain">&nbsp;some&nbsp;work&nbsp;on&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;bound&nbsp;to&nbsp;transaction</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">load</span><span class="java_separator">(...);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">persist</span><span class="java_separator">(...);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>CMT では、トランザクション境界をセッション Bean のデプロイメントディスクリプタで定義し、プログラムでは行いません。ゆえに、コードは次のように少なくなります: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;CMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</pre><p>CMT/EJB の中では、常にロールバックが自動的に実施されます。なぜなら、セッション Bean のメソッドにより投げられた制御されていない <code class="literal">RuntimeException</code> は、グローバルトランザクションをロールバックするようにコンテナに伝えるためです。 <span class="emphasis"><em>これは、 BMT もしくは CMT と一緒に Hibernate <code class="literal">Transaction</code> API を使う必要はまったくないということを意味し、トランザクションにバインドする「現在の」セッションを自動伝搬できます。</em></span> </p><p>Hibernate のトランザクションファクトリを設定する際に、 JTA を直接使う （BMTの） 場合は <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> を、 CMT セッション Bean の中では <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> を選択すべきだということに注意してください。 <code class="literal">hibernate.transaction.manager_lookup_class</code> をセットすることも思い出してください。なお、 <code class="literal">hibernate.current_session_context_class</code> は、セットしないか（後方互換）、 <code class="literal">"jta"</code> をセットしてください。 </p><p><code class="literal">getCurrentSession()</code> オペレーションは、 JTA 環境では１つの欠点を持ちます。デフォルトで使われる <code class="literal">after_statement</code> コネクションリリースモードを使用する上で、警告が１つあります。 JTA 仕様の愚かな制約のために、 <code class="literal">scroll()</code> または <code class="literal">iterate()</code> が返した、閉じられていない <code class="literal">ScrollableResults</code> または <code class="literal">Iterator</code> インスタンスを Hibernate が自動的にクリーンアップすることはできません。 <code class="literal">finally</code> ブロックの中で、 <code class="literal">ScrollableResults.close()</code> または <code class="literal">Hibernate.close(Iterator)</code> を明示的に呼び出して、裏に潜んだデータベースカーソルを解放 <span class="emphasis"><em>しなければなりません</em></span>。 （もちろん、多くのアプリケーションでは、 JTA か CMT コードで <code class="literal">scroll()</code> や <code class="literal">iterate()</code> の使用を避けるのは容易です。） </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>13.2.3. 例外ハンドリング</h3></div></div></div><p><code class="literal">Session</code> が例外 （<code class="literal">SQLException</code>を含む） を投げた場合、直ちに、データベーストランザクションをロールバックし、 <code class="literal">Session.close()</code> を呼び、 <code class="literal">Session</code> インスタンスを破棄すべきです。 <code class="literal">Session</code> のいくつかのメソッドは、セッションの状態を <span class="emphasis"><em>矛盾したまま</em></span> にします。 Hibernate が投げた例外を、回復できるものとして扱うことはできません。 <code class="literal">finally</code> ブロックの中で <code class="literal">close()</code> を呼んで、 <code class="literal">Session</code> を確実に閉じてください。 </p><p><code class="literal">HibernateException</code> は、 Hibernate 永続化層の中で発生する多くのエラーをラップする、検査されない例外です （ Hibernate の古いバージョンは違いました） 。私たちの意見は、アプリケーション開発者に回復不可能な例外を下層でキャッチすることを強要すべきではないということです。多くのシステムでは、検査されない例外と致命的な例外は、コールスタックの最初のフレームの１つ （例えば、最上位の層で） でハンドリングし、エラーメッセージをアプリケーションユーザーに表示します （もしくは、他の適切な処理を実施します） 。 Hibernate は、<code class="literal">HibernateException</code> 以外の検査されない例外も投げることに注意してください。これらもまた、回復不可能であり、適切な処理を実施すべきです。 </p><p>Hibernate は、データベースとの対話中に投げられた <code class="literal">SQLException</code> を <code class="literal">JDBCException</code> でラップします。実は、例外をより意味のある <code class="literal">JDBCException</code> のサブクラスに変換しようと試みます。元の <code class="literal">SQLException</code> は、 <code class="literal">JDBCException.getCause()</code> によりいつでも得られます。 Hibernate は、 <code class="literal">SessionFactory</code> に追加されている <code class="literal">SQLExceptionConverter</code> を使い、 <code class="literal">SQLException</code> を適当な <code class="literal">JDBCException</code> サブクラスに変換します。デフォルトでは、 <code class="literal">SQLExceptionConverter</code> は設定されている SQL 方言により定義されます。一方で、独自の実装に差し替えることもできます （詳細は、 <code class="literal">SQLExceptionConverterFactory</code> クラスの Javadoc を参照してください）。標準的な <code class="literal">JDBCException</code> のサブタイプを下記に示します。 </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code> - 基礎となる JDBC 通信のエラーを表します。 </p></li><li><p><code class="literal">SQLGrammarException</code> - 発行する SQL の文法もしくは構文の問題を表します。 </p></li><li><p><code class="literal">ConstraintViolationException</code> - 何らかの形式の完全性制約違反を表します。 </p></li><li><p><code class="literal">LockAcquisitionException</code> - 要求された操作を実施するのに必要なロックレベルを得る際のエラーを表します。 </p></li><li><p><code class="literal">GenericJDBCException</code> - 他のカテゴリに一致しなかった一般的な例外です。 </p></li></ul></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>13.2.4. トランザクションのタイムアウト</h3></div></div></div><p>EJB のような管理された環境が提供するきわめて重要な特徴の１つは、トランザクションのタイムアウトです。これは管理されていないコードには提供できません。トランザクションタイムアウトは、不品行なトランザクションがユーザーにレスポンスを返さないまま、無期限にリソースを使い続けないことを保障します。管理された環境 （JTA） の外では、 Hibernate はこの機能をフルに提供できません。しかしながら、 Hibernate は次のようなデータアクセス操作の制御くらいはできます。データベースレベルのデッドロックや大きなリザルトセットを返すクエリを定義されたタイムアウトによって確実に制限します。管理された環境では、 Hibernate はトランザクションタイムアウトを JTA に委譲します。この機能は、 Hibernate の <code class="literal">Transaction</code> オブジェクトによって抽象化されています。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">set&nbsp;transaction&nbsp;timeout&nbsp;to&nbsp;</span><span class="java_literal">3</span><span class="java_plain">&nbsp;seconds</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">setTimeout</span><span class="java_separator">(</span><span class="java_literal">3</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>CMT Bean の中では <code class="literal">setTimeout()</code> を呼び出せないことに注意してください。トランザクションタイムアウトは宣言的に定義されるべきです。 </p></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>13.3. 楽観的同時実行制御</h2></div></div></div><p>高い並列性と高いスケーラビリティの両方を実現するアプローチは、バージョニングを使った楽観的同時実行制御のみです。更新の衝突を見つけるために（および、更新が失われるのを防ぐために）、バージョン番号もしくはタイムスタンプを使って、バージョンをチェックします。 Hibernate は、楽観的同時実行を行うアプリケーションコードを書くためのアプローチを３つ提供します。私たちが見せるユースケースは、長い対話を持ちますが、バージョンチェックはまだ１つのデータベーストランザクションの中で更新を失うことを防ぐ利点も持っています。 </p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>13.3.1. アプリケーションによるバージョンチェック</h3></div></div></div><p>Hibernate にほとんど助けてもらわずに実装するケースです。データベースとのやり取りは、それぞれ新しい <code class="literal">Session</code> の中で起こります。開発者は、すべての永続性インスタンスを操作する前に、データベースから再読み込みする責務があります。このアプローチでは、対話トランザクションの分離を守るために、アプリケーション自身がバージョンチェックを行う必要があります。このアプローチは、データベースアクセスの中では、最も非効率です。エンティティ EJB と最も似ているアプローチです。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">int</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">,</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getKey</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;load&nbsp;the&nbsp;current&nbsp;state</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StaleObjectStateException</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p><code class="literal">&lt;version&gt;</code> を使って、 <code class="literal">version</code> プロパティをマッピングします。 Hibernate は、エンティティがダーティである場合、フラッシュし、その間に <code class="literal">version</code> プロパティを自動的にインクリメントします。 </p><p>もちろん、データの並列性が低い環境で運用しており、バージョンチェックが不要なら、このアプローチを使い、バージョンチェックをスキップするだけです。その場合は、長い対話には、 <span class="emphasis"><em>最後にコミットしたものが勝つ</em></span> がデフォルトの戦略でしょう。このアプローチは、アプリケーションのユーザーを混乱させるかもしれないことを心に留めて置いてください。それは、エラーメッセージや競合した変更をマージする機会がないまま、更新を失う可能性があるからです。 </p><p>確かに、マニュアルによるバージョンチェックは、些細な儀式だけで実行できますが、多くのアプリケーションにとって実用的ではありません。しばしば、１つのインスタンスだけでなく、修正されたオブジェクトの完全なグラフをチェックしなければなりません。 Hibernate は、設計パラダイムとして、拡張 <code class="literal">Session</code> か分離されたインスタンスを自動的にバージョンチェックします。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>13.3.2. 拡張セッションと自動バージョニング</h3></div></div></div><p>１つの <code class="literal">Session</code> インスタンスとその永続性インスタンスは、 <span class="emphasis"><em>session-per-conversation</em></span> として知られる、対話全体で使われます。 Hibernate はフラッシュする際に、インスタンスのバージョンをチェックします。同時に修正されたことを検出すると、例外を投げます。この例外をキャッチして扱うのは、開発者の責任です （一般的な選択肢は、変更をマージするか古くないデータでビジネス対話を再スタートする機会をユーザーに提供することです）。 </p><p>ユーザーの対話を待っているときは、 <code class="literal">Session</code> を基礎となる JDBC コネクションから切り離します。このアプローチは、データベースアクセスの中では、最も効率的です。アプリケーションは、バージョンチェックや分離されたインスタンスを再追加することに関心を持つ必要はありません。また、あらゆるデータベーストランザクションの中でインスタンスを再読み込みする必要はありません。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;earlier&nbsp;by&nbsp;the&nbsp;old&nbsp;session</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Obtain</span><span class="java_plain">&nbsp;a&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;start&nbsp;transaction</span>
</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Also</span><span class="java_plain">&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span></pre><p><code class="literal">foo</code> オブジェクトは、自分をロードした <code class="literal">Session</code> をまだ知っています。古いセッションの上で新しいデータベーストランザクションを開始することで、新しいコネクションを取得し、そのセッションが再開されます。データベーストランザクションをコミットすることで、セッションから JDBC コネクションを切断し、コネクションをプールに返します。再接続した後、更新していないデータのバージョンチェックを強制するために、他のトランザクションにより更新されているかもしれないオブジェクトに関して、 <code class="literal">LockMode.READ</code> をつけて <code class="literal">Session.lock()</code> を呼び出すことができます。更新して <span class="emphasis"><em>いる</em></span> データをロックする必要はありません。通常、拡張 <code class="literal">Session</code> に <code class="literal">FlushMode.MANUAL</code> をセットします。最後のデータベーストランザクションの周期でのみ、対話の中で変更されたすべてを実際に永続化させるためです。ゆえに、最後のデータベーストランザクションのみ <code class="literal">flush()</code> オペレーションを含みます。そして、対話を終わらせるために、セッションも <code class="literal">close()</code> します。 </p><p>ユーザーが考慮中に、格納することができないくらい <code class="literal">Session</code> が大きいのであれば、このパターンは問題があります。例えば、 <code class="literal">HttpSession</code> は可能な限り小さく保つべきです。 <code class="literal">Session</code> は （強制的に） １次キャッシュでもあり、ロードしたオブジェクトをすべて保持します。おそらく、リクエスト／レスポンスのサイクルが数回であれば、この戦略が使えます。１つの対話のためだけに <code class="literal">Session</code> を使うべきです。なぜなら、すぐに新鮮でないデータを持つためです。 </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注記</h2><p>Hibernate の以前のバージョンは、明示的な <code class="literal">Session</code> の切断と再接続が必要だったことに注意してください。これらのメソッドは非推奨になりました。なぜなら、トランザクションの開始と終了は同じ効果があるためです。 </p></div><p>切断した <code class="literal">Session</code> を永続化層の近くで保持すべきであることに注意してください。言い換えると、３層環境の中で <code class="literal">Session</code> を保持するために、 EJB ステートフルセッション Bean を使ってください。 <code class="literal">HttpSession</code> に格納するために、 Web 層に転送しないでください （別の層へのシリアライズもしないでください）。 </p><p>拡張セッションパターン （もしくは、 <span class="emphasis"><em>session-per-conversation</em></span> ） は、自動的なカレントセッションコンテキスト管理を実施するより難しい。このために、あなたは <code class="literal">CurrentSessionContext</code> の実装を供給する必要があります。 Hibernate Wiki にある例を参照してください。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>13.3.3. デタッチされたオブジェクトと自動バージョニング</h3></div></div></div><p>新しい <code class="literal">Session</code> により、永続化ストア （訳注：ＤＢ） との対話が発生します。また一方、同じ永続性インスタンスが、データベースとの対話ごとに再利用されます。アプリケーションは、元々は他の <code class="literal">Session</code> でロードされ、デタッチされたインスタンスの状態を操作します。そして、 <code class="literal">Session.update()</code> もしくは、 <code class="literal">Session.saveOrUpdate()</code> 、 <code class="literal">Session.merge()</code> を使って、それらのインスタンスを再追加します。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">saveOrUpdate</span><span class="java_separator">(</span><span class="java_plain">foo</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Use</span><span class="java_plain">&nbsp;merge</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;foo&quot;</span><span class="java_plain">&nbsp;might&nbsp;have&nbsp;been&nbsp;loaded&nbsp;already</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>この場合もやはり、 Hibernate はフラッシュする際に、インスタンスのバージョンをチェックします。更新の競合が発生した場合には、例外を投げます。 </p><p>オブジェクトが修正されていないことを確信している場合は、 <code class="literal">update()</code> の代わりに、 <code class="literal">LockMode.READ</code> を使って、 <code class="literal">lock()</code> を呼び出すこともできます （すべてのキャッシュを迂回し、バージョンチェックを実施します）。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>13.3.4. 自動バージョニングのカスタマイズ</h3></div></div></div><p>マッピングの <code class="literal">optimistic-lock</code> 属性に <code class="literal">false</code> を設定することにより、特定のプロパティやコレクションのために自動バージョンインクリメントを無効にできます。プロパティがダーティであっても、バージョンをインクリメントしません。 </p><p>レガシーのデータベーススキーマは、しばしば固定的であり、変更できません。または、他のアプリケーションが同じデータベースにアクセスしなければならず、そのアプリケーションはバージョン番号やタイムスタンプさえ操作する方法を知りません。どちらの場合も、テーブルの特定のカラムを当てにして、バージョニングを行えません。バージョンやタイムスタンプのプロパティをマッピングせずに、バージョンチェックさせるために、 <code class="literal">&lt;class&gt;</code> マッピングに <code class="literal">optimistic-lock="all"</code> を指定してください。行のすべてのフィールドの状態を比較するようになります。これは、 Hibernate が古い状態と新しい状態を比較できる場合に、理論的に動作するだけであることに注意してください。例えば、 session-per-request-with-detached-objects ではなく、１つの長い <code class="literal">Session</code> を使う場合です。 </p><p>ときどき、行われた変更が重ならない限り、同時に行われた変更を受け入れることができます。 <code class="literal">&lt;class&gt;</code> マッピングに <code class="literal">optimistic-lock="dirty"</code> を設定した場合、フラッシュする際に、 Hibernate はダーティフィールドのみを比較します。 </p><p>専用のバージョン／タイムスタンプのカラムを使う場合、もしくはすべて／ダーティのフィールドを比較する場合どちらであっても、 Hibernate はエンティティごとに1つの <code class="literal">UPDATE</code> 文を （適切な <code class="literal">WHERE</code> 節と共に） 使い、バージョンチェックと情報の更新を行います。関連するエンティティの再追加をカスケードするために、連鎖的な永続化を使用した場合、不必要な更新を実行するかもしれません。これは通常問題になりません。しかし、分離したインスタンスを変更していなくとも、データベースの <span class="emphasis"><em>on update</em></span> トリガーが実行されるかもしれません。 <code class="literal">&lt;class&gt;</code> マッピングに <code class="literal">select-before-update="true"</code> を設定することによって、この振る舞いをカスタマイズできます。確実に変更されたかを確認するために、行を更新する前に、必ずインスタンスを <code class="literal">SELECT</code> します。 </p></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>13.4. 悲観的ロック</h2></div></div></div><p>ユーザーがロック戦略に悩むのに多くの時間を費やすことを意図していません。通常は、 JDBC コネクションに分離レベルを指定し、単にデータベースにすべての仕事をさせれば十分です。しかしながら、高度なユーザーは、排他的な悲観的ロックを獲得することか、新しいトランザクションが開始される際にロックを再獲得することをときどき望むかもしれません。 </p><p>Hibernate はいつもデータベースのロックの仕組みを使います。メモリ内のオブジェクトを決してロックしません。 </p><p><code class="literal">LockMode</code> クラスは、 Hibernate が獲得できる異なるロックレベルを定義します。以下の仕組みにより、ロックを獲得できます。 </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode.WRITE</code> は、 Hibernate が行を更新もしくは挿入する際に自動的に得られます。 </p></li><li><p><code class="literal">LockMode.UPGRADE</code> は、データベースでサポートされている文法 <code class="literal">SELECT ... FOR UPDATE</code> を使った、明示的なユーザー要求により得られるかもしれません。 </p></li><li><p><code class="literal">LockMode.UPGRADE_NOWAIT</code> は、 Oracle で <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> を使った、明示的なユーザー要求により得られるかもしれません。 </p></li><li><p><code class="literal">LockMode.READ</code> は、 Repeatable Read もしくは Serializable の分離レベルで、データを読んだ際に自動的に得られます。おそらく、明示的なユーザー要求により、再取得されます。 </p></li><li><p><code class="literal">LockMode.NONE</code> は、ロックしないことを表します。 <code class="literal">Transaction</code> の終わりに、すべてのオブジェクトはこのロックモードに切り替わります。 <code class="literal">update()</code> や <code class="literal">saveOrUpdate()</code> を呼び出すことによって、セッションに関連付けられたオブジェクトも、このロックモードで出発します。 </p></li></ul></div><p>「明示的なユーザー要求」とは、下記の方法の１つで言い表せます。 </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode</code> を指定した <code class="literal">Session.load()</code> の呼び出し。 </p></li><li><p><code class="literal">Session.lock()</code> の呼び出し。 </p></li><li><p><code class="literal">Query.setLockMode()</code> の呼び出し。 </p></li></ul></div><p><code class="literal">UPGRADE</code> もしくは <code class="literal">UPGRADE_NOWAIT</code> が指定された <code class="literal">Session.load()</code> が呼び出され、かつ要求されたオブジェクトがセッションによってまだロードされていなかった場合は、 <code class="literal">SELECT ... FOR UPDATE</code> を使って、オブジェクトがロードされます。 <code class="literal">load()</code> で呼び出されたオブジェクトが、要求されているより制限が少ないロックですでにロードされていた場合は、 Hibernate はそのオブジェクトのために、 <code class="literal">lock()</code> を呼び出します。 </p><p>指定されたロックモードが <code class="literal">READ</code> もしくは、 <code class="literal">UPGRADE</code> 、 <code class="literal">UPGRADE_NOWAIT</code> だった場合、 <code class="literal">Session.lock()</code> は、バージョン番号のチェックを実施します。 （<code class="literal">UPGRADE</code> もしくは <code class="literal">UPGRADE_NOWAIT</code> の場合、 <code class="literal">SELECT ... FOR UPDATE</code> が使われます。） </p><p>データベースが要求されたロックモードをサポートしていない場合、 Hibernate は（例外を投げる代わりに、）適切な代わりのモードを使います。これは、アプリケーションがポータブルであることを保証します。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>13.5. コネクション開放モード</h2></div></div></div><p>Hibernate のレガシー（2.x）の JDBC コネクション管理に関する振る舞いは、最初に必要とした際に <code class="literal">Session</code> がコネクションを得るというものでした。そして、セッションが閉じられるまで、そのコネクションを保持しました。 Hibernate 3.x は、セッションに JDBC コネクションをどのように制御するかを伝えるコネクション開放モードという概念を導入しました。以降の議論は、構成された <code class="literal">ConnectionProvider</code> を通して提供されるコネクションに適切であることに注意してください。異なる開放モードは、 <code class="literal">org.hibernate.ConnectionReleaseMode</code> に列挙された値により確認されます。 </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code> - 本質的に上記で述べたレガシーの振る舞いです。 Hibernate セッションは最初に JDBC アクセスを実行する必要がある際にコネクションを得ます。そして、セッションが閉じられるまで、コネクションを保持します。 </p></li><li><p><code class="literal">AFTER_TRANSACTION</code> - <code class="literal">org.hibernate.Transaction</code> が完了した後、コネクションを開放します。 </p></li><li><p><code class="literal">AFTER_STATEMENT</code> （積極的な開放とも呼ばれる） - すべてのステートメントがそれぞれ実行された後、コネクションが開放されます。ステートメントがセッションに関連するリソースを開いたままにする場合は、この積極的な開放はスキップされます。今のところ、これが起こるのは <code class="literal">org.hibernate.ScrollableResults</code> が使われる場合のみです。 </p></li></ul></div><p>コンフィグレーションパラメータの <code class="literal">hibernate.connection.release_mode</code> は、使用する開放モードを指定するために使います。指定できる値は次の通りです: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code> （デフォルト） - これを選択すると <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code> メソッドによって返される開放モードに委譲されます。このメソッドは、 JTATransactionFactory には ConnectionReleaseMode.AFTER_STATEMENT を返し、 JDBCTransactionFactory には ConnectionReleaseMode.AFTER_TRANSACTION を返します。このデフォルトの振る舞いを変えてうまくいった試しがありません。それは、この設定値が原因で起こる障害は、ユーザーコードの中でバグや間違った条件になりやすいからです。 </p></li><li><p><code class="literal">on_close</code> - ConnectionReleaseMode.ON_CLOSE を使います。この設定は後方互換のために残されていますが、使わないことを強く勧めます。 </p></li><li><p><code class="literal">after_transaction</code> - ConnectionReleaseMode.AFTER_TRANSACTION を使います。この設定は JTA 環境の中では使うべきではありません。 ConnectionReleaseMode.AFTER_TRANSACTION を指定し、自動コミットモードの中では、開放モードが AFTER_STATEMENT であるかのように、コネクションは開放されることに注意してください。 </p></li><li><p><code class="literal">after_statement</code> - ConnectionReleaseMode.AFTER_STATEMENT を使います。さらに、設定された <code class="literal">ConnectionProvider</code> は、この設定 (<code class="literal">supportsAggressiveRelease()</code>) をサポートするかどうかを調べるために使用します。もしそうでない場合、開放モードは ConnectionReleaseMode.AFTER_TRANSACTION にリセットされます。この設定は次の環境でのみ安全です。それは、 <code class="literal">ConnectionProvider.getConnection()</code> を呼び出すたびに基盤となる JDBC コネクションが同じものを取得できるか、同じコネクションが得られることが問題とならない自動コミット環境の中です。 </p></li></ul></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">製作著作 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>前のページ</strong>第12章 Read-only entities</a></li><li class="up"><a accesskey="u" href="#"><strong>上に戻る</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>ホーム</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>次のページ</strong>第14章 インターセプタとイベント</a></li></ul></body></html>