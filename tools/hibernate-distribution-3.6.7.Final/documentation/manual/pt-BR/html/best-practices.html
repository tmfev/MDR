<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 27. Melhores práticas</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="prev" href="example-mappings.html" title="Capítulo 26. Exemplo: Vários Mapeamentos"/><link rel="next" href="portability.html" title="Capítulo 28. Considerações da Portabilidade do Banco de Dados"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="example-mappings.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="portability.html"><strong>Próxima</strong></a></li></ul><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="best-practices"/>Capítulo 27. Melhores práticas</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Escreva classes compactas e mapeie-as usando <code class="literal">&lt;component&gt;</code>:</span></dt><dd><p>Use uma classe <code class="literal">Endereço</code> para encapsular <code class="literal">rua</code>, <code class="literal">bairro</code>, <code class="literal">estado</code>, <code class="literal">CEP</code>. Isto promove a reutilização de código e simplifica o refactoring. </p></dd><dt><span class="term">Declare propriedades identificadoras em classes persistentes:</span></dt><dd><p>O Hibernate constrói propriedades identificadoras opcionais. Existem inúmeras razões para utilizá-las. Nós recomendamos que os identificadores sejam 'sintéticos', quer dizer, gerados sem significado para negócios.  </p></dd><dt><span class="term">Identifique chaves naturais:</span></dt><dd><p>Identifique chaves naturais para todas as entidades, e mapeie-as usando <code class="literal">&lt;natural-id&gt;</code>. Implemente <code class="literal">equals()</code> e <code class="literal">hashCode()</code> para comparar as propriedades que compõem a chave natural. </p></dd><dt><span class="term">Coloque cada classe de mapeamento em seu próprio arquivo:</span></dt><dd><p>Não use um único código de mapeamento monolítico. Mapeie <code class="literal">com.eg.Foo</code> no arquivo <code class="literal">com/eg/Foo.hbm.xml</code>. Isto faz bastante sentido, especialmente em ambiente de equipe. </p></dd><dt><span class="term">Carregue os mapeamentos como recursos:</span></dt><dd><p>Implemente os mapeamentos junto às classes que eles mapeiam. </p></dd><dt><span class="term">Considere a possibilidade de externar as strings de consultas:</span></dt><dd><p>Esta é uma boa prática se suas consultas chamam funções SQL que não sejam ANSI. Externar as strings de consultas para mapear arquivos irá tornar a aplicação mais portável.  </p></dd><dt><span class="term">Use variáveis de vínculo.</span></dt><dd><p>Assim como em JDBC, sempre substitua valores não constantes por "?". Nunca use a manipulação de strings para concatenar valores não constantes em uma consulta. Até melhor, considere a possibilidade de usar parâmetros nomeados nas consultas. </p></dd><dt><span class="term">Não gerencie suas conexões JDBC:</span></dt><dd><p>O Hibernate permite que a aplicação gerencie conexões JDBC, mas esta abordagem deve ser considerada um último recurso. Se você não pode usar os provedores de conexão embutidos, considere fazer sua implementação a partir de <code class="literal">org.hibernate.connection.ConnectionProvider</code>. </p></dd><dt><span class="term">Considere a possibilidade de usar tipos customizados:</span></dt><dd><p>Suponha que você tenha um tipo Java, de alguma biblioteca, que precisa ser persistido mas não provê de acessórios necessários para mapeá-lo como um componente. Você deve implementar <code class="literal">org.hibernate.UserType</code>. Esta abordagem livra o código da aplicação de implementar transformações de/para o tipo Hibernate.  </p></dd><dt><span class="term">Use código manual JDBC nos afunilamentos:</span></dt><dd><p>Nas áreas de desempenho crítico do sistema, alguns tipos de operações podem se beneficiar do uso direto do JDBC. Mas por favor, espere até você <span class="emphasis"><em>saber</em></span> se é um afunilamento. E não suponha que o uso direto do JDBC é necessariamente mais rápido. Se você precisar usar diretamente o JDBC, vale a pena abrir uma <code class="literal">Session</code> do Hibernate, embrulhar a sua operaçäo JDBC como um objeto <code class="literal">org.hibernate.jdbc.Work</code> e usar uma conexão JDBC. De modo que você possa ainda usar a mesma estratégia de transação e ocultar o provedor a conexão. </p></dd><dt><span class="term">Entenda o esvaziamento da <code class="literal">Session</code>:</span></dt><dd><p>De tempos em tempos a sessão sincroniza seu estado persistente com o banco de dados. O desempenho será afetado se este processo ocorrer frequentemente. Você pode algumas vezes minimizar a liberação desnecessária desabilitando a liberação automática ou até mesmo mudando a ordem das consultas e outras operações em uma transação particular.  </p></dd><dt><span class="term">Em uma arquitetura de três camadas, considere o uso de objetos separados:</span></dt><dd><p>Ao usar a arquitetura do bean de sessão/servlet, você pode passar os objetos persistentes carregados no bean de sessão para e a partir da camada servlet/JSP. Use uma nova sessão para manipular cada solicitação. Use a <code class="literal">Session.merge()</code> ou a <code class="literal">Session.saveOrUpdate()</code> para sincronizar objetos com o banco de dados.   </p></dd><dt><span class="term">Em uma arquitetura de duas camadas, considere o uso de contextos de longa persistência:</span></dt><dd><p>As Transações do Banco de Dados precisam ser as mais curtas possíveis para uma melhor escalabilidade. No entanto, é geralmente necessário implementar <span class="emphasis"><em>transações de aplicações</em></span> de longa duração, uma única unidade de trabalho a partir do ponto de vista de um usuário. Uma transação de aplicação pode transpor diversos ciclos de solicitação/resposta de cliente. É comum usar objetos desanexados para implementar as transações de aplicação. Uma outra alternativa, extremamente apropriada em uma arquitetura de duas camadas, é manter um único contato de persistência aberto (sessão) para todo o tempo de vida da transação de aplicação e simplesmente disconectá-lo do JDBC ao final de cada solicitação e reconectá-lo no início de uma solicitação subsequente. Nunca compartilhe uma sessão única com mais de uma transação de aplicação, ou você irá trabalhar com dados antigos. </p></dd><dt><span class="term">Não trate as exceções como recuperáveis:</span></dt><dd><p>Isto é mais uma prática necessária do que uma "melhor" prática. Quando uma exceção ocorre, retorne à <code class="literal">Transaction</code> e feche a <code class="literal">Sessão</code>. Se não fizer isto, o Hibernate não poderá garantir que o estado em memória representará de forma precisa o estado persistente. Como este é um caso especial, não utilize a <code class="literal">Session.load()</code> para determinar se uma instância com dado identificador existe em um banco de dados, use <code class="literal">Session.get()</code> ou então uma consulta.  </p></dd><dt><span class="term">Prefira a busca lazy para associações:</span></dt><dd><p>Use a busca antecipada de forma moderada. Use as coleções proxy e lazy para a maioria das associações para classes que possam não ser completamente mantidas em cache de segundo nível. Para associações de classes em cache, onde existe uma enorme probabilidade de coincidir caches, desabilite explicitamente a busca antecipada usando <code class="literal">lazy="false"</code>. Quando uma busca de união é apropriada para um caso específico, use a consulta com <code class="literal">left join fetch</code>. </p></dd><dt><span class="term">Use o modelo <span class="emphasis"><em>sessão aberta na visualização</em></span>, ou uma <span class="emphasis"><em>fase de construção</em></span> para evitar problemas com dados não encontrados. </span></dt><dd><p>O Hibernate libera o desenvolvedor de escrever <span class="emphasis"><em>Objetos de Transferência de Dados</em></span> (DTO). Em uma arquitetura tradicional EJB, os DTOs servem dois propósitos: primeiro, eles se deparam com o problema de que os beans de entidade não são serializáveis, depois, eles implicitamente definem uma fase de construção onde todos os dados a serem utilizados pelo view são buscados e conduzidos aos DTOs antes mesmo de retornar o controle à camada de apresentação. O Hibernate elimina o primeiro propósito. No entanto, você ainda precisará de uma fase de construção (pense em seus métodos de negócios como tendo um contrato estrito com a camada de apresentação sobre o quais dados estão disponíveis nos objetos desanexados) a não ser que você esteja preparado para manter o contexto de persistência (sessão) aberto no processo de renderização da visualização. Isto não é uma limitação do Hibernate. É uma solicitação fundamental para acesso a dados transacionais seguros. </p></dd><dt><span class="term">Considere abstrair sua lógica comercial do Hibernate:</span></dt><dd><p>Oculte (Hibernate) o código de acesso a dados atrás de uma interface. Combine os modelos <span class="emphasis"><em>DAO</em></span> e <span class="emphasis"><em>Sessão Local de Thread</em></span>. Você pode também persistir algumas classes pelo JDBC handcoded, associado ao Hibernate via um  <code class="literal">UserType</code>. Este é um conselho para aplicações "grandes o suficiente", não é apropriado para uma aplicação com cinco tabelas. </p></dd><dt><span class="term">Não use mapeamentos de associação exóticos:</span></dt><dd><p>Casos de testes práticos para associações muitos-para-muitos reais são raros. A maioria do tempo você precisa de informação adicional armazenada na " tabela de link". Neste caso, é muito melhor usar associações dois um-para-muitos para uma classe de link intermediário. Na verdade, acreditamos que a maioria das associações é um-para-muitos e muitos-para-um, você deve tomar cuidado ao utilizar qualquer outro tipo de associação e perguntar a você mesmo se é realmente necessário.  </p></dd><dt><span class="term">Prefira associações bidirecionais:</span></dt><dd><p>As associações unidirecionais são mais difíceis para pesquisar. Em aplicações grandes, quase todas as associações devem navegar nas duas direções em consultas.  </p></dd></dl></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="example-mappings.html"><strong>Anterior</strong>Capítulo 26. Exemplo: Vários Mapeamentos</a></li><li class="up"><a accesskey="u" href="#"><strong>Acima</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Principal</strong></a></li><li class="next"><a accesskey="n" href="portability.html"><strong>Próxima</strong>Capítulo 28. Considerações da Portabilidade do Ba...</a></li></ul></body></html>