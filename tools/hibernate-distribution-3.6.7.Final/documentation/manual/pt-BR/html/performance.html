<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 21. Aumentando o desempenho</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="prev" href="xml.html" title="Capítulo 20. Mapeamento XML"/><link rel="next" href="toolsetguide.html" title="Capítulo 22. Guia de Toolset"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>Próxima</strong></a></li></ul><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>Capítulo 21. Aumentando o desempenho</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance.html#performance-fetching">21.1. Estratégias de Busca </a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-fetching-lazy">21.1.1. Trabalhando com associações preguiçosas (lazy)</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-custom">21.1.2. Personalizando as estratégias de busca</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-proxies">21.1.3. Proxies de associação final único</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-initialization">21.1.4. Inicializando coleções e proxies</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-batch">21.1.5. Usando busca em lote</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-subselect">21.1.6. Usando busca de subseleção</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-profiles">21.1.7. Perfis de Busca </a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-lazyproperties">21.1.8. Usando busca preguiçosa de propriedade</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-cache">21.2. O Cachê de Segundo Nível</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-cache-mapping">21.2.1. Mapeamento de Cache</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-readonly">21.2.2. Estratégia: somente leitura</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-readwrite">21.2.3. Estratégia: leitura/escrita</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-nonstrict">21.2.4. Estratégia: leitura/escrita não estrita</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-transactional">21.2.5. Estratégia: transacional</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-compat-matrix">21.2.6. Compatibilidade de Estratégia de Concorrência de Cache Provedor</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-sessioncache">21.3. Gerenciando os caches</a></span></dt><dt><span class="section"><a href="performance.html#performance-querycache">21.4. O Cache de Consulta</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-querycache-enable">21.4.1. Ativação do cache de consulta</a></span></dt><dt><span class="section"><a href="performance.html#performance-querycache-regions">21.4.2. Regiões de cache de consulta</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-collections">21.5. Entendendo o desempenho da Coleção</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-collections-taxonomy">21.5.1. Taxonomia</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-mostefficientupdate">21.5.2. Listas, mapas, bags de id e conjuntos são coleções mais eficientes para atualizar</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-mostefficentinverse">21.5.3. As Bags e listas são as coleções de inversão mais eficientes.</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-oneshotdelete">21.5.4. Deletar uma vez</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-monitoring">21.6. Monitorando desempenho</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-monitoring-sf">21.6.1. Monitorando uma SessionFactory</a></span></dt><dt><span class="section"><a href="performance.html#performance-monitoring-metrics">21.6.2. Métricas</a></span></dt></dl></dd></dl></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>21.1. Estratégias de Busca </h2></div></div></div><p>Uma <span class="emphasis"><em>estratégia de busca</em></span> é a estratégia que o Hibernate irá usar para recuperar objetos associados se a aplicação precisar navegar pela associação. Estratégias de Busca podem ser declaradas nos metadados de mapeamento O/R, ou sobrescritos por uma consulta HQL ou consulta com <code class="literal">Criteria</code>. </p><p>Hibernate3 define as seguintes estratégias de busca:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Join fetching</em></span> - o Hibernate busca o objeto ou coleção associada no mesmo <code class="literal">SELECT</code>, usando um <code class="literal">OUTER JOIN</code>. </p></li><li><p><span class="emphasis"><em>Select fetching</em></span> - um segundo <code class="literal">SELECT</code> é usado para buscar a entidade ou coleção associada. A menos que você desabilite a busca lazy, especificando <code class="literal">lazy="false"</code>, esse segundo SELECT será executado apenas quando você acessar a associação. </p></li><li><p><span class="emphasis"><em>Subselect fetching</em></span> - um segundo <code class="literal">SELECT</code> será usado para recuperar as coleções associadas de todas as entidades recuperadas em uma consulta ou busca anterior. A menos que você desabilite a busca lazy especificando <code class="literal">lazy="false"</code>, esse segundo SELECT será executado apenas quando você acessar a associação.  </p></li><li><p><span class="emphasis"><em>Batch fetching</em></span> - uma opção de otimização para selecionar a busca. O Hibernate recupera um lote de instâncias ou entidades usando um único <code class="literal">SELECT</code>, especificando uma lista de chaves primárias ou chaves externas.</p></li></ul></div><p>O Hibernate distingue também entre:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Immediate fetching</em></span> - uma associação, coleção ou função é imediatamente recuperada, quando o proprietário for carregado. </p></li><li><p><span class="emphasis"><em>Lazy collection fetching</em></span> - a coleção é recuperada quando a aplicação invoca uma operação sobre aquela coleção. Esse é o padrão para coleções.</p></li><li><p><span class="emphasis"><em>"Extra-lazy" collection fetching</em></span> - elementos individuais de uma coleção são acessados a partir do banco de dados quando necessário. O Hibernate tenta não buscar a coleção inteira dentro da memória a menos que seja absolutamente necessário. Isto é indicado para coleções muito grandes.</p></li><li><p><span class="emphasis"><em>Proxy fetching</em></span>: uma associação de um valor é carregada quando um método diferente do getter do identificador é invocado sobre o objeto associado.</p></li><li><p><span class="emphasis"><em>"No-proxy" fetching</em></span> - uma associação de um único valor é recuperada quando a variável da instância é acessada. Comparada à busca proxy, esse método é menos preguiçoso (lazy); a associação é buscada até mesmo quando somente o identificador é acessado. Ela é mais transparente, já que não há proxies visíveis para a aplicação. Esse método requer instrumentação de bytecodes em build-time e é raramente necessário.</p></li><li><p><span class="emphasis"><em>Lazy attribute fetching</em></span>: um atributo ou associação de um valor é buscado quanto a varíavel da instância é acessada. Esse método requer instrumentação de bytecodes em build-time e é raramente necessário.</p></li></ul></div><p>Nós temos aqui duas noções ortogonais: <span class="emphasis"><em>quando</em></span> a associação é buscada e <span class="emphasis"><em>como</em></span> ela é buscada. É importante que você não os confuda. Nós usamos <code class="literal">fetch</code> para ajustar o desempenho. Podemos usar <code class="literal">lazy</code> para definir um contrato para qual dado é sempre disponível em qualquer instância desconectada de uma classe particular.</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>21.1.1. Trabalhando com associações preguiçosas (lazy)</h3></div></div></div><p>Por padrão, o Hibernate3 usa busca preguiçosa para coleções e busca preguiçosa com proxy para associações de um valor. Esses padrões fazem sentido para quase todas as associações em quase todas a aplicações. </p><p>Se você ajustar <code class="literal">hibernate. default_batch_fetch_size</code>, o Hibernate irá usar otimização de busca em lote para a busca preguiçosa. Essa otimização pode ser também habilitada em um nível mais fino.</p><p>Perceba que o acesso a associações preguiçosas fora do contexto de uma sessão aberta do Hibernate irá resultar numa exceção. Por exemplo:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">s&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessions</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">openSession</span><!-- <br/> --><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_type">User</span><span class="java_plain">&nbsp;u&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">User</span><span class="java_separator">)</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;from&nbsp;User&nbsp;u&nbsp;where&nbsp;u.name=:userName&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setString</span><span class="java_separator">(</span><span class="java_literal">&quot;userName&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;userName</span><span class="java_separator">).</span><span class="java_plain">uniqueResult</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Map</span><span class="java_plain">&nbsp;permissions&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;u</span><span class="java_separator">.</span><span class="java_plain">getPermissions</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">s</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">Integer</span><span class="java_plain">&nbsp;accessLevel&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Integer</span><span class="java_separator">)</span><span class="java_plain">&nbsp;permissions</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">&quot;accounts&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Error</span><span class="java_operator">!</span></pre><p>Como a coleção de permissões não foi inicializada quando a <code class="literal">Session</code> for fechada, a coleção não poderá carregar o seu estado. <span class="emphasis"><em>O Hibernate não suporta inicialização preguiçosa para objetos desconectados</em></span>. Para consertar isso, é necessário mover o código que carrega a coleção para logo antes da transação ser submetida. </p><p>Alternativamente, nós podemos usar uma coleção ou associação não preguiçosa, especificando <code class="literal">lazy="false"</code> para o mapeamento da associação. Porém, é pretendido que a inicialização preguiçosa seja usada por quase todas as coleções e associações. Se você definir muitas associações não preguiçosas em seu modelo de objetos, o Hibernate irá precisar buscar no banco de dados inteiro da memória em cada transação.</p><p>Por outro lado, nós geralmente escolhemos a busca de união (que não é preguiçosa por natureza) ao invés do selecionar busca em uma transação particular. Nós agora veremos como customizar a estratégia de busca. No Hibernate3, os mecanismos para escolher a estratégia de busca são idênticos para as associações de valor único e para coleções.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>21.1.2. Personalizando as estratégias de busca</h3></div></div></div><p>O padrão selecionar busca, é extremamente vunerável aos problemas de seleção N+1, então habilitaremos a busca de união no documento de mapeamento:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;permissions&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">fetch</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;userId&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Permission&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;mother&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">fetch</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>A estratégia de <code class="literal">fetch</code> definida no documento de mapeamento afeta:</p><div class="itemizedlist"><ul><li><p>recupera via <code class="literal">get()</code> ou <code class="literal">load()</code></p></li><li><p>Recuperações que acontecem implicitamente quando navegamos por uma associação</p></li><li><p>consultas por <code class="literal">Criteria</code> </p></li><li><p>consultas HQL se a busca por <code class="literal">subselect</code> for usada</p></li></ul></div><p>Independentemente da estratégia de busca que você usar, o gráfico não preguiçoso definido será certamente carregado na memória. Note que isso irá resultar em diversas seleções imediatas sendo usadas para rodar uma consulta HQL em particular.</p><p>Geralmente, não usamos documentos de mapeamento para customizar as buscas. Ao invés disso, nós deixamos o comportamento padrão e sobrescrevemos isso em uma transação em particular, usando <code class="literal">left join fetch</code> no HQL. Isso diz ao Hibernate para buscar a associação inteira no primeiro select, usando uma união externa. Na API de busca <code class="literal">Criteria</code>, você irá usar <code class="literal">setFetchMode(FetchMode.JOIN)</code>.</p><p>Se você quiser mudar a estratégia de busca usada pelo <code class="literal">get()</code> ou <code class="literal">load()</code>, simplesmente use uma consulta por <code class="literal">Criteria</code>, por exemplo: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_plain">&nbsp;user&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createCriteria</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setFetchMode</span><span class="java_separator">(</span><span class="java_literal">&quot;permissions&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">FetchMode</span><span class="java_separator">.</span><span class="java_plain">JOIN</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Restrictions</span><span class="java_separator">.</span><span class="java_plain">idEq</span><span class="java_separator">(</span><span class="java_plain">userId</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">uniqueResult</span><span class="java_separator">();</span></pre><p>Isto é o equivalente do Hibernate para o que algumas soluções ORM chamam de "plano de busca".</p><p>Um meio totalmente diferente de evitar problemas com selects N+1 é usar um cache de segundo nível. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>21.1.3. Proxies de associação final único</h3></div></div></div><p>A recuperação preguiçosa para coleções é implementada usando uma implementação própria do Hibernate para coleções persistentes. Porém, é necessário um mecanismo diferente para comportamento preguiçoso em associações de final único. A entidade alvo da associação precisa usar um proxy. O Hibernate implementa proxies para inicialização preguiçosa em objetos persistentes usando manipulação de bytecode, através da excelente biblioteca CGLIB. </p><p>Por padrão, o Hibernate3 gera proxies (na inicialização) para todas as classes persistentes que os usem para habilitar recuperação preguiçosa de associações <code class="literal">many-to-one</code> e <code class="literal">one-to-one</code>. </p><p>O arquivo de mapeamento deve declarar uma interface para usar como interface de proxy para aquela classe, com a função <code class="literal">proxy</code>. Por padrão, o Hibernate usa uma subclasse dessa classe. <span class="emphasis"><em>Note que a classe a ser usada via proxy precisa implementar o construtor padrão com pelo menos visibilidade de package. Nós recomendamos esse construtor para todas as classes persistentes</em></span>.</p><p>Existe alguns truques que você deve saber quando estender esse comportamento para classes polimórficas. Por exemplo:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Primeiramente, instâncias de <code class="literal">Cat</code> nunca serão convertidas para <code class="literal">DomesticCat</code>, mesmo que a instância em questão seja uma instância de <code class="literal">DomesticCat</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;instantiate&nbsp;a&nbsp;proxy&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">does&nbsp;not&nbsp;hit&nbsp;the&nbsp;db</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cat</span><span class="java_separator">.</span><span class="java_plain">isDomesticCat</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;hit&nbsp;the&nbsp;db&nbsp;to&nbsp;initialize&nbsp;the&nbsp;proxy</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;dc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cat</span><span class="java_separator">;</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Error</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">....</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>E, segundo, é possível quebrar o proxy <code class="literal">==</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;instantiate&nbsp;a&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;proxy</span>
<!--  --><br/><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;dc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;id</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;acquire&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;proxy</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_operator">==</span><span class="java_plain">dc</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span></pre><p>Porém a situação não é tão ruim como parece. Mesmo quando temos duas referências para objetos proxies diferentes, a instância adjacente será do mesmo objeto:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">setWeight</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">11.0</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;hit&nbsp;the&nbsp;db&nbsp;to&nbsp;initialize&nbsp;the&nbsp;proxy</span>
<!--  --><br/><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">&nbsp;dc</span><span class="java_separator">.</span><span class="java_plain">getWeight</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_literal">11.0</span></pre><p>E por terceiro, você não pode usar um proxy CGLIB em uma classe <code class="literal">final</code> ou com quaisquer métodos <code class="literal">final</code>.</p><p>Finalmente, se o seu objeto persistente adquirir qualquer recurso durante a instanciação (ex. em inicializadores ou construtor padrão), então esses recursos serão adquiridos pelo proxy também. A classe de proxy é uma subclasse da classe persistente. </p><p>Esses problemas se dão devido à limitação originária do modelo de herança simples do Java. Se você quiser evitar esses problemas em suas classes persistentes você deve implementar uma interface que declare seus métodos comerciais. Você deve especificar essas interfaces no arquivo de mapeamento onde <code class="literal">CatImpl</code> implementa a interface <code class="literal">Cat</code> e <code class="literal">DomesticCatImpl</code> implementa a interface <code class="literal">DomesticCat</code>. Por exemplo: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CatImpl&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCatImpl&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Então, os proxies para instâncias de <code class="literal">Cat</code> e  <code class="literal">DomesticCat</code> podem ser retornadas pelo <code class="literal">load()</code> ou <code class="literal">iterate()</code>.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">CatImpl</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Iterator</span><span class="java_plain">&nbsp;iter&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;from&nbsp;CatImpl&nbsp;as&nbsp;cat&nbsp;where&nbsp;cat.name='fritz'&quot;</span><span class="java_separator">).</span><span class="java_plain">iterate</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Cat</span><span class="java_plain">&nbsp;fritz&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;iter</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">();</span></pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p><code class="literal">list()</code> normalmente retorna proxies.</p></div><p>Relacionamentos são também inicializados de forma preguiçosa. Isso significa que você precisa declarar qualquer propriedade como sendo do tipo <code class="literal">Cat</code>, e não <code class="literal">CatImpl</code>.</p><p>Algumas operações <span class="emphasis"><em>não</em></span> requerem inicialização por proxy: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code>: se a classe persistente não sobrescrever <code class="literal">equals()</code></p></li><li><p><code class="literal">hashCode()</code>: se a classe persistente não sobrescrever <code class="literal">hashCode()</code></p></li><li><p>O método getter do identificador</p></li></ul></div><p>O Hibernate irá detectar classes persistentes que sobrescrevem <code class="literal">equals()</code> ou <code class="literal">hashCode()</code>.</p><p>Escolhendo <code class="literal">lazy="no-proxy"</code> ao invés do padrão <code class="literal">lazy="proxy"</code>, podemos evitar problemas associados com typecasting. Porém, iremos precisar de instrumentação de bytecode em tempo de compilação e todas as operações irão resultar em inicializações de proxy imediatas. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>21.1.4. Inicializando coleções e proxies</h3></div></div></div><p>Será lançada uma <code class="literal">LazyInitializationException</code> se uma coleção não inicializada ou proxy for acessado fora do escopo da <code class="literal">Session</code>, isto é, quando a entidade que contém a coleção ou que possua a referência ao proxy estiver no estado desanexado. </p><p>Algumas vezes precisamos garantir que o proxy ou coleção é inicializado antes de fechar a <code class="literal">Session</code>. Claro que sempre podemos forçar a inicialização chamando <code class="literal">cat.getSex()</code> ou <code class="literal">cat.getKittens().size()</code>, por exemplo. Mas isto parece confuso para quem lê o código e não é conveniente para códigos genéricos. </p><p>Os métodos estáticos <code class="literal">Hibernate.initialize()</code> e <code class="literal">Hibernate.isInitialized()</code> favorecem a aplicação para trabalhar com coleções ou proxies inicializados de forma preguiçosa. O <code class="literal">Hibernate.initialize(cat)</code> irá forçar a inicialização de um proxy, <code class="literal">cat</code>, contanto que a <code class="literal">Session</code> esteja ainda aberta. <code class="literal">Hibernate.initialize (cat.getKittens() )</code> tem um efeito similar para a coleção de kittens. </p><p>Uma outra opção é manter a <code class="literal">Session</code> aberta até que todas as coleções e os proxies necessários sejam carregados. Em algumas arquiteturas de aplicações, particularmente onde o código que acessa os dados usando Hibernate e o código que os usa, se encontram em diferentes camadas da aplicação ou diferentes processos físicos, será um problema garantir que a <code class="literal">Session</code> esteja aberta quando uma coleção for inicializada. Existem dois caminhos básicos para lidar com esse problema: </p><div class="itemizedlist"><ul><li><p>Em uma aplicações web, um filtro servlet pode ser usado para fechar a <code class="literal">Session</code> somente no final da requisição do usuário, quando a renderização da view estiver completa (o modelo <span class="emphasis"><em>Abrir Sessão em View</em></span>). Claro, que isto demanda uma exatidão no manuseio de exceções na infraestrutura de sua aplicação. É extremamente importante que a <code class="literal">Session</code> seja fechada e a transação terminada antes de retornar para o usuário, mesmo que uma exceção ocorra durante a renderização da view. Veja o Wiki do Hibernate para exemplos do pattern "Abrir Sessão em View".</p></li><li><p>Em uma aplicação com uma camada de negócios separada, a lógica de negócios deve "preparar" todas as coleções que serão usadas pela camada web antes de retornar. Isto sgnifica que a camada de negócios deve carregar todos os dados e retorná-los já inicializados para a camada de apresentação que é representada para um caso de uso particular. Geralmente, a aplicação chama <code class="literal">Hibernate.initialize()</code> para cada coleção que será usada pela camada web (essa chamada deve ocorrer antes da sessão ser fechada) ou retorna a coleção usando uma consulta Hibernate com uma cláusula <code class="literal">FETCH</code> ou um <code class="literal">FetchMode.JOIN</code> na <code class="literal">Criteria</code>. Fica muito mais fácil se você adotar o modelo <span class="emphasis"><em>Command</em></span> ao invés do <span class="emphasis"><em>Session Facade</em></span>. </p></li><li><p>Você também pode anexar um objeto previamente carregado em uma nova <code class="literal">Session</code><code class="literal">merge()</code> ou <code class="literal">lock()</code> antes de acessar coleções não inicializadas (ou outros proxies). O Hibernate não faz e certamente <code class="literal">não deve</code> fazer isso automaticamente, pois isso introduziria semântica em transações  impromptu.</p></li></ul></div><p>Às vezes você não quer inicializar uma coleção muito grande, mas precisa de algumas informações, como o mesmo tamanho, ou um subconjunto de seus dados.</p><p>Você pode usar um filtro de coleção para saber seu tamanho sem inicializá-la:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">list</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">get</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">0</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p>O método <code class="literal">createFilter()</code> é usado também para retornar algus dados de uma coleção eficientemente sem precisar inicializar a coleção inteira:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;lazyCollection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">setFirstResult</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">0</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">setMaxResults</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">10</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">list</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>21.1.5. Usando busca em lote</h3></div></div></div><p>O Hibernate pode fazer uso eficiente de busca em lote, ou seja o Hibernate pode carregar diversos proxies não inicializados, se um proxy for acessado (ou coleções). A busca em lote é uma otimização da estratégia da busca de seleção lazy. Existem duas maneiras para você usar a busca em lote: no nível da classe ou no nível da coleção.</p><p>A recuperação em lote para classes/entidades é mais fácil de entender. Imagine que você tem a seguinte situação em tempo de execução: você tem 25 instâncias de <code class="literal">Cat</code> carregadas em uma <code class="literal">Session</code>, cada <code class="literal">Cat</code> possui uma referência ao seu <code class="literal">owner</code>, que é da classe <code class="literal">Person</code>. A classe <code class="literal">Person</code> é mapeada com um proxy, <code class="literal">lazy="true"</code>. Se você interar sobre todos os Cat's e chamar <code class="literal">getOwner()</code> em cada, o Hibernate irá por padrão executar 25 comandos <code class="literal">SELECT()</code>, para buscar os proxies de owners. Você pode melhorar esse comportamento especificando um <code class="literal">batch-size</code> no mapeamento da classe <code class="literal">Person</code>: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">batch-size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;10&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">...</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>O Hibernate irá executar agora apenas três consultas; o padrão é 10, 10, 5.</p><p>Você também pode habilitar busca em lote de uma coleção. Por exemplo, se cada <code class="literal">Person</code> tem uma coleção preguiçosa de <code class="literal">Cat</code>s e 10 persons estão já carregadas em uma <code class="literal">Session</code>, serão gerados 10 <code class="literal">SELECT</code>s ao se interar todas as persons, um para cada chamada de <code class="literal">getCats()</code>. Se você habilitar busca em lote para a coleção de <code class="literal">cats</code> no mapeamento da classe <code class="literal">Person</code>, o Hibernate pode fazer uma pré carga das coleções:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cats&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">batch-size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;3&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Com um <code class="literal">batch-size</code> de 3, o Hibernate irá carregar 3, 3, 3, 1 coleções em 4 <code class="literal">SELECT</code>s. Novamente, o valor da função depende do número esperado de coleções não inicializadas em determinada <code class="literal">Session</code>.</p><p>A busca em lote de coleções é particularmente útil quando você tem uma árvore encadeada de ítens, ex.: o típico padrão bill-of-materials (Se bem que um <span class="emphasis"><em>conjunto encadeado</em></span> ou <span class="emphasis"><em>caminho materializado</em></span> pode ser uma opção melhor para árvores com mais leitura.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>21.1.6. Usando busca de subseleção</h3></div></div></div><p>Se uma coleção ou proxy simples precisa ser recuperado, o Hibernate carrega todos eles rodando novamente a consulta original em uma subseleção. Isso funciona da mesma maneira que busca em lote, sem carregar tanto.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-profiles"/>21.1.7. Perfis de Busca </h3></div></div></div><p>Another way to affect the fetching strategy for loading associated objects is through something called a fetch profile, which is a named configuration associated with the <code class="interfacename">org.hibernate.SessionFactory</code> but enabled, by name, on the <code class="interfacename">org.hibernate.Session</code>. Once enabled on a <code class="interfacename">org.hibernate.Session</code>, the fetch profile will be in affect for that <code class="interfacename">org.hibernate.Session</code> until it is explicitly disabled.</p><p>So what does that mean? Well lets explain that by way of an example which show the different available approaches to configure a fetch profile:</p><div class="example"><a id="d0e18922"/><p class="title"><b>Exemplo 21.1. Specifying a fetch profile using <code class="classname">@FetchProfile</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">@Entity</span><br />
<span class="xml_plain">@FetchProfile(name&nbsp;=&nbsp;&quot;customer-with-orders&quot;,&nbsp;fetchOverrides&nbsp;=&nbsp;{</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@FetchProfile.FetchOverride(entity&nbsp;=&nbsp;Customer.class,&nbsp;association&nbsp;=&nbsp;&quot;orders&quot;,&nbsp;mode&nbsp;=&nbsp;FetchMode.JOIN)</span><br />
<span class="xml_plain">})</span><br />
<span class="xml_plain">public&nbsp;class&nbsp;Customer&nbsp;{</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@Id</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@GeneratedValue</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;id;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;customerNumber;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@OneToMany</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;Set</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">Order</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;orders;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;//&nbsp;standard&nbsp;getter/setter</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">}</span><br />
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e18929"/><p class="title"><b>Exemplo 21.2. Specifying a fetch profile using <code class="literal">&lt;fetch-profile&gt;</code> outside <code class="literal">&lt;class&gt;</code> node</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cust_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch-profile</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;customer-with-orders&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">entity</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">association</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">style</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetch-profile</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e18940"/><p class="title"><b>Exemplo 21.3. Specifying a fetch profile using <code class="literal">&lt;fetch-profile&gt;</code> inside <code class="literal">&lt;class&gt;</code> node</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cust_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch-profile</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;customer-with-orders&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">association</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">style</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetch-profile</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>Now normally when you get a reference to a particular customer, that customer's set of orders will be lazy meaning we will not yet have loaded those orders from the database. Normally this is a good thing. Now lets say that you have a certain use case where it is more efficient to load the customer and their orders together. One way certainly is to use "dynamic fetching" strategies via an HQL or criteria queries. But another option is to use a fetch profile to achieve that. The following code will load both the customer <span class="emphasis"><em>and</em></span>their orders:</p><div class="example"><a id="d0e18956"/><p class="title"><b>Exemplo 21.4. Activating a fetch profile for a given <code class="classname">Session</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Session</span><!-- <br/> --><span class="java_plain">&nbsp;session&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">...;</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">enableFetchProfile</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;customer-with-orders&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;name&nbsp;matches&nbsp;from&nbsp;mapping</span>
<!--  --><br/><span class="java_type">Customer</span><span class="java_plain">&nbsp;customer&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Customer</span><span class="java_separator">)</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Customer</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;customerId&nbsp;</span><span class="java_separator">);</span>
</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p><code class="classname">@FetchProfile </code>definitions are global and it does not matter on which class you place them. You can place the <code class="classname">@FetchProfile</code> annotation either onto a class or package (package-info.java). In order to define multiple fetch profiles for the same class or package <code class="classname">@FetchProfiles</code> can be used.</p></div><p>Apenas os perfis de busca em estilo são suportados, mas planeja-se o suporte de estilos adicionais. Consulte <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-3414">HHH-3414</a> para maiores detalhes.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>21.1.8. Usando busca preguiçosa de propriedade</h3></div></div></div><p>O Hibernate3 suporta a busca lazy de propriedades individuais. Essa técnica de otimização é também conhecida como <span class="emphasis"><em>grupos de busca</em></span>. Veja que esta é mais uma característica de marketing já que na prática, é mais importante a otimização nas leituras dos registros do que na leitura das colunas. Porém, carregar apenas algumas propriedades de uma classe pode ser útil em casos extremos, onde tabelas legadas podem ter centenas de colunas e o modelo de dados não pode ser melhorado.</p><p>Para habilitar a carga de propriedade lazy, é preciso ajustar a função <code class="literal">lazy</code> no seu mapeamento de propriedade:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Document&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;native&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;50&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;summary&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;200&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">lazy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;text&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;2000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">lazy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>A carga de propriedades lazy requer instrumentação de bytecode. Se suas classes persistentes não forem melhoradas, o Hibernate irá ignorar silenciosamente essa configuração e usará a busca imediata.</p><p>Para instrumentação de bytecode, use a seguinte tarefa do Ant:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">target</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;instrument&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">depends</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;compile&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">taskdef</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;instrument&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">classname</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.tool.instrument.InstrumentTask&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">path</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${jar.path}&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">path</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${classes.dir}&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">refid</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;lib.class.path&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">taskdef</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">instrument</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">verbose</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fileset</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">dir</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${testclasses.dir}/org/hibernate/auction/model&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">include</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;*.class&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fileset</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">instrument</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">target</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Uma forma diferente de evitar leitura de coluna desnecessária, ao menos para transações de somente leitura, deve-se usar os recursos de projeção do HQL ou consultas por Critério. Isto evita a necessidade de processamento de bytecode em build-time e é certamente uma melhor solução.</p><p>Você pode forçar a busca antecipada comum de propriedades usando <code class="literal">buscar todas as propriedades</code> no HQL.</p></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>21.2. O Cachê de Segundo Nível</h2></div></div></div><p>Uma <code class="literal">Session</code> do Hibernate é um cache de nível transacional de dados persistentes. É possível configurar um cluster ou um cache de nível JVM (nível <code class="literal">SessionFactory</code>) em uma estrutura classe por classe e coleção por coleção. Você pode até mesmo plugar em um cache em cluster. Tenha cuidado, pois os caches nunca sabem das mudanças feitas em armazenamento persistente por um outro aplicativo. No entanto, eles podem ser configurados para dados em cache vencido regularmente.</p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed in <a class="xref" href="performance.html#cacheproviders" title="Tabela 21.1. Provedores de Cache">Tabela 21.1, “Provedores de Cache ”</a>. You can also implement your own and plug it in as outlined above. Note that versions prior to Hibernate 3.2 use EhCache as the default cache provider.</p><div class="table"><a id="cacheproviders"/><p class="title"><b>Tabela 21.1. Provedores de Cache </b></p><div class="table-contents"><table summary="Provedores de Cache " border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">Classe de provedor</th><th align="left">Tipo</th><th align="left">Segurança de Cluster</th><th align="left">Cache de Consulta Suportado</th></tr></thead><tbody><tr><td align="left">Hashtable (não recomendado para uso de produção)</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">memória</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">memory, disk, transactional, clustered</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">memória, disco</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">clustered (ip multicast)</td><td align="left">sim (invalidação em cluster)</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">(ip multicast) em cluster, transacional</td><td align="left">sim (replicação)</td><td align="left">sim (solicitação de sync. de relógio)</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc.JBossCacheRegionFactory</code></td><td align="left">(ip multicast) em cluster, transacional</td><td align="left">sim (invalidação ou replicação)</td><td align="left">sim (solicitação de sync. de relógio)</td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>21.2.1. Mapeamento de Cache</h3></div></div></div><p>As we have done in previous chapters we are looking at the two different possibiltites to configure caching. First configuration via annotations and then via Hibernate mapping files.</p><p>By default, entities are not part of the second level cache and we recommend you to stick to this setting. However, you can override this by setting the <code class="literal">shared-cache-mode</code> element in your <code class="filename">persistence.xml</code> file or by using the <code class="literal">javax.persistence.sharedCache.mode </code>property in your configuration. The following values are possible:</p><div class="itemizedlist"><ul><li><p><code class="literal">ENABLE_SELECTIVE</code> (Default and recommended value): entities are not cached unless explicitly marked as cacheable.</p></li><li><p><code class="literal">DISABLE_SELECTIVE</code>: entities are cached unless explicitly marked as not cacheable.</p></li><li><p><code class="literal">ALL</code>: all entities are always cached even if marked as non cacheable.</p></li><li><p><code class="literal">NONE</code>: no entity are cached even if marked as cacheable. This option can make sense to disable second-level cache altogether.</p></li></ul></div><p>The cache concurrency strategy used by default can be set globaly via the <code class="literal">hibernate.cache.default_cache_concurrency_strategy</code> configuration property. The values for this property are:</p><div class="itemizedlist"><ul><li><p><code class="literal">read-only</code></p></li><li><p><code class="literal">read-write</code></p></li><li><p><code class="literal">nonstrict-read-write</code></p></li><li><p><code class="literal">transactional</code></p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>It is recommended to define the cache concurrency strategy per entity rather than using a global one. Use the <code class="classname">@org.hibernate.annotations.Cache</code> annotation for that.</p></div><div class="example"><a id="example-cache-concurrency-with-cache-annotation"/><p class="title"><b>Exemplo 21.5. Definition of cache concurrency strategy via <code class="classname">@Cache</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Entity</span><!-- <br/> --><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cacheable</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">Forest</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>Hibernate also let's you cache the content of a collection or the identifiers if the collection contains other entities. Use the <code class="classname">@Cache</code> annotation on the collection property.</p><div class="example"><a id="d0e19196"/><p class="title"><b>Exemplo 21.6. Caching collections using annotations</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">OneToMany</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">cascade</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">CascadeType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">ALL</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;fetch</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">FetchType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">EAGER</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">JoinColumn</span><span class="java_separator">(</span><span class="java_plain">name</span><span class="java_operator">=</span><span class="java_literal">&quot;CUST_ID&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">SortedSet</span><span class="java_operator">&lt;</span><span class="java_type">Ticket</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;getTickets</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;tickets</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p><a class="xref" href="performance.html#example-cache-annotation-with-attributes" title="Exemplo 21.7. @Cache annotation with attributes">Exemplo 21.7, “@Cache annotation with attributes”</a>shows the<code class="literal"> @org.hibernate.annotations.Cache</code> annotations with its attributes. It allows you to define the caching strategy and region of a given second level cache.</p><div class="example"><a id="example-cache-annotation-with-attributes"/><p class="title"><b>Exemplo 21.7. <code class="classname">@Cache</code> annotation with attributes</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">@Cache(
    CacheConcu<span xmlns="" class="co" id="cache-hm1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>rrencyStrategy usage();
    String reg<span xmlns="" class="co" id="cache-hm2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>ion() default "";
    String inc<span xmlns="" class="co" id="cache-hm3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>lude() default "all";
)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>usage: the given cache concurrency strategy (NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>region (optional): the cache region (default to the fqcn of the class or the fq role name of the collection)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code> (optional): all to include all properties, non-lazy to only include non lazy properties (default all).</p></td></tr></table></div></div></div></div><br class="example-break"/><p>Let's now take a look at Hibernate mapping files. There the <code class="literal">&lt;cache&gt;</code> element of a class or collection mapping is used to configure the second level cache. Looking at <a class="xref" href="performance.html#example-hibernate-cache-mapping-element" title="Exemplo 21.8. The Hibernate &lt;cache&gt; mapping element">Exemplo 21.8, “The Hibernate &lt;cache&gt; mapping element”</a> the parallels to anotations is obvious.</p><div class="example"><a id="example-hibernate-cache-mapping-element"/><p class="title"><b>Exemplo 21.8. The Hibernate <code class="literal">&lt;cache&gt;</code> mapping element</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">&lt;cache
    usage="tra<span xmlns="" class="co" id="cache1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>nsactional|read-write|nonstrict-read-write|read-only"
    region="Re<span xmlns="" class="co" id="cache2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>gionName"
    include="a<span xmlns="" class="co" id="cache3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>ll|non-lazy"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">uso</code> (solicitado) especifica a estratégia de cache: <code class="literal">transacional</code>, <code class="literal">leitura-escrita</code>, <code class="literal">leitura-escrita não estrito</code> ou <code class="literal">somente leitura</code></p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">region</code> (opcional: padrão à classe ou nome papel da coleção): especifica o nome da região do cache de segundo nível</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code> (opcional: padrão para <code class="literal">all</code>) <code class="literal">non-lazy</code>: especifica que a propriedade da entidade mapeada com <code class="literal">lazy="true"</code> pode não estar em cache quando o nível da função busca lazy for habilitada</p></td></tr></table></div></div></div></div><br class="example-break"/><p>Alternatively to <code class="literal">&lt;cache&gt;</code>, you can use <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>.</p><p>Let's now have a closer look at the different usage strategies</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>21.2.2. Estratégia: somente leitura</h3></div></div></div><p>Se sua aplicação precisar ler mas nunca modificar instâncias de uma classe persistente, pode-se utilizar um cache de <code class="literal">read-only</code>. Esta é a estratégia de desempenho mais simples e melhor. É também perfeitamente seguro para uso em um cluster.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>21.2.3. Estratégia: leitura/escrita</h3></div></div></div><p>Se a aplicação precisar atualizar dados, um cache de <code class="literal">read-write</code> pode ser mais apropriado. Esta estratégia de cache nunca deve ser usada se solicitado um nível de isolação de transação serializável. Se o cache for usado em um ambiente JTA, você deve especificar a propriedade <code class="literal">hibernate.transaction.manager_lookup_class</code>, nomeando uma estratégia por obter o <code class="literal">TransactionManager</code> JTA. Em outros ambientes, você deve assegurar que a transação está completa quando a <code class="literal">Session.close()</code> ou <code class="literal">Session.disconnect()</code> for chamada. Se desejar utilizar esta estratégia em um cluster, você deve assegurar que a implementação de cache adjacente suporta o bloqueio. Os provedores de cache built-in <span class="emphasis"><em>não</em></span> suportam o bloqueamento.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>21.2.4. Estratégia: leitura/escrita não estrita</h3></div></div></div><p>Se a aplicação somente precisa atualizar dados ocasionalmente (ou seja, se for extremamente improvável que as duas transações tentem atualizar o mesmo ítem simultaneamente) e não for requerido uma isolação de transação estrita, o uso deum cache de <code class="literal">nonstrict-read-write</code> pode ser mais apropriado. Se um cache é usado em ambiente JTA, você deverá especificar o <code class="literal">hibernate.transaction.manager_lookup_class</code>. Em outros ambientes, você deve assegurar que a transação está completa quando a <code class="literal">Session.close()</code> ou <code class="literal">Session.disconnect()</code> for chamada.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>21.2.5. Estratégia: transacional</h3></div></div></div><p>A estratégia de cache <code class="literal">transactional</code> provê suporte para provedores de cache transacional completo como o JBoss TreeCache. Tal cache, deve ser usado somente em um ambiente JTA e você deverá especificar o <code class="literal">hibernate.transaction.manager_lookup_class</code>.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>21.2.6. Compatibilidade de Estratégia de Concorrência de Cache Provedor</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Nenhum provedor de cache suporta todas as estratégias de concorrência de cache. </p></div><p>A seguinte tabela mostra qual provedor é compatível com qual estratégia de concorrência. </p><div class="table"><a id="d0e19370"/><p class="title"><b>Tabela 21.2. Suporte de Estratégia de Concorrência de Cache</b></p><div class="table-contents"><table summary="Suporte de Estratégia de Concorrência de Cache" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (não recomendado para uso de produção)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>21.3. Gerenciando os caches</h2></div></div></div><p>Quando passar um objeto para <code class="literal">save()</code>, <code class="literal">update()</code> ou <code class="literal">saveOrUpdate()</code> e quando recuperar um objeto usando um <code class="literal">load()</code>, <code class="literal">get()</code>, <code class="literal">list()</code>, <code class="literal">iterate()</code> ou <code class="literal">scroll()</code>, este objeto será adicionado ao cache interno da <code class="literal">Session</code>.</p><p>Quando o <code class="literal">flush()</code> for subsequentemente chamado, o estado deste objeto será sincronizado com o banco de dados. Se você não desejar que esta sincronização aconteça ou se você estiver processando uma grande quantidade de objetos e precisar gerenciar a memória de forma eficiente, o método <code class="literal">evict()</code> pode ser usado para remover o objeto de suas coleções de cache de primeiro nível.</p><div class="example"><a id="d0e19490"/><p class="title"><b>Exemplo 21.9. Explcitly evicting a cached instance from the first level cache using <code class="methodname">Session.evict()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">ScrollableResult</span><!-- <br/> --><span class="java_plain">&nbsp;cats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Cat&nbsp;as&nbsp;cat&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">scroll</span><!-- <br/> --><span class="java_separator">();</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">a&nbsp;huge&nbsp;result&nbsp;set</span>
<!--  --><br/><span class="java_keyword">while</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;cat&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">0</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWithACat</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>A <code class="literal">Session</code> também oferece um método<code class="literal">contains()</code> para determinar se uma instância pertence ao cache de sessão.</p><p>Para despejar completamente todos os objetos do cache de Sessão, chame <code class="literal">Session.clear()</code></p><p>Para o cache de segundo nível, existem métodos definidos na <code class="literal">SessionFactory</code> para despejar o estado de cache de uma instância, classe inteira, instância de coleção ou papel de coleção inteiro.</p><div class="example"><a id="d0e19514"/><p class="title"><b>Exemplo 21.10. Second-level cache eviction via <code class="methodname">SessionFactoty.evict() </code>and <code class="methodname">SessionFacyory.evictCollection()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">evict</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catId</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;</span><span class="java_type">Cats</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;catId</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;collection&nbsp;of&nbsp;kittens</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;kitten&nbsp;collections</span></pre></div></div><br class="example-break"/><p>O <code class="literal">CacheMode</code> controla como uma sessão em particular interage com o cache de segundo nível:</p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code> - lê e escreve itens ao cache de segundo nível.</p></li><li><p><code class="literal">CacheMode.GET</code>: itens de leitura do cache de segundo nível. Não escreve ao cache de segundo nível, exceto quando atualizar dados.</p></li><li><p><code class="literal">CacheMode.PUT</code>: escreve itens ao cache de segundo nível. Não lê a partir do cache de segundo nível.</p></li><li><p><code class="literal">CacheMode.REFRESH</code>: escreve itens ao cache de segundo nível, mas não lê a partir do cache de segundo nível. Passa o efeito de <code class="literal">hibernate.cache.use_minimal_puts</code>, forçando uma atualização do cache de segundo nível para que todos os itens leiam a partir do banco de dados. </p></li></ul></div><p>Para navegar o conteúdo do segundo nível ou região de cache de consulta, use o<code class="literal">Statistics</code> API:</p><div class="example"><a id="d0e19558"/><p class="title"><b>Exemplo 21.11. Browsing the second-level cache entries via the <code class="classname">Statistics</code> API</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Map</span><!-- <br/> --><span class="java_plain">&nbsp;cacheEntries&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getSecondLevelCacheStatistics</span><span class="java_separator">(</span><span class="java_plain">regionName</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getEntries</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>Você precisará habilitar estatísticas e, opcionalmente, forçar o Hibernate a manter as entradas de cache em um formato mais compreensível: </p><div class="example"><a id="d0e19568"/><p class="title"><b>Exemplo 21.12. Enabling Hibernate statistics</b></p><div class="example-contents"><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div></div><br class="example-break"/></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>21.4. O Cache de Consulta</h2></div></div></div><p>O conjunto de resultado de consulta pode também estar em cache. Isto é útil, somente para consultas que são rodadas freqüentemente com os mesmos parâmetros. </p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-enable"/>21.4.1. Ativação do cache de consulta</h3></div></div></div><p>A aplicação do cache nos resultados de consulta introduz alguns resultados referentes o seu processamento transacional normal de aplicações. Por exemplo, se você realizar o cache nos resultados de uma consulta do Person Hibernate, você precisará acompanhar quando estes resultados deverão ser inválidos devido alterações salvas no Person. Tudo isto, acompanhado com o fato de que a maioria dos aplicativos não recebem benefício algum ao realizar o cache nos resultados da consulta, levando o Hibernate a desativar o cache de resultados de consulta por padrão. Para uso do cache de consulta, você primeiro precisa ativar o cache de consulta:</p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>Esta configuração cria duas novas regiões de cache: </p><div class="itemizedlist"><ul><li><p><code class="classname">org.hibernate.cache.StandardQueryCache</code>, mantendo os resultados da consulta com cache.</p></li><li><p><code class="classname">org.hibernate.cache.UpdateTimestampsCache</code>, mantém os timestamps das atualizações mais recentes para tabelas consultáveis. Elas são usadas para validar os resultados uma vez que elas são servidas a partir do cache de consulta.</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>If you configure your underlying cache implementation to use expiry or timeouts is very important that the cache timeout of the underlying cache region for the UpdateTimestampsCache be set to a higher value than the timeouts of any of the query caches. In fact, we recommend that the the UpdateTimestampsCache region not be configured for expiry at all. Note, in particular, that an LRU cache expiry policy is never appropriate.</p></div><p>Conforme mencionado acima, a maioria das consultas não se beneficiam do cache ou de seus resultados. Portanto por padrão, as consultas individuais não estão em cache mesmo depois de ativar o cache de consulta. Para habilitar o caching de resultados, chame <code class="literal">org.hibernate.Query.setCacheable(true)</code>. Esta chamada permite que a consulta procure por resultados de caches existentes ou adicione seus resultados ao cache quando for executado. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>O cache de consulta não realiza o cache ao estado de entidades atuais no cache, ele apenas realiza o cache nos valores identificadores e resultados do tipo de valor. Por esta razão, o cache de consulta deve sempre ser usado em conjunção com o cache de segundo nível para as entidades esperadas a sofrerem o cache como parte de um cache de resultado de consulta (apenas com o cache de coleção).</p></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-regions"/>21.4.2. Regiões de cache de consulta</h3></div></div></div><p>Se você solicitar um controle de granulado fino com políticas de validade do cache de consulta, você poderá especificar uma região de cache nomeada para uma consulta em particular, chamando <code class="literal">Query.setCacheRegion()</code>.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">List</span><!-- <br/> --><span class="java_plain">&nbsp;blogs&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Blog&nbsp;blog&nbsp;where&nbsp;blog.blogger&nbsp;=&nbsp;:blogger&quot;</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setEntity</span><span class="java_separator">(</span><span class="java_literal">&quot;blogger&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;blogger</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_literal">15</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheable</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheRegion</span><span class="java_separator">(</span><span class="java_literal">&quot;frontpages&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>Se você quiser forçar um cache de consulta para uma atualização de sua região (independente de quaisquer resultados com cache encontrados nesta região), você poderá usar <code class="literal">org.hibernate.Query.setCacheMode(CacheMode.REFRESH)</code>. Juntamente com a região que você definiu para o cache gerado, o Hibernate seletivamente forçará os resultados com cache, naquela região particular a ser atualizada. Isto é particularmente útil em casos onde dados adjacentes podem ter sido atualizados através de um processo em separado , além de ser uma alternativa mais eficiente se aplicada ao despejo de uma região de cache através de <code class="literal">SessionFactory.evictQueries()</code>.</p></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>21.5. Entendendo o desempenho da Coleção</h2></div></div></div><p>Nas seções anteriores nós descrevemos as coleções e seus aplicativos. Nesta seção nós exploraremos mais problemas em relação às coleções no período de execução.</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>21.5.1. Taxonomia</h3></div></div></div><p>O Hibernate define três tipos básicos de coleções:</p><div class="itemizedlist"><ul><li><p>Coleções de valores</p></li><li><p>Associações um-para-muitos </p></li><li><p>Associações muitos-para-muitos </p></li></ul></div><p>A classificação distingue as diversas tabelas e relacionamento de chave externa, mas não nos diz tudo que precisamos saber sobre o modelo relacional. Para entender completamente a estrutura relacional e as características de desempenho, devemos também considerar a estrutura da chave primária que é usada pelo Hibernate para atualizar ou deletar linhas de coleções. Isto sugere a seguinte classificação:</p><div class="itemizedlist"><ul><li><p>Coleções indexadas</p></li><li><p>conjuntos</p></li><li><p>Bags</p></li></ul></div><p>Todas as coleções indexadas (mapas, listas, matrizes) possuem uma chave primária, que consiste em colunas <code class="literal">&lt;key&gt;</code> e <code class="literal">&lt;index&gt;</code>. Neste caso, as atualizações de coleção são geralmente muito eficientes. A chave primária pode ser indexada de forma eficiente e uma linha em particular pode ser localizada de forma eficiente quando o Hibernate tentar atualizar ou deletá-la. </p><p>Os conjuntos possuem uma chave primária que consiste em <code class="literal">&lt;key&gt;</code> e colunas de elemento. Isto pode ser menos eficiente para alguns tipos de elementos de coleções, especialmente elementos compostos ou textos grandes ou ainda campos binários. O banco de dados pode não ser capaz de indexar uma chave primária complexa de forma tão eficiente. Por um outro lado, para associações um-para-muitos ou muitos-para-muitos, especialmente no caso de identificadores sintáticos, é bem provável que seja tão eficiente quanto. Se você quiser que o <code class="literal">SchemaExport</code> crie para você uma chave primária de um <code class="literal">&lt;set&gt;</code> você deverá declarar todas as colunas como <code class="literal">not-null="true"</code>.</p><p>Os mapeamentos <code class="literal">&lt;idbag&gt;</code> definem uma chave substituta, para que elas sejam sempre muito eficientes ao atualizar. Na verdade, este é o melhor caso. </p><p>As Bags são os piores casos. Como uma bag permite duplicar valores de elementos e não possui coluna de índice, não se deve definir nenhuma chave primária. O Hibernate não tem como distinguir entre linhas duplicadas. O Hibernate resolve este problema, removendo completamente em um único <code class="literal">DELETE</code> e recria a coleção quando mudar. Isto pode ser bastante ineficiente.</p><p>Note que para uma associação um-para-muitos, a chave primária pode não ser a chave primária física da tabela do banco de dados, mas mesmo neste caso, a classificação acima é ainda útil. Isto reflete como o Hibernate "localiza" linhas individuais da coleção.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>21.5.2. Listas, mapas, bags de id e conjuntos são coleções mais eficientes para atualizar</h3></div></div></div><p>A partir da discussão acima, deve ficar claro que as coleções indexadas e conjuntos (geralmente) permitem uma operação mais eficente em termos de adição, remoção e atualização de elementos.  </p><p>Existe ainda, mais uma vantagem, das coleções indexadas sob conjuntos para associações muitos-para-muitos. Por causa da estrutura de um <code class="literal">Set</code>, o Hibernate nunca utiliza o comando <code class="literal">UPDATE</code> em uma linha quando um elemento é "modificado". As mudanças para o <code class="literal"> Conjunto</code> funcionam sempre através do comando <code class="literal">INSERT</code> e <code class="literal">DELETE</code> de linhas individuais. Novamente, esta consideração não se aplica às associações um para muitos. </p><p>Após observar que as matrizes não podem ser preguiçosas, nós concluimos que as listas, mapas e bags de id são tipos de coleções com maior desempenho (não inverso), com conjuntos que não ficam atrás. Espera-se que os conjuntos sejam um tipo mais comum de coleção nas aplicações Hibernate. Isto porque as semânticas "conjunto" são mais naturais em modelos relacionais. </p><p>No entanto, em modelos de domínio de Hibernate bem criados, geralmente vemos que a maioria das coleções são de fato, associações um-para-muitos com <code class="literal">inverse="true"</code>. Para estas associações, a atualização é manipulada pelo lado muitos-para-um de uma associação e portanto considerações de desempenho de atualização de coleção simplesmente não se aplicam a este caso.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>21.5.3. As Bags e listas são as coleções de inversão mais eficientes.</h3></div></div></div><p>Existe um caso em particular no qual as bags (e também as listas) possuem um desempenho muito maior do que conjuntos. Para uma coleção com <code class="literal">inverse="true"</code>, o idioma de relacionamento um-para-um bidirecional padrão, por exemplo, podemos adicionar elementos a uma bag ou uma lista sem precisar inicializar (buscar) os elementos da bag. Isto acontece porque a <code class="literal">Collection.add()</code> ou <code class="literal">Collection.addAll()</code> deve sempre retornar verdadeira para uma bag ou <code class="literal">List</code>. Isto pode fazer que o código comum seguinte seja muito mais rápido:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">no&nbsp;need&nbsp;to&nbsp;fetch&nbsp;the&nbsp;collection</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">sess</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>21.5.4. Deletar uma vez</h3></div></div></div><p>Às vezes, deletar elementos de coleção um por um pode ser extremamente ineficiente. O Hibernate não é completamente burro, portanto ele sabe que não deve fazer isso no caso de uma coleção que tenha sido esvaziada recentemente (se você chamou <code class="literal">list.clear()</code>, por exemplo). Neste caso, o Hibernate irá editar um único <code class="literal">DELETE</code>.</p><p>Vamos supor que tenha adicionado um elemento único à uma coleção de tamanho vinte e então remove dois elementos. O Hibernate irá editar uma instrução <code class="literal">INSERT</code> e duas instruções <code class="literal">DELETE</code>, a não ser que a coleção seja uma bag. Isto é certamente desejável.</p><p>No entanto, suponha que removamos dezoito elementos, deixando dois e então adicionando três novos elementos. Existem duas formas possíveis de se proceder:</p><div class="itemizedlist"><ul><li><p>delete dezoito linhas uma por uma e então insira três linhas</p></li><li><p>remova toda a coleção em um SQL <code class="literal">DELETE</code> e insira todos os cinco elementos atuais, um por um</p></li></ul></div><p>O Hibernate não sabe que a segunda opção é provavelmente mais rápida neste caso. O Hibernate não deseha saber a opção, uma vez que tal comportamento deve confundir os triggers do banco de dados, etc.</p><p>Felizmente, você pode forçar este comportamento (ou seja, uma segunda estratégia) a qualquer momento, descartando (ou seja, desreferenciando) a coleção original e retornando uma coleção recentemente instanciada com todos os elementos atuais. </p><p>É claro que, deletar somente uma vez, não se aplica às coleções mapeadas <code class="literal">inverse="true"</code>.</p></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>21.6. Monitorando desempenho</h2></div></div></div><p>A otimização não é muito usada sem o monitoramento e acesso ao número de desempenho. O Hibernate oferece uma grande variedade de números sobre suas operações internas. Estatísticas em Hibernate estão disponíveis através do <code class="literal">SessionFactory</code>.</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>21.6.1. Monitorando uma SessionFactory</h3></div></div></div><p>Você poderá acessar as métricas da <code class="literal">SessionFactory</code> de duas formas. Sua primeira opção é chamar a <code class="literal">sessionFactory.getStatistics()</code> e ler ou dispôr as <code class="literal">Estatísticas</code> você mesmo.</p><p>O Hibernate também usa o JMX para publicar métricas se você habilitar o MBean de <code class="literal">StatisticsService</code>. Você deve habiliar um MBean único para todas as suas <code class="literal">SessionFactory</code> ou uma por factory. Veja o seguinte código para exemplos de configurações minimalísticos: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;a&nbsp;specific&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;sessionFactory&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;myFinancialApp&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;tb</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;object&nbsp;name</span>
</span>
<!--  --><br/><span class="java_type">StatisticsService</span><span class="java_plain">&nbsp;stats&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StatisticsService</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">stats</span><span class="java_separator">.</span><span class="java_plain">setSessionFactory</span><span class="java_separator">(</span><span class="java_plain">sessionFactory</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Bind</span><span class="java_plain">&nbsp;the&nbsp;stats&nbsp;to&nbsp;a&nbsp;</span><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_plain">server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">stats</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Register</span><span class="java_plain">&nbsp;the&nbsp;</span><span class="java_type">Mbean</span><span class="java_plain">&nbsp;on&nbsp;the&nbsp;server</span></pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;all&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">'s</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;sessionFactory&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;all&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;tb</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;object&nbsp;name</span>
</span>
<!--  --><br/><span class="java_type">StatisticsService</span><span class="java_plain">&nbsp;stats&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StatisticsService</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">stats</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Register</span><span class="java_plain">&nbsp;the&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;on&nbsp;the&nbsp;server</span></pre><p>Você pode (des)ativar o monitoramento para uma <code class="literal">SessionFactory</code>:</p><div class="itemizedlist"><ul><li><p>no tempo de configuração, ajuste <code class="literal">hibernate.generate_statistics</code> para <code class="literal">falso</code></p></li></ul></div><div class="itemizedlist"><ul><li><p>em tempo de espera: <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> ou <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code></p></li></ul></div><p>As estatísticas podem ser reajsutadas de forma programática, usando o método <code class="literal">clear()</code>. Um resumo pode ser enviado para o usuário (nível de info) usando o método <code class="literal">logSummary()</code>. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>21.6.2. Métricas</h3></div></div></div><p>O Hibernate oferece um número de métricas, desde informações bem básicas até especializadas, somente relevantes a certos cenários. Todos os contadores disponíveis estão descritos na API da interface <code class="literal">Statistics</code>, em três categorias: </p><div class="itemizedlist"><ul><li><p>As métricas relacionadas ao uso da <code class="literal">Sessão</code>, tal como um número de sessões em aberto, conexões JDBC recuperadas, etc.</p></li><li><p>As métricas relacionadas às entidades, coleções, consultas e caches como um todo (mais conhecido como métricas globais). </p></li><li><p>Métricas detalhadas relacionadas à uma entidade em particular, coleção, consulta ou região de cache.</p></li></ul></div><p>Por exemplo, você pode verificar a coincidência de um cache, perder e colocar a relação entre as entidades, colações e consultas e tempo médio que uma consulta precisa. Esteja ciente de que o número de milisegundos é sujeito a aproximação em Java. O Hibernate é preso à precisão do JVM, em algumas plataformas a precisão chega a ser de 10 segundos. </p><p>Os Getters simples são usados para acessar métricas globais (ou seja, não presos à uma entidade em particular, coleção, região de cache, etc.) Você pode acessar as métricas de uma entidade em particular, coleção ou região de cache através de seu nome e através de sua representação de HQL ou SQL para consultas. Por favor consulte a Javadoc API <code class="literal">Statistics</code>, <code class="literal">EntityStatistics</code>, <code class="literal">CollectionStatistics</code>, <code class="literal">SecondLevelCacheStatistics</code>, e <code class="literal">QueryStatistics</code> para maiores informações. O seguinte código mostra um exemplo simples:  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Statistics</span><!-- <br/> --><span class="java_plain">&nbsp;stats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">HibernateUtil</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheHitCount&nbsp;&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getQueryCacheHitCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheMissCount&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getQueryCacheMissCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheHitRatio&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;queryCacheHitCount&nbsp;</span><span class="java_operator">/</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">queryCacheHitCount&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;queryCacheMissCount</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">log</span><span class="java_separator">.</span><span class="java_plain">info</span><span class="java_separator">(</span><span class="java_literal">&quot;Query&nbsp;Hit&nbsp;ratio:&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;queryCacheHitRatio</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_type">EntityStatistics</span><span class="java_plain">&nbsp;entityStats&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getEntityStatistics</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">long</span><span class="java_plain">&nbsp;changes&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getInsertCount</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getUpdateCount</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getDeleteCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">log</span><span class="java_separator">.</span><span class="java_plain">info</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;&nbsp;changed&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;changes&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;times&quot;</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">);</span></pre><p>Para trabalhar em todas as entidades, coleções, consultas e caches regionais, você poderá recuperar os nomes de lista de entidades, coleções, consultas e caches regionais com os seguintes métodos: <code class="literal">getQueries()</code>, <code class="literal">getEntityNames()</code>, <code class="literal">getCollectionRoleNames()</code>, e <code class="literal">getSecondLevelCacheRegionNames()</code>. </p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>Anterior</strong>Capítulo 20. Mapeamento XML</a></li><li class="up"><a accesskey="u" href="#"><strong>Acima</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Principal</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>Próxima</strong>Capítulo 22. Guia de Toolset</a></li></ul></body></html>