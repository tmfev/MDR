<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 28. Considerações da Portabilidade do Banco de Dados</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="prev" href="best-practices.html" title="Capítulo 27. Melhores práticas"/><link rel="next" href="bi01.html" title="Referências"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>Próxima</strong></a></li></ul><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>Capítulo 28. Considerações da Portabilidade do Banco de Dados</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="portability.html#portability-basics">28.1. Fundamentos da Portabilidade</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialect">28.2. Dialeto</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialectresolver">28.3. Resolução do Dialeto</a></span></dt><dt><span class="section"><a href="portability.html#portability-idgen">28.4. Geração do identificador</a></span></dt><dt><span class="section"><a href="portability.html#portability-functions">28.5. Funções do banco de dados</a></span></dt><dt><span class="section"><a href="portability.html#portability-types">28.6. Tipos de mapeamentos</a></span></dt></dl></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>28.1. Fundamentos da Portabilidade</h2></div></div></div><p>Um dos pontos de venda do Hibernate (e realmente Mapeamento do Objeto/Relacional como um conjunto) é a noção da portabilidade do banco de dados. Isto pode significar um usuário de TI interno migrando a partir de um fornecedor de banco de dados a outro, ou isto pode significar que um framework ou aplicativo implementável consumindo o Hibernate para produtos de banco de dados múltiplos de destinação simultaneamente pelos usuários. Independente do cenário exato, a idéia básica é que você queira que o Hibernate o ajude a rodar em referência a qualquer número de banco de dados sem as alterações a seu código e preferencialmente sem quaisquer alterações ao metadados de mapeamento. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>28.2. Dialeto</h2></div></div></div><p>A primeira linha de portabilidade para o Hibernate é o dialeto, que trata-se de uma especialização de um contrato <code class="classname">org.hibernate.dialect.Dialect</code>. Um dialeto encapsula todas as diferenças em como o Hibernate deve comunicar-se com um banco de dados particular para completar algumas tarefas como obter um valor de seqüência ou estruturar uma consulta SELECT. O Hibernate vincula uma variedade de dialetos para muitos dos bancos de dados mais populares. Se você achar que seu banco de dados particular não está seguindo os mesmos, não será difícil escrever o seu próprio. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>28.3. Resolução do Dialeto</h2></div></div></div><p>Originalmente, o Hibernate sempre solicita que os usuários especifiquem qual dialeto a ser usado. No caso dos usuários buscarem banco de dados múltiplos de destinação simultaneamente com as próprias construções que eram problemáticas. Normalmente, isto solicita que seus próprios usuários configurem o dialeto do Hibernate ou definam o próprio método de determinação do valor. </p><p>Inicializando com a versão 3.2, o Hibernate introduziu a noção de detecção automática do dialeto para uso baseado no <code class="interfacename">java.sql.DatabaseMetaData</code> obtido a partir de um <code class="interfacename">java.sql.Connection</code> para aquele banco de dados. Era muito melhor, esperar que esta resolução limitada aos bancos de dados Hibernate soubesse com antecedência e que em ocasião alguma era configurável ou substituível. </p><p>Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Dialect</span><!-- <br/> --><span class="java_plain">&nbsp;resolveDialect</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">DatabaseMetaData</span><!-- <br/> --><span class="java_plain">&nbsp;metaData</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">throws</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">JDBCConnectionException</span></pre><p>The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver. </p><p>A melhor parte destes solucionadores é que os usuários também podem registrar os seus próprios solucionadores personalizados dos quais serão processados antes dos Hibernates internos. Isto poderá ser útil em um número diferente de situações: permite uma integração fácil de auto-detecção de dialetos além daqueles lançados com o próprio Hibernate. Além disto, permite que você especifique o uso de um dialeto personalizado quando um banco de dados particular é reconhecido, etc. Para registrar um ou mais solucionadores, apenas especifique-os (separados por vírgula, tabs ou espaços) usando o conjunto de configuração 'hibernate.dialect_resolvers' (consulte a constante <code class="constant">DIALECT_RESOLVERS</code> no <code class="classname">org.hibernate.cfg.Environment</code>). </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>28.4. Geração do identificador</h2></div></div></div><p>When considering portability between databases, another important decision is selecting the identifier generation stratagy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy becauase the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entitiy be associated with the session (like via save() e.g.) regardless of current transactional semantics. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p> Hibernate was changed slightly once the implication of this was better understood so that the insert is delayed in cases where that is feasible. </p></div><p> The underlying issue is that the actual semanctics of the application itself changes in these cases. </p><p>Starting with version 3.2.3, Hibernate comes with a set of <a class="ulink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting portability in a much different way. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p> There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: </p><div class="itemizedlist"><ul><li><p> <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> </p></li><li><p> <code class="classname">org.hibernate.id.enhanced.TableGenerator</code> </p></li></ul></div><p> </p></div><p> The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>28.5. Funções do banco de dados</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Atenção</h2><p>Esta é uma área do Hibernate com necessidade de melhoramentos. Este manuseio de função funciona atualmente muito bem com o HQL, quando falamos das preocupações de portabilidade. No entanto, é bastante precária em outros aspectos. </p></div><p>As funções SQL podem ser referenciadas em diversas maneiras pelos usuários. No entanto, nem todos os bancos de dados suportam o mesmo conjunto de função. O Hibernate fornece um significado de mapeamento do nome da função <span class="emphasis"><em>lógica</em></span> para uma delegação que sabe como manusear aquela função em particular, mesmo quando usando uma chamada de função física totalmente diferente. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Technically this function registration is handled through the <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code> class which is intended to allow users to provide custom function definitions without having to provide a custom dialect. This specific behavior is not fully completed as of yet. </p><p>It is sort of implemented such that users can programatically register functions with the <code class="classname">org.hibernate.cfg.Configuration</code> and those functions will be recognized for HQL. </p></div><p>
        </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>28.6. Tipos de mapeamentos</h2></div></div></div><p>A seção está esquematizada para finalização numa data posterior... </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>Anterior</strong>Capítulo 27. Melhores práticas</a></li><li class="up"><a accesskey="u" href="#"><strong>Acima</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Principal</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>Próxima</strong>Referências</a></li></ul></body></html>