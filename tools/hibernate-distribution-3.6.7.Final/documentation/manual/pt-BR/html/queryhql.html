<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 16. HQL: A Linguagem de Consultas do Hibernate</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="prev" href="batch.html" title="Capítulo 15. Batch processing"/><link rel="next" href="querycriteria.html" title="Capítulo 17. Consultas por critérios"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>Próxima</strong></a></li></ul><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>Capítulo 16. HQL: A Linguagem de Consultas do Hibernate</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="queryhql.html#queryhql-casesensitivity">16.1. Diferenciação de maiúscula e minúscula</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-from">16.2. A cláusula from</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins">16.3. Associações e uniões</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins-forms">16.4. Formas de sintáxe de uniões</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-identifier-property">16.5. Referência à propriedade do identificador </a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-select">16.6. A cláusula select</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-aggregation">16.7. Funções de agregação</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-polymorphism">16.8. Pesquisas Polimórficas</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-where">16.9. A cláusula where</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-expressions">16.10. Expressões</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-ordering">16.11. A cláusula ordenar por</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-grouping">16.12. A cláusula agrupar por</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-subqueries">16.13. Subconsultas</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-examples">16.14. Exemplos de HQL</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-bulk">16.15. Atualização e correção em lote</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tipstricks">16.16. Dicas &amp; Truques</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-components">16.17. Componentes</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tuple">16.18. Sintáxe do construtor de valores de linha</a></span></dt></dl></div><p>O Hibernate vem com uma poderosa linguagem de consulta (HQL) que é muito parecida com o SQL. No entanto, comparado com o SQL o HQL é totalmente orientado à objetos, e compreende noções de herança, polimorfismo e associações. </p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>16.1. Diferenciação de maiúscula e minúscula</h2></div></div></div><p>As Consultas não diferenciam maiúscula de minúscula, exceto pelo nomes das classes e propriedades Java. Portanto, <code class="literal">SeLeCT</code> é o mesmo que <code class="literal">sELEct</code> que é o mesmo que <code class="literal">SELECT</code>, mas <code class="literal">org.hibernate.eg.FOO</code> não é <code class="literal">org.hibernate.eg.Foo</code> e <code class="literal">foo.barSet</code> não é <code class="literal">foo.BARSET</code>. </p><p>Esse manual usa as palavras chave HQL em letras minúsculas. Alguns usuários acreditam que com letras maiúsculas as consultas ficam mais legíveis, mas nós acreditamos que este formato não é apropriado para o código Java.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>16.2. A cláusula from</h2></div></div></div><p>A consulta mais simples possível do Hibernate é a seguinte: </p><pre class="programlisting">from eg.Cat</pre><p>Isto simplesmente retornará todas as instâncias da classe <code class="literal">eg.Cat</code>. Geralmente não precisamos qualificar o nome da classe, uma vez que o <code class="literal">auto-import</code> é o padrão. Por exemplo: </p><pre class="programlisting">from Cat</pre><p>Com o objetivo de referir-se ao <code class="literal">Cat</code> em outras partes da consulta, você precisará determinar um <span class="emphasis"><em>alias</em></span>. Por exemplo: </p><pre class="programlisting">from Cat as cat</pre><p>Essa consulta atribui um alias a <code class="literal">cat</code> para as instâncias de <code class="literal">Cat</code>, portanto poderemos usar esse alias mais tarde na consulta. A palavra chave <code class="literal">as</code> é opcional. Você também pode escrever assim: </p><pre class="programlisting">from Cat cat</pre><p>Classes múltiplas podem ser envolvidas, resultando em um produto cartesiano ou união "cruzada".  </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>É considerada uma boa prática nomear alias de consulta, utilizando uma letra minúscula inicial, consistente com os padrões de nomeação Java para variáveis locais (ex.: <code class="literal">domesticCat</code>).  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>16.3. Associações e uniões</h2></div></div></div><p>Podemos também atribuir aliases em uma entidade associada, ou mesmo em elementos de uma coleção de valores, usando uma <code class="literal">join</code>. Por exemplo: </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>Os tipos de uniões suportados foram inspirados no ANSI SQL: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">inner join</code>
                </p></li><li><p>
                    <code class="literal">left outer join</code>
                </p></li><li><p>
                    <code class="literal">right outer join</code>
                </p></li><li><p><code class="literal">união completa</code> (geralmente não é útil) </p></li></ul></div><p>As construções <code class="literal">inteiro</code>, <code class="literal">união esquerda externa</code> e <code class="literal">união direita externa</code> podem ser abreviadas. </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>Você pode fornecer condições extras de união usando a palavra chave do HQL <code class="literal">with</code>. </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight 
&gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a class="xref" href="performance.html#performance-fetching" title="21.1. Estratégias de Busca">Seção 21.1, “Estratégias de Busca ”</a> for more information. </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>Geralmente, uma união de busca não precisa atribuir um alias, pois o objeto associado não deve ser usado na cláusula <code class="literal">where</code> (ou em qualquer outra cláusula). Também, os objetos associados não são retornados diretamente nos resultados da consulta. Ao invés disso, eles devem ser acessados usando o objeto pai. A única razão pela qual precisariamos de um alias é quando fazemos uma união de busca recursivamente em uma coleção adicional:  </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>Observe que a construção <code class="literal">busca</code> não deve ser usada em consultas invocadas usando <code class="literal">iterate()</code> (embora possa ser usado com <code class="literal">scroll()</code>). O <code class="literal">Fetch</code> também não deve ser usado junto com o <code class="literal">setMaxResults()</code> ou <code class="literal">setFirstResult()</code> pois essas operações são baseadas nas linhas retornadas, que normalmente contém duplicidade devido à busca das coleções, então o número de linhas pode não ser o que você espera. A <code class="literal">Fetch</code> não deve ser usada junto com uma condição <code class="literal">with</code>. É possível que seja criado um produto cartesiano pela busca de união em mais do que uma coleção em uma consulta, então tome cuidado nesses casos. Uma busca de união em várias coleções pode trazer resultados inesperados para mapeamentos do tipo bag, tome cuidado na hora de formular consultas como essas. Finalmente, observe o seguinte, a <code class="literal">busca de união completa</code> e <code class="literal">busca de união direita</code> não são importantes. </p><p>Se estiver usando o nível de propriedade busca lazy (com instrumentação de bytecode), é possível forçar o Hibernate a buscar as propriedades lazy imediatamente na primeira consulta, usando <code class="literal">buscar todas as propriedades </code>.  </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>16.4. Formas de sintáxe de uniões</h2></div></div></div><p>O HQL suporta duas formas de associação para união: <code class="literal">implícita</code> e <code class="literal">explícita</code>. </p><p>As consultas apresentadas na seção anterior usam a forma <code class="literal">explícita</code>, onde a palavra chave união é explicitamente usada na cláusula from. Essa é a forma recomendada. </p><p>A forma <code class="literal">implícita</code> não usa a palavra chave "união". Entretanto, as associações são "diferenciadas" usando pontuação ("." - dot-notation). Uniões<code class="literal">implícitas</code> podem aparecer em qualquer uma das cláusulas HQL. A união <code class="literal">implícita</code> resulta em declarações SQL que contém uniões inteiras. </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>16.5. Referência à propriedade do identificador </h2></div></div></div><p>Geralmente, existem duas formas para se referir à propriedade do indentificador de uma entidade:  </p><div class="itemizedlist"><ul compact="compact"><li><p>A propriedade especial (em letra minúscula) <code class="literal">id</code> pode ser usada para se referir à propriedade do identificador de uma entidade <span class="emphasis"><em>considerando que a entidade não define uma propriedade não identificadora chamada id</em></span>. </p></li><li><p>Se a entidade definir a propriedade do identificador nomeada, você poderá usar este nome de propriedade.  </p></li></ul></div><p>As referências à composição das propriedades do identificador seguem as mesmas regras de nomeação. Se a entidade tiver uma propriedade de não identificador chamada id, a composição da propriedade do identificador pode somente ser referenciada pelo seu nome definido. Do contrário, uma propriedade especial <code class="literal">id</code> poderá ser usada para referenciar a propriedade do identificador.  </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Observe: esta ação mudou completamente na versão 3.2.2. Nas versões anteriores o <code class="literal">id</code> <span class="emphasis"><em>sempre</em></span> referia-se à propriedade do identificador não importando seu nome atual. Uma ramificação desta decisão era que as propriedades do não identificador de chamadas <code class="literal">id</code> nunca poderiam ser referenciadas nas consultas do Hibernate.  </p></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>16.6. A cláusula select</h2></div></div></div><p>A cláusula <code class="literal">select</code> seleciona quais objetos e propriedades retornam no resultado da consulta. Considere:  </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>A consulta selecionará <code class="literal">mate</code>s (parceiros), de outros <code class="literal">Cat</code>s. Atualmente, podemos expressar a consulta de forma mais compacta como:  </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>As consultas podem retornar propriedades de qualquer tipo de valor, incluindo propriedades de tipo de componente:  </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>As consultas podem retornar múltiplos objetos e/ou propriedades como uma matriz do tipo <code class="literal">Object[]</code>: </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Ou como um <code class="literal">List</code>: </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Ou - considerando que a classe <code class="literal">Family</code> tenha um construtor apropriado - como um objeto Java typesafe atual: </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>Pode-se designar alias à expressões selecionadas usando <code class="literal">as</code>: </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>Isto é bem mais útil quando usado junto <code class="literal">com</code><code class="literal">selecione novo mapa</code>: </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>Esta consulta retorna um <code class="literal">Mapa</code> de referências para valores selecionados. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>16.7. Funções de agregação</h2></div></div></div><p>As consultas HQL podem retornar o resultado de funções agregadas nas propriedades: </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>As funções agregadas suportadas são:  </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>Pode-se usar operadores aritméticos, concatenação e funções SQL reconhecidas na cláusula select:  </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>As palavras <code class="literal">distinct</code> e <code class="literal">all</code> podem ser usadas e têm a mesma semântica que no SQL.  </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>16.8. Pesquisas Polimórficas</h2></div></div></div><p>A consulta: </p><pre class="programlisting">from Cat as cat</pre><p>retorna instâncias não só de <code class="literal">Cat</code>, mas também de subclasses como <code class="literal">DomesticCat</code>. As consultas do Hibernate podem nomear qualquer classe Java ou interface na cláusula <code class="literal">from</code>. A consulta retornará instâncias de todas as classes persistentes que extendam a determinada classe ou implemente a determinada interface. A consulta a seguir, poderia retornar todos os objetos persistentes:  </p><pre class="programlisting">from java.lang.Object o</pre><p>A interface <code class="literal">Named</code> pode ser implementada por várias classes persistentes: </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>Note que as duas últimas consultas requerem mais de um SQL <code class="literal">SELECT</code>. Isto significa que a cláusula <code class="literal">order by</code> não ordena corretamente todo o resultado. Isso também significa que você não pode chamar essas consultas usando <code class="literal">consulta.scroll()</code>. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>16.9. A cláusula where</h2></div></div></div><p>A cláusula <code class="literal">where</code> permite estreitar a lista de instâncias retornadas. Se não houver referência alguma, pode-se referir à propriedades pelo nome:  </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>Se houver uma referência, use o nome da propriedade qualificada: </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>Isto retorna instâncias de <code class="literal">Cat</code> com nome ‘Fritz’. </p><p>A seguinte consulta: </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p>retornará todas as instâncias de <code class="literal">Foo</code>, para cada um que tiver uma instância de <code class="literal">bar</code> com a propriedade <code class="literal">date</code> igual a propriedade <code class="literal">startDate</code> de <code class="literal">Foo</code>. Expressões de caminho compostas fazem da cláusula <code class="literal">where</code>, extremamente poderosa. Consideremos:  </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>Esta consulta traduz para uma consulta SQL com uma tabela (inner) união. Por exemplo: </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>resultaria numa consulta que necessitasse de união de quatro tabelas, no SQL. </p><p>O operador <code class="literal">=</code> pode ser usado para comparar não apenas propriedades, mas também instâncias:  </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. Referência à propriedade do identificador">Seção 16.5, “Referência à propriedade do identificador ”</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>A segunda consulta é eficiente e não requer nenhuma união de tabelas. </p><p>As propriedades de identificadores compostas também podem ser usadas. Considere o seguinte exemplo onde <code class="literal">Person</code> possui identificadores compostos que consistem de <code class="literal">country</code> e <code class="literal">medicareNumber</code>:  </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>Mais uma vez, a segunda consulta não precisa de nenhuma união de tabela. </p><p>See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. Referência à propriedade do identificador">Seção 16.5, “Referência à propriedade do identificador ”</a> for more information regarding referencing identifier properties) </p><p>Da mesma forma, a propriedade especial <code class="literal">class</code> acessa o valor discriminador da instância, no caso de persistência polimórfica. O nome de uma classe Java inclusa em uma cláusula where, será traduzida para seu valor discriminante. </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a class="xref" href="queryhql.html#queryhql-components" title="16.17. Componentes">Seção 16.17, “Componentes”</a> for more information. </p><p>Um tipo "any" possui as propriedades <code class="literal">id</code> e <code class="literal">class</code> especiais, nos permitindo expressar uma união da seguinte forma (onde <code class="literal">AuditLog.item</code> é uma propriedade mapeada <code class="literal">com</code><code class="literal">&lt;any&gt;</code>): </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>Veja que <code class="literal">log.item.class</code> e <code class="literal">payment.class</code> podem referir-se à valores de colunas de banco de dados completamente diferentes, na consulta acima.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>16.10. Expressões</h2></div></div></div><p>As expressões permitidas na cláusula <code class="literal">where</code> incluem o seguinte: </p><div class="itemizedlist"><ul compact="compact"><li><p>operadores matemáticos: <code class="literal">+, -, *, /</code> </p></li><li><p>operadores de comparação binários: <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code> </p></li><li><p>operadores lógicos <code class="literal">and, or, not</code> </p></li><li><p>Parênteses <code class="literal">( )</code> que indica o agrupamento </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> and <code class="literal">not member of</code> </p></li><li><p>case "simples" , <code class="literal">case ... when ... then ... else ... end</code>, and "searched" case, <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>concatenação de string <code class="literal">...||...</code> ou <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code> e <code class="literal">current_timestamp()</code>  </p></li><li><p><code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code> e <code class="literal">year(...)</code> </p></li><li><p>qualquer função ou operador definidos pela EJB-QL 3.0: <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</code> </p></li><li><p><code class="literal">coalesce()</code> and <code class="literal">nullif()</code> </p></li><li><p><code class="literal">str()</code> para converter valores numéricos ou temporais para uma string de leitura </p></li><li><p><code class="literal">cast(... as ...)</code>, onde o segundo argumento é o nome do tipo hibernate, e<code class="literal">extract(... from ...)</code> se ANSI <code class="literal">cast()</code> e <code class="literal">extract()</code> é suportado pelo banco de dados adjacente </p></li><li><p>A função HQL <code class="literal">index()</code> , que se aplicam às referências de coleçôes associadas e indexadas </p></li><li><p>As funções HQL que retornam expressões de coleções de valores: <code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>, junto com o elemento especial, <code class="literal">elements()</code> e funções de <code class="literal">índices</code> que podem ser quantificadas usando <code class="literal">some, all, exists, any, in</code>. </p></li><li><p>Qualquer função escalar suportada pelo banco de dados como <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code> e <code class="literal">sin()</code> </p></li><li><p>Parâmetros posicionais ao estilo JDBC <code class="literal">?</code> </p></li><li><p>Parâmetros nomeados <code class="literal">:name</code>, <code class="literal">:start_date</code> e <code class="literal">:x1</code> </p></li><li><p>Literais SQL <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">6.66E+2</code>, <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>Constantes Java <code class="literal">final estático público</code><code class="literal">ex: Color.TABBY</code> </p></li></ul></div><p><code class="literal">in</code> e <code class="literal">between</code> podem ser usadas da seguinte maneira:  </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>As formas negativas podem ser escritas conforme segue abaixo: </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>Da mesma forma, <code class="literal">is null</code> e <code class="literal">is not null</code> podem ser usados para testar valores nulos. </p><p>Booleanos podem ser facilmente usados em expressões, declarando as substituições da consulta HQL, na configuração do Hibernate: </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"
&gt;true 1, false 0&lt;/property
&gt;</pre><p>Isso irá substituir as palavras chave <code class="literal">true</code> e <code class="literal">false</code><code class="literal">pelos</code> literais <code class="literal">1</code> e <code class="literal">0</code> na tradução do HQL para SQL. </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>Pode-se testar o tamanho de uma coleção com a propriedade especial <code class="literal">size</code> ou a função especial <code class="literal">size()</code>. </p><pre class="programlisting">from Cat cat where cat.kittens.size 
&gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) 
&gt; 0</pre><p>Para coleções indexadas, você pode se referir aos índices máximo e mínimo, usando as funções <code class="literal">minindex</code> e <code class="literal">maxindex</code>. Igualmente, pode-se referir aos elementos máximo e mínimo de uma coleção de tipos básicos usando as funções <code class="literal">minelement</code> e <code class="literal">maxelement</code>. Por exemplo: </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) 
&gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) 
&gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) 
&gt; 10000</pre><p>As funções SQL <code class="literal">any, some, all, exists, in</code> são suportadas quando passado o elemento ou o conjunto de índices de uma coleção (<code class="literal">elements</code> e <code class="literal">índices</code> de funções) ou o resultado de uma subconsulta (veja abaixo): </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 
&gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>Note que essas construções - <code class="literal">tamanho</code>, <code class="literal">elementos</code>, <code class="literal">índices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>, <code class="literal">minelement</code>, <code class="literal">maxelement</code> – só podem ser usados na cláusula where do Hibernate3. </p><p>Elementos de coleções com índice (matriz, listas, mapas) podem ser referenciadas pelo índice (apenas na cláusula where): </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>A expressão entre colchetes <code class="literal">[]</code> pode ser até uma expressão aritimética: </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>O HQL também provê a função interna <code class="literal">index()</code> para elementos de associação um-para-muitos ou coleção de valores. </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>Funções escalares SQL, suportadas pelo banco de dados subjacente podem ser usadas: </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>Se ainda não estiver totalmente convencido, pense o quão maior e menos legível poderia ser a consulta a seguir, em SQL:  </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>Hint:</em></span> algo como: </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>16.11. A cláusula ordenar por</h2></div></div></div><p>A lista retornada pela consulta pode ser ordenada por qualquer propriedade da classe ou componentes retornados: </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>As opções <code class="literal">asc</code> ou <code class="literal">desc</code> indicam ordem crescente ou decrescente, respectivamente. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>16.12. A cláusula agrupar por</h2></div></div></div><p>Uma consulta que retorne valores agregados, podem ser agrupados por qualquer propriedade de uma classe ou componentes retornados: </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p>Uma cláusula <code class="literal">having</code> também é permitida. </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>Funções SQL e funções agregadas são permitidas nas cláusulas <code class="literal">having</code> e <code class="literal">order by</code>, se suportadas pelo banco de dados subjacentes (ex: não no MeuSQL).  </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.name, cat.other, cat.properties
having avg(kitten.weight) 
&gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>Note que, nem a cláusula <code class="literal">group by</code> ou <code class="literal">order by</code> podem conter expressões aritméticas. O Hibernate também não expande atualmente uma entidade agrupada, portanto você não pode escrever <code class="literal">group by cat</code> caso todas as propriedades do <code class="literal">cat</code> não estiverem agregadas. Você precisa listar claramente todas as propriedades não-agregadas.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>16.13. Subconsultas</h2></div></div></div><p>Para bancos de dados que suportam subseleções, o Hibernate suporta subconsultas dentro de consultas. Uma subconsulta precisa estar entre parênteses (normalmente uma chamada de função agregada SQL). Mesmo subconsultas co-relacionadas (subconsultas que fazem referência à alias de outras consultas), são aceitas. </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight 
&gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>Note que HQL subconsultas podem aparecer apenas dentro de cláusulas select ou where.  </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a class="xref" href="queryhql.html#queryhql-tuple" title="16.18. Sintáxe do construtor de valores de linha">Seção 16.18, “Sintáxe do construtor de valores de linha”</a> for more information. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>16.14. Exemplos de HQL</h2></div></div></div><p>As consultas do Hibernate, podem ser muito poderosas e complexas. De fato, o poder da linguagem de consulta é um dos pontos principais na distribuição do Hibernate. Aqui temos algumas consultas de exemplo, muito similares a consultas usadas em um projeto recente. Note que a maioria das consultas que você irá escrever, são mais simples que estas. </p><p>A consulta a seguir retorna o id de ordenar, número de ítens e o valor total do ordenar para todos os ordenar não pagos para um cliente particular e valor total mínimo dado, ordenando os resultados por valor total. Para determinar os preços, utiliza-se o catálogo atual. A consulta SQL resultante, usando tabelas <code class="literal">ORDER</code>, <code class="literal">ORDER_LINE</code>, <code class="literal">PRODUCT</code>, <code class="literal">CATALOG</code> e <code class="literal">PRICE</code>, têm quatro uniões inteiras e uma subseleção (não correlacionada). </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate 
&gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>Que monstro! Na verdade, na vida real, eu não sou muito afeiçoado à subconsultas, então minha consulta seria mais parecida com isto: </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>A próxima consulta conta o número de pagamentos em cada status, excluindo todos os pagamentos no status <code class="literal">AWAITING_APPROVAL</code>, onde a mais recente mudança de status foi feita pelo usuário atual. Traduz-se para uma consulta SQL <code class="literal">com</code> duas uniões inteiras e uma subseleção correlacionada, nas tabelas <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code> e <code class="literal">PAYMENT_STATUS_CHANGE</code> . </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;
&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>Se eu tivesse mapeado a coleção <code class="literal">statusChanges</code> como um List, ao invés de um Set, a consulta teria sido muito mais simples de escrever.  </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;
&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>A próxima consulta usa a função <code class="literal">isNull()</code> do Servidor MS SQL, para retornar todas as contas e pagamentos não efetuados para a organização, para aquele que o usuário atual pertencer. Traduz-se para uma consulta SQL <code class="literal">com</code> três uniões inteiras, uma união externa e uma subseleção nas tabelas <code class="literal">ACCOUNT</code>, <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">ACCOUNT_TYPE</code>, <code class="literal">ORGANIZATION</code> e <code class="literal">ORG_USER</code> . </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>Para alguns bancos de dados, precisaremos eliminar a subseleção (correlacionada). </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>16.15. Atualização e correção em lote</h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a class="xref" href="batch.html#batch-direct" title="15.4. Operações no estilo DML">Seção 15.4, “Operações no estilo DML”</a> for more information. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>16.16. Dicas &amp; Truques</h2></div></div></div><p>Pode-se contar o número de resultados da consulta, sem realmente retorná-los: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p>Para ordenar um resultado pelo tamanho de uma coleção, use a consulta a seguir. </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>Se seu banco de dados suporta subseleções, pode-se colocar uma condição sobre tamanho de seleção na cláusula where da sua consulta: </p><pre class="programlisting">from User usr where size(usr.messages) 
&gt;= 1</pre><p>Se seu banco de dados não suporta subseleções, use a consulta a seguir:  </p><pre class="programlisting">select usr.id, usr.name
from User usr
    join usr.messages msg
group by usr.id, usr.name
having count(msg) 
&gt;= 1</pre><p>Com essa solução não se pode retornar um <code class="literal">User</code> sem nenhuma menssagem, por causa da união inteira, a forma a seguir também é útil: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>As propriedades de um JavaBean podem ser limitadas à parâmetros nomeados da consulta: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;foo&nbsp;Foo&nbsp;as&nbsp;foo&nbsp;where&nbsp;foo.name=:name&nbsp;and&nbsp;foo.size=:size&quot;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setProperties</span><span class="java_separator">(</span><span class="java_plain">fooBean</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;fooBean&nbsp;has&nbsp;getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;and&nbsp;getSize</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;foos&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>As coleções são pagináveis, usando a interface <code class="literal">Query</code> com um filtro: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;the&nbsp;trivial&nbsp;filter</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setFirstResult</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE&nbsp;</span><span class="java_operator">*</span><span class="java_plain">&nbsp;pageNumber</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;page&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>Os elementos da coleção podem ser ordenados ou agrupados usando um filtro de consulta:  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Collection</span><!-- <br/> --><span class="java_plain">&nbsp;orderedCollection&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">filter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;order&nbsp;by&nbsp;this.amount&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Collection</span><span class="java_plain">&nbsp;counts&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">filter</span><span class="java_separator">(</span><span class="java_plain">&nbsp;collection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;select&nbsp;this.type,&nbsp;count(this)&nbsp;group&nbsp;by&nbsp;this.type&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span></pre><p>Pode-se achar o tamanho de uma coleção sem inicializá-la: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>16.17. Componentes</h2></div></div></div><p>Os componentes podem ser usados de quase todas as formas que os tipos de valores simples são usados nas consultas HQL. Eles podem aparecer na cláusula <code class="literal">select</code>:  </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>onde a propriedade do nome da Person é um componente. Os componentes também podem ser utilizados na cláusula <code class="literal">where</code>: </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>Os componentes também podem ser usados na cláusula <code class="literal">order by</code>: </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>Outro uso comum dos componentes é nos <a class="link" href="queryhql.html#queryhql-tuple" title="16.18. Sintáxe do construtor de valores de linha">row value constructors</a>. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>16.18. Sintáxe do construtor de valores de linha</h2></div></div></div><p>O HQL suporta o uso da sintáxe ANSI SQL <code class="literal">row value constructor</code>, algumas vezes chamado de sintáxe <code class="literal">tupla</code>, embora o banco de dados adjacente possa não suportar esta noção. Aqui nós geralmente nos referimos às comparações de valores múltiplos, tipicamente associada aos componentes. Considere uma entidade Person que define um componente de nome: </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>Esta é uma sintáxe válida, embora um pouco verbosa. Seria ótimo tornar essa sintáxe um pouco mais concisa e utilizar a sintáxe <code class="literal">row value constructor</code>: </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p>Pode também ser útil especificar isto na cláusula <code class="literal">select</code>: </p><pre class="programlisting">select p.name from Person p</pre><p>Com o uso da sintáxe <code class="literal">row value constructor</code>, e que pode ser de benéfico, seria quando utilizar as subconsultas que precisem comparar com os valores múltiplos: </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>Ao decidir se você quer usar esta sintáxe ou não, deve-se considerar o fato de que a consulta será dependente da ordenação das sub-propriedades do componente no metadados.  </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>Anterior</strong>Capítulo 15. Batch processing</a></li><li class="up"><a accesskey="u" href="#"><strong>Acima</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Principal</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>Próxima</strong>Capítulo 17. Consultas por critérios</a></li></ul></body></html>