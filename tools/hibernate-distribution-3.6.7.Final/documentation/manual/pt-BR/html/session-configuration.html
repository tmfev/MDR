<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 3. Configuration</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="prev" href="architecture.html" title="Capítulo 2. Arquitetura"/><link rel="next" href="persistent-classes.html" title="Capítulo 4. Classes Persistentes"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="architecture.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="persistent-classes.html"><strong>Próxima</strong></a></li></ul><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="session-configuration"/>Capítulo 3. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="session-configuration.html#configuration-programmatic">3.1. Configuração programática</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-sessionfactory">3.2. Obtendo uma SessionFactory</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-hibernatejdbc">3.3. Conexões JDBC</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional">3.4. Propriedades opcionais de configuração</a></span></dt><dd><dl><dt><span class="section"><a href="session-configuration.html#configuration-optional-dialects">3.4.1. Dialetos SQL</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-outerjoin">3.4.2. Busca por união externa (Outer Join Fetching)</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-binarystreams">3.4.3. Fluxos Binários (Binary Streams)</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-cacheprovider">3.4.4. Cachê de segundo nível e consulta</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-querysubstitution">3.4.5. Substituição na Linguagem de Consulta</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-statistics">3.4.6. Estatísticas do Hibernate</a></span></dt></dl></dd><dt><span class="section"><a href="session-configuration.html#configuration-logging">3.5. Logging</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-namingstrategy">3.6. Implementando um NamingStrategy</a></span></dt><dt><span class="section"><a href="session-configuration.html#d0e3397">3.7. Implementing a PersisterClassProvider</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-xmlconfig">3.8. Arquivo de configuração XML</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-j2ee">3.9. Java EE Application Server integration</a></span></dt><dd><dl><dt><span class="section"><a href="session-configuration.html#configuration-optional-transactionstrategy">3.9.1. Configuração de estratégia de transação</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-jndi">3.9.2. SessionFactory vinculada à JNDI</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-j2ee-currentsession">3.9.3. Gerenciamento de contexto de Sessão atual com JTA</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-j2ee-jmx">3.9.4. implementação JMX </a></span></dt></dl></dd></dl></div><p>Devido ao fato do Hibernate ser projetado para operar em vários ambientes diferentes, há um grande número de parâmetros de configuração. Felizmente, a maioria possui valores padrão consideráveis e o Hibernate é distribuído com um arquivo <code class="literal">hibernate.properties</code> de exemplo no <code class="literal">etc/</code> que mostra várias opções. Apenas coloque o arquivo de exemplo no seu classpath e personalize-o. </p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-programmatic"/>3.1. Configuração programática</h2></div></div></div><p>Uma instância de <code class="literal">org.hibernate.cfg.Configuration</code> representa um conjunto inteiro de mapeamentos de tipos Java de aplicação para um banco de dados SQL. O <code class="classname">org.hibernate.cfg.Configuration</code> é usado para construir uma <code class="literal">SessionFactory</code> imutável. Os mapeamentos são compilados a partir de diversos arquivos de mapeamento XML. </p><p>Você pode obter uma instância <code class="classname">org.hibernate.cfg.Configuration</code> intanciando-a diretamente e especificando os documentos de mapeamento XML. Se os arquivos de mapeamento estiverem no classpath, use <code class="literal">addResource()</code>. Por exemplo:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_plain">&nbsp;cfg&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addResource</span><span class="java_separator">(</span><span class="java_literal">&quot;Item.hbm.xml&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addResource</span><span class="java_separator">(</span><span class="java_literal">&quot;Bid.hbm.xml&quot;</span><span class="java_separator">);</span></pre><p>Uma alternativa é especificar a classe mapeada e permitir que o Hibernate encontre o documento de mapeamento para você:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_plain">&nbsp;cfg&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addClass</span><span class="java_separator">(</span><span class="java_plain">org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">auction</span><span class="java_separator">.</span><span class="java_type">Item</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addClass</span><span class="java_separator">(</span><span class="java_plain">org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">auction</span><span class="java_separator">.</span><span class="java_type">Bid</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">);</span></pre><p>O Hibernate procurará pelos arquivos de mapeamento chamados <code class="literal">/org/hibernate/auction/Item.hbm.xml</code> e <code class="literal">/org/hibernate/auction/Bid.hbm.xml</code> no classpath. Esta abordagem elimina qualquer nome de arquivo de difícil compreensão.</p><p>Uma <code class="literal">Configuration</code> também permite que você especifique propriedades de configuração específica. Por exemplo:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_plain">&nbsp;cfg&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addClass</span><span class="java_separator">(</span><span class="java_plain">org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">auction</span><span class="java_separator">.</span><span class="java_type">Item</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addClass</span><span class="java_separator">(</span><span class="java_plain">org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">auction</span><span class="java_separator">.</span><span class="java_type">Bid</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate.dialect&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;org.hibernate.dialect.MySQLInnoDBDialect&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate.connection.datasource&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;java:comp/env/jdbc/test&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate.order_updates&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;true&quot;</span><span class="java_separator">);</span></pre><p>Esta não é a única forma de passar as propriedades de configuração para o Hibernate. As várias opções incluem: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Passar uma instância de <code class="literal">java.util.Properties</code> para <code class="literal">Configuration.setProperties()</code>. </p></li><li><p>Colocar <code class="literal">hibernate.properties</code> de arquivo nomeado no diretório raíz do classpath.</p></li><li><p>Determinar as propriedades do <code class="literal">System</code> usando <code class="literal">java -Dproperty=value</code>.</p></li><li><p>Incluir elementos <code class="literal">&lt;property&gt;</code> no <code class="literal">hibernate.cfg.xml</code> (discutido mais tarde). </p></li></ol></div><p>Caso você deseje inicializar rapidamente o <code class="filename">hibernate.properties</code> é a abordagem mais rápida.</p><p>O <code class="classname">org.hibernate.cfg.Configuration</code> é previsto como um objeto de tempo de inicialização, a ser descartado quando um <code class="literal">SessionFactory</code> for criado.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-sessionfactory"/>3.2. Obtendo uma SessionFactory</h2></div></div></div><p>Quando todos os mapeamentos forem analisados pelo <code class="classname">org.hibernate.cfg.Configuration</code>, a aplicação deve obter uma factory para as instâncias do <code class="interfacename">org.hibernate.Session</code>. O objetivo desta factory é ser compartilhado por todas as threads da aplicação: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sessions&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;cfg</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">buildSessionFactory</span><!-- <br/> --><span class="java_separator">();</span></pre><p>O Hibernate permite sua aplicação instanciar mais do que um <code class="interfacename">org.hibernate.SessionFactory</code>. Isto será útil se você estiver usando mais do que um banco de dados.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-hibernatejdbc"/>3.3. Conexões JDBC</h2></div></div></div><p>Normalmente, você deseja que o <code class="interfacename">org.hibernate.SessionFactory</code> crie e faça um um pool de conexões JDBC para você. Se você seguir essa abordagem, a abertura de um <code class="interfacename">org.hibernate.Session</code> será tão simples quanto:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Session</span><!-- <br/> --><span class="java_plain">&nbsp;session&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessions</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">openSession</span><!-- <br/> --><span class="java_separator">();</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;open&nbsp;a&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Session</span></pre><p>Assim que você fizer algo que requeira o acesso ao banco de dados, uma conexão JDBC será obtida a partir do pool.</p><p>Para esse trabalho, precisaremos passar algumas propriedades da conexão JDBC para o Hibernate. Todos os nomes de propriedades Hibernate e semânticas são definidas na classe <code class="literal">org.hibernate.cfg.Environment</code>. Descreveremos agora as configurações mais importantes para a conexão JDBC. </p><p>O Hibernate obterá conexões (e efetuará o pool) usando <code class="literal">java.sql.DriverManager</code> se você determinar as seguintes propriedades: </p><div class="table"><a id="d0e1826"/><p class="title"><b>Tabela 3.1. Propriedades JDBC Hibernate</b></p><div class="table-contents"><table summary="Propriedades JDBC Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nome da Propriedade</th><th>Propósito</th></tr></thead><tbody><tr><td><span class="property">hibernate.connection.driver_class</span></td><td><span class="emphasis"><em>JDBC driver class</em></span></td></tr><tr><td><span class="property">hibernate.connection.url</span></td><td><span class="emphasis"><em>JDBC URL</em></span></td></tr><tr><td><span class="property">hibernate.connection.username</span></td><td><span class="emphasis"><em>database user</em></span></td></tr><tr><td><span class="property">hibernate.connection.password</span></td><td><span class="emphasis"><em>database user password</em></span></td></tr><tr><td><span class="property">hibernate.connection.pool_size</span></td><td><span class="emphasis"><em>maximum number of pooled connections</em></span></td></tr></tbody></table></div></div><br class="table-break"/><p>No entanto, o algoritmo de pool de conexões do próprio Hibernate é um tanto rudimentar. A intenção dele é ajudar a iniciar e <span class="emphasis"><em>não para ser usado em um sistema de produção</em></span> ou até para testar o desempenho. Você deve utilizar um pool de terceiros para conseguir um melhor desempenho e estabilidade. Apenas substitua a propriedade <code class="literal">hibernate.connection.pool_size</code> pela configuração específica do pool de conexões. Isto irá desligar o pool interno do Hibernate. Por exemplo, você pode gostar de usar C3P0. </p><p>O C3P0 é um pool conexão JDBC de código aberto distribuído junto com Hibernate no diretório <code class="literal">lib</code>. O Hibernate usará o próprio <code class="classname">org.hibernate.connection.C3P0ConnectionProvider</code> para o pool de conexão se você configurar a propriedade <code class="literal">hibernate.c3p0.*</code>. Se você gostar de usar Proxool, consulte o pacote <code class="literal">hibernate.properties</code> e o web site do Hibernate para mais informações.</p><p>Este é um exemplo de arquivo <code class="literal">hibernate.properties</code> para c3p0:</p><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>Para usar dentro de um servidor de aplicação, você deve configurar o Hibernate para obter conexões de um servidor de aplicação <code class="interfacename">javax.sql.Datasource</code> registrado no JNDI. Você precisará determinar pelo menos uma das seguintes propriedades:</p><div class="table"><a id="d0e1908"/><p class="title"><b>Tabela 3.2. Propriedades do Datasource do Hibernate</b></p><div class="table-contents"><table summary="Propriedades do Datasource do Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nome da Propriedade</th><th>Propósito</th></tr></thead><tbody><tr><td><span class="property">hibernate.connection.datasource</span></td><td><span class="emphasis"><em>datasource JNDI name</em></span></td></tr><tr><td><span class="property">hibernate.jndi.url</span></td><td><span class="emphasis"><em>URL do fornecedor JNDI</em></span> (opcional)</td></tr><tr><td><span class="property">hibernate.jndi.class</span></td><td><span class="emphasis"><em>classe de JNDI <code class="literal">InitialContextFactory</code></em></span> (opcional)</td></tr><tr><td><span class="property">hibernate.connection.username</span></td><td><span class="emphasis"><em>usuário de banco de dados</em></span> (opcional)</td></tr><tr><td><span class="property">hibernate.connection.password</span></td><td><span class="emphasis"><em>senha de usuário de banco de dados</em></span> (opcional)</td></tr></tbody></table></div></div><br class="table-break"/><p>Eis um exemplo de arquivo <code class="literal">hibernate.properties</code> para um servidor de aplicação fornecedor de fontes de dados JNDI:</p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>Conexões JDBC obtidas de um datasource JNDI irão automaticamente participar das transações gerenciadas pelo recipiente no servidor de aplicação.</p><p>As propriedades de conexão arbitrárias podem ser acrescentandas ao "<code class="literal">hibernate.connnection</code>" ao nome da propriedade. Por exemplo, você deve especificar a propriedade de conexão <code class="literal">charSet</code> usando <span class="property">hibernate.connection.charSet</span>.</p><p>Você pode definir sua própria estratégia de plugin para obter conexões JDBC implementando a interface <code class="literal">org.hibernate.connection.ConnectionProvider</code> e especificando sua implementação customizada através da propriedade <code class="literal">hibernate.connection.provider_class</code>.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-optional"/>3.4. Propriedades opcionais de configuração</h2></div></div></div><p>Há um grande número de outras propriedades que controlam o comportamento do Hibernate em tempo de execução. Todos são opcionais e têm valores padrão lógicos. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Atenção</h2><p><span class="emphasis"><em>Algumas destas propriedades são somente em nível de sistema.</em></span>. As propriedades em nível de sistema podem ser determinadas somente via <code class="literal">java -Dproperty=value</code> ou <code class="literal">hibernate.properties</code>. Elas <span class="emphasis"><em>não podem</em></span> ser configuradas por outras técnicas descritas acima.</p></div><div class="table"><a id="configuration-optional-properties"/><p class="title"><b>Tabela 3.3. Propriedades de Configuração do Hibernate</b></p><div class="table-contents"><table summary="Propriedades de Configuração do Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nome da Propriedade</th><th>Propósito</th></tr></thead><tbody><tr><td><span class="property">hibernate.dialect</span></td><td>O nome da classe de um Hibernate <code class="classname">org.hibernate.dialect.Dialect</code> que permite o Hibernate gerar SQL otimizado para um banco de dados relacional em particular.   <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">full.classname.of.Dialect</code> </p> <p>Na maioria dos casos, o Hibernate irá atualmente estar apto a escolher a implementação <code class="classname">org.hibernate.dialect.Dialect</code> correta baseada no <code class="literal">JDBC metadata</code> retornado pelo JDBC driver. </p></td></tr><tr><td><span class="property">hibernate.show_sql</span></td><td>Escreve todas as instruções SQL no console. Esta é uma alternativa para configurar a categoria de log <code class="literal">org.hibernate.SQL</code> to <code class="literal">debug</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.format_sql</span></td><td>Imprime o SQL formatado no log e recipiente.  <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.default_schema</span></td><td>Qualifica no SQL gerado, os nome das tabelas desqualificadas com o esquema/espaço da tabela dado. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">SCHEMA_NAME</code> </p></td></tr><tr><td><span class="property">hibernate.default_catalog</span></td><td>Qualifica no SQL gerado, os nome das tabelas desqualificadas com catálogo dado. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">CATALOG_NAME</code> </p></td></tr><tr><td><span class="property">hibernate.session_factory_name</span></td><td>O <code class="interfacename">org.hibernate.SessionFactory</code> irá automaticamente se ligar a este nome no JNDI depois de ter sido criado.  <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p></td></tr><tr><td><span class="property">hibernate.max_fetch_depth</span></td><td>Estabelece a "profundidade" máxima para árvore de busca de união externa para associações finais únicas (um para um, muitos para um). Um <code class="literal">0</code> desativa por padrão a busca de união externa.   <p><span class="strong"><strong>eg.</strong></span> valores recomendados entre<code class="literal">0</code> e <code class="literal">3</code> </p></td></tr><tr><td><span class="property">hibernate.default_batch_fetch_size</span></td><td>Determina um tamanho padrão para busca de associações em lotes do Hibernate. <p><span class="strong"><strong>eg.</strong></span> valores recomendados <code class="literal">4</code>, <code class="literal">8</code>, <code class="literal">16</code> </p></td></tr><tr><td><span class="property">hibernate.default_entity_mode</span></td><td>Determina um modo padrão para representação de entidade para todas as sessões abertas desta <code class="literal">SessionFactory</code>  <p><code class="literal">dynamic-map</code>, <code class="literal">dom4j</code>, <code class="literal">pojo</code> </p></td></tr><tr><td><span class="property">hibernate.order_updates</span></td><td>Força o Hibernate a ordenar os updates SQL pelo valor da chave primária dos ítens a serem atualizados. Isto resultará em menos deadlocks nas transações em sistemas altamente concorrente.  <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.generate_statistics</span></td><td>Se habilitado, o Hibernate coletará estatísticas úteis para o ajuste do desempenho.  <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.use_identifier_rollback</span></td><td>Se habilitado, propriedades identificadoras geradas serão zeradas para os valores padrão quando os objetos forem apagados.  <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.use_sql_comments</span></td><td>Se ligado, o Hibernate irá gerar comentários dentro do SQL, para facilitar a depuração, o valor padrão é <code class="literal">false</code> <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.id.new_generator_mappings</span></td><td>Setting is relevant when using <code class="classname">@GeneratedValue</code>. It indicates whether or not the new <code class="classname">IdentifierGenerator</code> implementations are used for <code class="classname">javax.persistence.GenerationType.AUTO</code>, <code class="classname">javax.persistence.GenerationType.TABLE</code> and <code class="classname">javax.persistence.GenerationType.SEQUENCE</code>. Default to <code class="literal">false</code> to keep backward compatibility. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>We recommend all new projects which make use of to use <code class="classname">@GeneratedValue</code> to also set <code class="code">hibernate.id.new_generator_mappings=true</code> as the new generators are more efficient and closer to the JPA 2 specification semantic. However they are not backward compatible with existing databases (if a sequence or a table is used for id generation).</p></div><div class="table"><a id="configuration-jdbc-properties"/><p class="title"><b>Tabela 3.4. JDBC Hibernate e Propriedades de Conexão</b></p><div class="table-contents"><table summary="JDBC Hibernate e Propriedades de Conexão" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nome da Propriedade</th><th>Propósito</th></tr></thead><tbody><tr><td><span class="property">hibernate.jdbc.fetch_size</span></td><td>Um valor maior que zero determina o tamanho da buscado JDBC (chamadas <code class="literal">Statement.setFetchSize()</code>).</td></tr><tr><td><span class="property">hibernate.jdbc.batch_size</span></td><td>Um valor maior que zero habilita o uso das atualizações em lotes JDBC2 pelo Hibernate.   <p><span class="strong"><strong>ex.</strong></span> valores recomentados entre <code class="literal">5</code> e <code class="literal">30</code> </p></td></tr><tr><td><span class="property">hibernate.jdbc.batch_versioned_data</span></td><td>Set this property to <code class="literal">true</code> if your JDBC driver returns correct row counts from <code class="literal">executeBatch()</code>. It is usually safe to turn this option on. Hibernate will then use batched DML for automatically versioned data. Defaults to <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.jdbc.factory_class</span></td><td>Escolher um <code class="interfacename">org.hibernate.jdbc.Batcher</code>. Muitas aplicações não irão precisar desta propriedade de configuração. <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">classname.of.BatcherFactory</code> </p></td></tr><tr><td><span class="property">hibernate.jdbc.use_scrollable_resultset</span></td><td>Habilita o uso dos resultados de ajustes roláveis do JDBC2 pelo Hibernate. Essa propriedade somente é necessária quando se usa Conexões JDBC providas pelo usuário. Do contrário, o Hibernate os os metadados da conexão.  <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.jdbc.use_streams_for_binary</span></td><td>Utilize fluxos para escrever/ler tipos <code class="literal">binary</code> ou tipos <code class="literal">serializable</code> para/do JDBC. <span class="emphasis"><em>*system-level property*</em></span> <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.jdbc.use_get_generated_keys</span></td><td>Possibilita o uso do <code class="literal">PreparedStatement.getGeneratedKeys()</code> JDBC3 para recuperar chaves geradas de forma nativa depois da inserção. Requer driver JDBC3+ e JRE1.4+, ajuste para falso se seu driver tiver problemas com gerador de indentificadores Hibernate. Por padrão, tente determinar o driver capaz de usar metadados da conexão.   <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">true|false</code>   </p></td></tr><tr><td><span class="property">hibernate.connection.provider_class</span></td><td>O nome da classe de um <code class="interfacename">org.hibernate.connection.ConnectionProvider</code>, do qual proverá conexões JDBC para o Hibernate.  <p><span class="strong"><strong>exemplo</strong></span><code class="literal">classname.of.ConnectionProvider</code>   </p></td></tr><tr><td><span class="property">hibernate.connection.isolation</span></td><td>Determina o nível de isolamento de uma transação JDBC. Verifique <code class="literal">java.sql.Connection</code> para valores significativos mas note que a maior parte dos bancos de dados não suportam todos os isolamentos que não são padrões.  <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">1, 2, 4, 8</code> </p></td></tr><tr><td><span class="property">hibernate.connection.autocommit</span></td><td>Habilita o auto-commit para conexões no pool JDBC (não recomendado).  <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><span class="property">hibernate.connection.release_mode</span></td><td>Especifica quando o Hibernate deve liberar conexões JDBC. Por padrão, uma conexão JDBC é retida até a sessão estar explicitamente fechada ou desconectada. Para uma fonte de dados JTA do servidor de aplicação, você deve usar <code class="literal">after_statement</code> para forçar a liberação da conexões depois de todas as chamadas JDBC. Para uma conexão não-JTA, freqüentemente faz sentido liberar a conexão ao fim de cada transação, usando <code class="literal">after_transaction</code>. O <code class="literal">auto</code> escolherá <code class="literal">after_statement</code> para as estratégias de transaçãoes JTA e CMT e <code class="literal">after_transaction</code> para as estratégias de transação JDBC. <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">auto</code> (padrão) | <code class="literal">on_close</code> | <code class="literal">after_transaction</code> | <code class="literal">after_statement</code>  </p> <p>This setting only affects <code class="literal">Session</code>s returned from <code class="literal">SessionFactory.openSession</code>. For <code class="literal">Session</code>s obtained through <code class="literal">SessionFactory.getCurrentSession</code>, the <code class="literal">CurrentSessionContext</code> implementation configured for use controls the connection release mode for those <code class="literal">Session</code>s. See <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sessões Contextuais">Seção 2.3, “Sessões Contextuais”</a> </p></td></tr><tr><td><span class="property">hibernate.connection.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span></td><td>Passar a propriedade JDBC <span class="emphasis"><em>&lt;propertyName&gt;</em></span> para <code class="literal">DriverManager.getConnection()</code>.</td></tr><tr><td><span class="property">hibernate.jndi.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span></td><td>Passar a propriedade <span class="emphasis"><em>&lt;propertyName&gt;</em></span> para o JNDI <code class="literal">InitialContextFactory</code>.</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-cache-properties"/><p class="title"><b>Tabela 3.5. Propriedades de Cachê do Hibernate</b></p><div class="table-contents"><table summary="Propriedades de Cachê do Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nome da Propriedade</th><th>Propósito</th></tr></thead><tbody><tr><td><code class="literal">hibernate.cache.provider_class</code></td><td>O nome da classe de um  <code class="literal">CacheProvider</code> personalizado. <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">classname.of.CacheProvider</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.use_minimal_puts</code></td><td>Otimizar operação de cachê de segundo nível para minimizar escritas, ao custo de leituras mais freqüentes. Esta configuração é mais útil para cachês em cluster e, no Hibernate3, é habilitado por padrão para implementações de cache em cluster.  <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">true|false</code>   </p></td></tr><tr><td><code class="literal">hibernate.cache.use_query_cache</code></td><td>Habilita a cache de consultas. Mesmo assim, consultas individuais ainda têm que ser habilitadas para o cache. <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">true|false</code>   </p></td></tr><tr><td><code class="literal">hibernate.cache.use_second_level_cache</code></td><td>Pode ser utilizado para desabilitar completamente o cache de segundo nível, o qual é habilitado por padrão para as classes que especificam um mapeamento <code class="literal">&lt;cache&gt;</code>. <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">true|false</code>   </p></td></tr><tr><td><code class="literal">hibernate.cache.query_cache_factory</code></td><td>O nome de classe de uma interface personalizada <code class="literal">QueryCache</code>, padroniza para o <code class="literal">StandardQueryCache</code> criado automaticamente.  <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">classname.of.QueryCache</code> </p></td></tr><tr><td><code class="literal">hibernate.cache.region_prefix</code></td><td>Um prefixo para usar em nomes regionais de cachê de segundo nível <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">prefix</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.use_structured_entries</code></td><td>Força o Hibernate a armazenar dados no cachê de segundo nível em um formato mais humanamente amigável. <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">true|false</code>   </p></td></tr><tr><td><code class="literal">hibernate.cache.default_cache_concurrency_strategy</code></td><td>Setting used to give the name of the default <code class="classname">org.hibernate.annotations.CacheConcurrencyStrategy</code> to use when either <code class="classname">@Cacheable</code> or <code class="classname">@Cache</code> is used. <code class="code">@Cache(strategy="..")</code> is used to override this default.</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-transaction-properties"/><p class="title"><b>Tabela 3.6. Propriedades de Transação do Hibernate</b></p><div class="table-contents"><table summary="Propriedades de Transação do Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nome da Propriedade</th><th>Propósito</th></tr></thead><tbody><tr><td><code class="literal">hibernate.transaction.factory_class</code></td><td>O nome da classe de uma <code class="literal">TransactionFactory</code>  para usar com API do Hibernate  <code class="literal">Transaction</code> ( por padrão<code class="literal">JDBCTransactionFactory</code> ).  <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">classname.of.TransactionFactory</code>   </p></td></tr><tr><td><code class="literal">jta.UserTransaction</code></td><td>Um nome JNDI usado pelo  <code class="literal">JTATransactionFactory</code>para obter uma  <code class="literal">UserTransaction</code> JTA a partir do servidor de aplicação.  <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p></td></tr><tr><td><code class="literal">hibernate.transaction.manager_lookup_class</code></td><td>O nome da classe de um <code class="literal">TransactionManagerLookup</code>. Ele é requerido quando o caching a nível JVM estiver habilitado ou quando estivermos usando um gerador hilo em um ambiente JTA.  <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">classname.of.TransactionManagerLookup</code>  </p></td></tr><tr><td><code class="literal">hibernate.transaction.flush_before_completion</code></td><td>If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sessões Contextuais">Seção 2.3, “Sessões Contextuais”</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><code class="literal">hibernate.transaction.auto_close_session</code></td><td>If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and automatic session context management is preferred, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sessões Contextuais">Seção 2.3, “Sessões Contextuais”</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-misc-properties"/><p class="title"><b>Tabela 3.7. Propriedades Variadas</b></p><div class="table-contents"><table summary="Propriedades Variadas" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nome da Propriedade</th><th>Propósito</th></tr></thead><tbody><tr><td><code class="literal">hibernate.current_session_context_class</code></td><td>Supply a custom strategy for the scoping of the "current" <code class="literal">Session</code>. See <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sessões Contextuais">Seção 2.3, “Sessões Contextuais”</a> for more information about the built-in strategies. <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">jta</code> | <code class="literal">thread</code> | <code class="literal">managed</code> | <code class="literal">custom.Class</code> </p></td></tr><tr><td><code class="literal">hibernate.query.factory_class</code></td><td>Escolha a implementação de análise HQL.  <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">org.hibernate.hql.ast. ASTQueryTranslatorFactory</code> ou <code class="literal">org.hibernate.hql.classic. ClassicQueryTranslatorFactory</code> </p></td></tr><tr><td><code class="literal">hibernate.query.substitutions</code></td><td>Mapeamento a partir de símbolos em consultas do Hibernate para para símbolos SQL (símbolos devem ser por exemplo, funções ou nome literais).   <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</code>  </p></td></tr><tr><td><code class="literal">hibernate.hbm2ddl.auto</code></td><td>Automaticamente valida ou exporta DDL esquema para o banco de dados quando o <code class="literal">SessionFactory</code> é criado. Com <code class="literal">create-drop</code>, o esquema do banco de dados será excluido quando a <code class="literal">SessionFactory</code> for fechada explicitamente.  <p><span class="strong"><strong>exemplo</strong></span> <code class="literal">validate</code> | <code class="literal">update</code> | <code class="literal">create</code> | <code class="literal">create-drop</code>   </p></td></tr><tr><td><code class="literal">hibernate.hbm2ddl.import_files</code></td><td><p>Comma-separated names of the optional files containing SQL DML statements executed during the <code class="classname">SessionFactory</code> creation. This is useful for testing or demoing: by adding INSERT statements for example you can populate your database with a minimal set of data when it is deployed.</p><p>File order matters, the statements of a give file are executed before the statements of the following files. These statements are only executed if the schema is created ie if <code class="literal">hibernate.hbm2ddl.auto</code> is set to <code class="literal">create</code> or <code class="literal">create-drop</code>.</p><p><span class="strong"><strong>e.g.</strong></span> <code class="literal">/humans.sql,/dogs.sql</code> </p></td></tr><tr><td><code class="literal">hibernate.bytecode.use_reflection_optimizer</code></td><td><p>Enables the use of bytecode manipulation instead of runtime reflection. This is a System-level property and cannot be set in <code class="literal">hibernate.cfg.xml</code>. Reflection can sometimes be useful when troubleshooting. Hibernate always requires either CGLIB or javassist even if you turn off the optimizer.</p><p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p></td></tr><tr><td><code class="literal">hibernate.bytecode.provider</code></td><td><p>Both javassist or cglib can be used as byte manipulation engines; the default is <code class="literal">javassist</code>.</p><p><span class="strong"><strong>e.g.</strong></span> <code class="literal">javassist</code> | <code class="literal">cglib</code> </p></td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-dialects"/>3.4.1. Dialetos SQL</h3></div></div></div><p>Você deve sempre determinar a propriedade <code class="literal">hibernate.dialect</code> para a subclasse de <code class="literal">org.hibernate.dialect.Dialect</code> correta de seu banco de dados. Se você especificar um dialeto, o Hibernate usará padrões lógicos para qualquer um das outras propriedades listadas abaixo, reduzindo o esforço de especificá-los manualmente.</p><div class="table"><a id="sql-dialects"/><p class="title"><b>Tabela 3.8. Dialetos SQL do Hibernate (<code class="literal">hibernate.dialect</code>)</b></p><div class="table-contents"><table summary="Dialetos SQL do Hibernate (hibernate.dialect)" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>RDBMS</th><th>Dialeto</th></tr></thead><tbody><tr><td>DB2</td><td><code class="literal">org.hibernate.dialect.DB2Dialect</code></td></tr><tr><td>DB2 AS/400</td><td><code class="literal">org.hibernate.dialect.DB2400Dialect</code></td></tr><tr><td>DB2 OS390</td><td><code class="literal">org.hibernate.dialect.DB2390Dialect</code></td></tr><tr><td>PostgreSQL</td><td><code class="literal">org.hibernate.dialect.PostgreSQLDialect</code></td></tr><tr><td>MySQL5</td><td><code class="literal">org.hibernate.dialect.MySQL5Dialect</code></td></tr><tr><td>MySQL5 with InnoDB</td><td><code class="literal">org.hibernate.dialect.MySQL5InnoDBDialect</code></td></tr><tr><td>Meu SQL com MeuISAM</td><td><code class="literal">org.hibernate.dialect.MySQLMyISAMDialect</code></td></tr><tr><td>Oracle (qualquer versão)</td><td><code class="literal">org.hibernate.dialect.OracleDialect</code></td></tr><tr><td>Oracle 9i</td><td><code class="literal">org.hibernate.dialect.Oracle9iDialect</code></td></tr><tr><td>Oracle 10g</td><td><code class="literal">org.hibernate.dialect.Oracle10gDialect</code></td></tr><tr><td>Oracle 11g</td><td><code class="literal">org.hibernate.dialect.Oracle10gDialect</code></td></tr><tr><td>Sybase</td><td><code class="literal">org.hibernate.dialect.SybaseASE15Dialect</code></td></tr><tr><td>Sybase Qualquer lugar</td><td><code class="literal">org.hibernate.dialect.SybaseAnywhereDialect</code></td></tr><tr><td>Microsoft SQL Server 2000</td><td><code class="literal">org.hibernate.dialect.SQLServerDialect</code></td></tr><tr><td>Microsoft SQL Server 2005</td><td><code class="literal">org.hibernate.dialect.SQLServer2005Dialect</code></td></tr><tr><td>Microsoft SQL Server 2008</td><td><code class="literal">org.hibernate.dialect.SQLServer2008Dialect</code></td></tr><tr><td>SAP DB</td><td><code class="literal">org.hibernate.dialect.SAPDBDialect</code></td></tr><tr><td>Informix</td><td><code class="literal">org.hibernate.dialect.InformixDialect</code></td></tr><tr><td>HypersonicSQL</td><td><code class="literal">org.hibernate.dialect.HSQLDialect</code></td></tr><tr><td>H2 Database</td><td><code class="literal">org.hibernate.dialect.H2Dialect</code></td></tr><tr><td>Ingres</td><td><code class="literal">org.hibernate.dialect.IngresDialect</code></td></tr><tr><td>Progresso</td><td><code class="literal">org.hibernate.dialect.ProgressDialect</code></td></tr><tr><td>Mckoi SQL</td><td><code class="literal">org.hibernate.dialect.MckoiDialect</code></td></tr><tr><td>Interbase</td><td><code class="literal">org.hibernate.dialect.InterbaseDialect</code></td></tr><tr><td>Base Ponto</td><td><code class="literal">org.hibernate.dialect.PointbaseDialect</code></td></tr><tr><td>Base Frontal</td><td><code class="literal">org.hibernate.dialect.FrontbaseDialect</code></td></tr><tr><td>Firebird</td><td><code class="literal">org.hibernate.dialect.FirebirdDialect</code></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-outerjoin"/>3.4.2. Busca por união externa (Outer Join Fetching)</h3></div></div></div><p>Se seu banco de dados suporta união externa no estilo ANSI, Oracle ou Sybase, a <span class="emphasis"><em>outer join fetching</em></span> freqüentemente aumentará o desempenho limitando o número de chamadas (round trips) para e a partir do banco de dados. No entanto, isto ao custo de possivelmente mais trabalho desempenhado pelo próprio banco de dados. A busca por união externa (outer join fetching) permite um gráfico completo de objetos conectados por associações muitos-para-um, um-para-muitos, muitos-para-muitos e um-para-um para serem recuperadas em uma simples instrução SQL <code class="literal">SELECT</code>.</p><p>A busca por união externa pode ser desabilitada <span class="emphasis"><em>globalmente</em></span> configurando a propriedade <code class="literal">hibernate.max_fetch_depth</code> para <code class="literal">0</code>. Um valor <code class="literal">1</code> ou maior habilita a busca por união externa para associações um-para-um e muitos-para-um, cujos quais têm sido mapeados com <code class="literal">fetch="join"</code>.</p><p>See <a class="xref" href="performance.html#performance-fetching" title="21.1. Estratégias de Busca">Seção 21.1, “Estratégias de Busca ”</a> for more information.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-binarystreams"/>3.4.3. Fluxos Binários (Binary Streams)</h3></div></div></div><p>O Oracle limita o tamanho de matrizes de <code class="literal">byte</code> que podem ser passadas para/do driver JDBC. Se você desejar usar grandes instâncias de tipos <code class="literal">binary</code> ou <code class="literal">serializable</code>, você deve habilitar <code class="literal">hibernate.jdbc.use_streams_for_binary</code>. <span class="emphasis"><em>Essa é uma configuração que só pode ser feita em nível de sistema.</em></span> </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-cacheprovider"/>3.4.4. Cachê de segundo nível e consulta</h3></div></div></div><p>The properties prefixed by <code class="literal">hibernate.cache</code> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <a class="xref" href="performance.html#performance-cache" title="21.2. O Cachê de Segundo Nível">Seção 21.2, “O Cachê de Segundo Nível”</a> for more information.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-querysubstitution"/>3.4.5. Substituição na Linguagem de Consulta</h3></div></div></div><p>Você pode definir novos símbolos de consulta Hibernate usando <code class="literal">hibernate.query.substitutions</code>. Por exemplo: </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>Isto faria com que os símbolos <code class="literal">true</code> e <code class="literal">false</code> passasem a ser traduzidos para literais inteiros no SQL gerado.</p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>Isto permitirá que você renomeie a função <code class="literal">LOWER</code> no SQL.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-statistics"/>3.4.6. Estatísticas do Hibernate</h3></div></div></div><p>Se você habilitar <code class="literal">hibernate.generate_statistics</code>, o Hibernate exibirá um número de métricas bastante útil ao ajustar um sistema via <code class="literal">SessionFactory.getStatistics()</code>. O Hibernate pode até ser configurado para exibir essas estatísticas via JMX. Leia o Javadoc da interface <code class="literal">org.hibernate.stats</code> para mais informações.</p></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-logging"/>3.5. Logging</h2></div></div></div><p>O Hibernate utiliza o <a class="ulink" href="http://www.slf4j.org/">Simple Logging Facade for Java</a> (SLF4J) com o objetivo de registrar os diversos eventos de sistema. O SLF4J pode direcionar a sua saída de logging a diversos frameworks de logging (NOP, Simple, log4j version 1.2, JDK 1.4 logging, JCL ou logback) dependendo de sua escolha de vinculação. Com o objetivo de determinar o seu logging, você precisará do <code class="filename">slf4j-api.jar</code> em seu classpatch juntamente com o arquivo jar para a sua vinculação preferida - <code class="filename">slf4j-log4j12.jar</code> no caso do Log4J. Consulte o SLF4J <a class="ulink" href="http://www.slf4j.org/manual.html">documentation</a> para maiores detalhes. Para usar o Log4j você precisará também colocar um arquivo <code class="filename">log4j.properties</code> em seu classpath. Um exemplo do arquivo de propriedades está distribuído com o Hibernate no diretório <code class="literal">src/</code>. </p><p>Nós recomendamos que você se familiarize-se com mensagens de log do Hibernate. Tem sido um árduo trabalho fazer o log Hibernate tão detalhado quanto possível, sem fazê-lo ilegível. É um dispositivo de controle de erros essencial. As categorias de log mais interessantes são as seguintes:</p><div class="table"><a id="log-categories"/><p class="title"><b>Tabela 3.9. Categorias de Log do Hibernate</b></p><div class="table-contents"><table summary="Categorias de Log do Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Categoria</th><th>Função</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.SQL</code></td><td>Registra todas as instruções SQL DML a medida que elas são executadas</td></tr><tr><td><code class="literal">org.hibernate.type</code></td><td>Registra todos os parâmetros JDBC</td></tr><tr><td><code class="literal">org.hibernate.tool.hbm2ddl</code></td><td>Registra todas as instruções SQL DDL a medida que elas são executadas</td></tr><tr><td><code class="literal">org.hibernate.pretty</code></td><td>Registra o estado de todas as entidades (máximo 20 entidades) associadas à sessão no momento da liberação (flush).</td></tr><tr><td><code class="literal">org.hibernate.cache</code></td><td>Registra todas as atividades de cachê de segundo nível</td></tr><tr><td><code class="literal">org.hibernate.transaction</code></td><td>Registra atividades relacionada à transação</td></tr><tr><td><code class="literal">org.hibernate.jdbc</code></td><td>Registra todas as requisições de recursos JDBC</td></tr><tr><td><code class="literal">org.hibernate.hql.ast.AST</code></td><td>Registra instruções SQL e HQL durante a análise da consultas</td></tr><tr><td><code class="literal">org.hibernate.secure</code></td><td>Registra todas as requisições de autorização JAAS</td></tr><tr><td><code class="literal">org.hibernate</code></td><td>Registra tudo. Apesar de ter muita informação, é muito útil para o problema de inicialização.</td></tr></tbody></table></div></div><br class="table-break"/><p>Ao desenvolver aplicações com Hibernate, você deve quase sempre trabalhar com o depurador <code class="literal">debug</code> habilitado para a categoria <code class="literal">org.hibernate.SQL</code>, ou, alternativamente, com a propriedade <code class="literal">hibernate.show_sql</code> habilitada.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-namingstrategy"/>3.6. Implementando um <code class="literal">NamingStrategy</code></h2></div></div></div><p>A interface <code class="literal">org.hibernate.cfg.NamingStrategy</code> permite que você especifique um "padrão de nomeação" para objetos do banco de dados e elementos de esquema.</p><p>Você deve criar regras para a geração automaticamente de identificadores do banco de dados a partir de identificadores Java ou para processar colunas "lógicas" e nomes de tabelas dado o arquivo de mapeamento para nomes "físicos" de tabelas e colunas. Este recurso ajuda a reduzir a verbosidade do documento de mapeamento, eliminando interferências repetitivas (<code class="literal">TBL_</code> prefixos, por exemplo). A estratégia padrão usada pelo Hibernate é bastante mínima. </p><p>Você pode especificar uma estratégia diferente ao chamar <code class="literal">Configuration.setNamingStrategy()</code> antes de adicionar os mapeamentos: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sf&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setNamingStrategy</span><span class="java_separator">(</span><span class="java_type">ImprovedNamingStrategy</span><span class="java_separator">.</span><span class="java_plain">INSTANCE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addFile</span><span class="java_separator">(</span><span class="java_literal">&quot;Item.hbm.xml&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addFile</span><span class="java_separator">(</span><span class="java_literal">&quot;Bid.hbm.xml&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">buildSessionFactory</span><span class="java_separator">();</span></pre><p><code class="literal">org.hibernate.cfg.ImprovedNamingStrategy</code> é uma estratégia interna que pode ser um ponto inicial útil para algumas aplicações.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3397"/>3.7. Implementing a PersisterClassProvider</h2></div></div></div><p>You can configure the persister implementation used to persist your entities and collections:</p><div class="itemizedlist"><ul><li><p>by default, Hibernate uses persisters that make sense in a relational model and follow Java Persistence's specification</p></li><li><p>you can define a <code class="classname">PersisterClassProvider</code> implementation that provides the persister class used of a given entity or collection</p></li><li><p>finally, you can override them on a per entity and collection basis in the mapping using <code class="classname">@Persister</code> or its XML equivalent</p></li></ul></div><p>The latter in the list the higher in priority.</p><p>You can pass the <code class="classname">PersisterClassProvider</code> instance to the <code class="classname">Configuration</code> object.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sf&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setPersisterClassProvider</span><span class="java_separator">(</span><span class="java_plain">customPersisterClassProvider</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addAnnotatedClass</span><span class="java_separator">(</span><span class="java_type">Order</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">buildSessionFactory</span><span class="java_separator">();</span></pre><p>The persister class provider methods, when returning a non null persister class, override the default Hibernate persisters. The entity name or the collection role are passed to the methods. It is a nice way to centralize the overriding logic of the persisters instead of spreading them on each entity or collection mapping.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-xmlconfig"/>3.8. Arquivo de configuração XML</h2></div></div></div><p>Uma maneira alternativa de configuração é especificar uma configuração completa em um arquivo chamado <code class="literal">hibernate.cfg.xml</code>. Este arquivo pode ser usado como um substituto para o arquivo <code class="literal">hibernate.properties</code> ou, se ambos estiverem presentes, para substituir propriedades.</p><p>O arquivo XML de configuração deve ser encontrado na raíz do seu <code class="literal">CLASSPATH</code>. Veja um exemplo: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version='1.0'&nbsp;encoding='utf-8'?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">DOCTYPE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">hibernate-configuration</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">PUBLIC</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_value">&quot;-//Hibernate/Hibernate&nbsp;Configuration&nbsp;DTD//EN&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_value">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-configuration</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;a&nbsp;SessionFactory&nbsp;instance&nbsp;listed&nbsp;as&nbsp;/jndi/name&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">session-factory</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;java:hibernate/SessionFactory&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;properties&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;connection.datasource&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:/comp/env/jdbc/MyDB</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;dialect&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.hibernate.dialect.MySQLDialect</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;show_sql&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;transaction.factory_class&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.hibernate.transaction.JTATransactionFactory</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;jta.UserTransaction&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:comp/UserTransaction</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;mapping&nbsp;files&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">resource</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org/hibernate/auction/Item.hbm.xml&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">resource</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org/hibernate/auction/Bid.hbm.xml&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;cache&nbsp;settings&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class-cache</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.auction.Item&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">usage</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;read-write&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class-cache</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.auction.Bid&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">usage</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;read-only&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">collection-cache</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">collection</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.auction.Item.bids&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">usage</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;read-write&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">session-factory</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-configuration</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Como você pode ver, a vantagem deste enfoque é a externalização dos nomes dos arquivos de mapeamento para configuração. O <code class="literal">hibernate.cfg.xml</code> também é mais conveniente caso você tenha que ajustar o cache do Hibernate. Note que a escolha é sua em usar <code class="literal">hibernate.properties</code> ou <code class="literal">hibernate.cfg.xml</code>, ambos são equivalentes, exceto os acima mencionados de usar a sintaxe de XML. </p><p>Com a configuração do XML, iniciar o Hibernate é então tão simples quanto: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sf&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">configure</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">buildSessionFactory</span><!-- <br/> --><span class="java_separator">();</span></pre><p>Você poderá escolher um arquivo de configuração XML diferente, utilizando:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sf&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">configure</span><span class="java_separator">(</span><span class="java_literal">&quot;catdb.cfg.xml&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">buildSessionFactory</span><span class="java_separator">();</span></pre></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-j2ee"/>3.9. Java EE Application Server integration</h2></div></div></div><p>O Hibernate tem os seguintes pontos da integração para a infraestrutura de J2EE:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>DataSources gerenciados pelo container</em></span>: O Hibernate pode usar conexões JDBC gerenciadas pelo Container e fornecidas pela JNDI. Geralmente, um <code class="literal">TransactionManager</code> compatível com JTA e um <code class="literal">ResourceManager</code> cuidam do gerenciamento da transação (CMT), especialmente em transações distribuídas,  manipuladas através de vários DataSources. Naturalmente, você também pode demarcar os limites das transações programaticamente (BMT) ou você poderia querer usar a API opcional do Hibernate <code class="literal">Transaction</code> para esta manter seu código portável. </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Vinculação (binding) automática à JNDI</em></span>: O Hibernate pode associar sua <code class="literal">SessionFactory</code> a JNDI depois de iniciado.</p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Vinculação (binding) da Sessão na JTA:</em></span> A <code class="literal">Session</code> do Hibernate pode automaticamente ser ligada ao escopo da transações JTA. Simplesmente localizando a <code class="literal">SessionFactory</code> da JNDI e obtendo a <code class="literal">Session</code> corrente. Deixe o Hibernate cuidar da liberação e encerramento da <code class="literal">Session</code> quando as transações JTA terminarem. A Demarcação de transação pode ser declarativa (CMT) ou programática (BMT/Transação do usuário).</p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JMX deployment:</em></span> Se você usa um JMX servidor de aplicações capaz (ex. Jboss AS), você pode fazer a instalação do Hibernate como um MBean controlado. Isto evita ter que iniciar uma linha de código para construir sua <code class="literal">SessionFactory</code> de uma <code class="literal">Configuration</code>. O container iniciará seu <code class="literal">HibernateService</code>, e também cuidará das dependências de serviços (DataSources, têm que estar disponíveis antes do Hibernate iniciar, etc.). </p></li></ul></div><p>Dependendo do seu ambiente, você pode ter que ajustar a opção de configuração <code class="literal">hibernate.connection.aggressive_release</code> para verdadeiro ( true ), se seu servidor de aplicações lançar exeções "retenção de conexão".</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-transactionstrategy"/>3.9.1. Configuração de estratégia de transação</h3></div></div></div><p>A API Hibernate <code class="literal">Session</code> é independente de qualquer sistema de demarcação de transação em sua arquitetura. Se você deixar o Hibernate usar a JDBC diretamente, através de um pool de conexões, você pode inicializar e encerrar suas transações chamando a API JDBC. Se você rodar em um servidor de aplicações J2EE, você poderá usar transações controladas por beans e chamar a API JTA e <code class="literal">UserTransaction</code> quando necessário. </p><p>Para manter seu código portável entre estes dois (e outros) ambientes, recomendamos a API Hibernate <code class="literal">Transaction</code>, que envolve e esconde o sistema subjacente. Você tem que especificar uma classe construtora para instâncias <code class="literal">Transaction</code> ajustando a propriedade de configuração do <code class="literal">hibernate.transaction.factory_class</code>.</p><p>Existem três escolhas, ou internas, padrões: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code></span></dt><dd><p>delega as transações (JDBC) para bases de dados (Padrão)</p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.JTATransactionFactory</code></span></dt><dd><p>delega para uma transação à um container gerenciado se uma transação existente estiver de acordo neste contexto (ex: método bean de sessão EJB). No entanto, uma nova transação será iniciada e serão usadas transações controladas por um bean.</p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.CMTTransactionFactory</code></span></dt><dd><p>delega para um container gerenciador de transações JTA</p></dd></dl></div><p>Você também pode definir suas próprias estratégias de transação (para um serviço de transação CORBA, por exemplo).</p><p>Algumas características no Hibernate (ex., o cache de segundo nível, sessões contextuais com JTA, etc.) requerem acesso a JTA <code class="literal">TransactionManager</code> em um ambiente controlado. Em um servidor de aplicação você tem que especificar como o Hibernate pode obter uma referência para a <code class="literal">TransactionManager</code>, pois o J2EE não padroniza um mecanismo simples:</p><div class="table"><a id="jtamanagerlookup"/><p class="title"><b>Tabela 3.10. Gerenciadores de transações JTA</b></p><div class="table-contents"><table summary="Gerenciadores de transações JTA" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Factory de Transação</th><th align="center">Servidor de Aplicação</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</code></td><td align="center">JBoss AS</td></tr><tr><td><code class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</code></td><td align="center">Weblogic</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</code></td><td align="center">WebSphere</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</code></td><td align="center">WebSphere 6</td></tr><tr><td><code class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</code></td><td align="center">Orion</td></tr><tr><td><code class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</code></td><td align="center">Resin</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</code></td><td align="center">JOTM</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</code></td><td align="center">JOnAS</td></tr><tr><td><code class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</code></td><td align="center">JRun4</td></tr><tr><td><code class="literal">org.hibernate.transaction.BESTransactionManagerLookup</code></td><td align="center">Borland ES</td></tr><tr><td><code class="literal">org.hibernate.transaction.JBossTSStandaloneTransactionManagerLookup</code></td><td align="center">JBoss TS used standalone (ie. outside JBoss AS and a JNDI environment generally). Known to work for <code class="literal">org.jboss.jbossts:jbossjta:4.11.0.Final</code></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-jndi"/>3.9.2. <code class="literal">SessionFactory</code> vinculada à JNDI</h3></div></div></div><p>Uma <code class="literal">SessionFactory</code> de Hibernate vinculada à JNDI pode simplificar a localização da fábrica e a criação de novas <code class="literal">Session</code>s. Observe que isto não está relacionado a um <code class="literal">Datasource</code> ligado a JNDI, simplesmente ambos usam o mesmo registro.</p><p>Se você desejar ter uma <code class="literal">SessionFactory</code> limitada a um nome de espaço de JNDI, especifique um nome (ex.: <code class="literal">java:hibernate/SessionFactory</code>) usando a propriedade <code class="literal">hibernate.session_factory_name</code>. Se esta propriedade for omitida, a <code class="literal">SessionFactory</code> não será limitada ao JNDI. Isto é muito útil em ambientes com uma implementação padrão JNDI de somente leitura (ex.: Tomcat).</p><p>Ao vincular a <code class="literal">SessionFactory</code> ao JNDI, o Hibernate irá utilizar os valores de <code class="literal">hibernate.jndi.url</code>, <code class="literal">hibernate.jndi.class</code> para instanciar um contexto inicial. Se eles não forem especificados, será usado o padrão <code class="literal">InitialContext</code>.</p><p>O Hibernate colocará automaticamente a <code class="literal">SessionFactory</code> no JNDI depois que você chamar a <code class="literal">cfg.buildSessionFactory()</code>. Isto significa que você terá esta chamada em pelo menos algum código de inicialização (ou classe de utilidade) em seu aplicativo, a não ser que você use a implementação JMX com o <code class="literal">HibernateService</code> (discutido mais tarde). </p><p>Se você usar um JNDI <code class="literal">SessionFactory</code>, o EJB ou qualquer outra classe obterá a <code class="literal">SessionFactory</code> utilizando um localizador JNDI.</p><p>It is recommended that you bind the <code class="literal">SessionFactory</code> to JNDI in a managed environment and use a <code class="literal">static</code> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <code class="literal">SessionFactory</code> in a helper class, such as <code class="literal">HibernateUtil.getSessionFactory()</code>. Note that such a class is also a convenient way to startup Hibernate—see chapter 1.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-currentsession"/>3.9.3. Gerenciamento de contexto de Sessão atual com JTA</h3></div></div></div><p>The easiest way to handle <code class="literal">Sessions</code> and transactions is Hibernate's automatic "current" <code class="literal">Session</code> management. For a discussion of contextual sessions see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sessões Contextuais">Seção 2.3, “Sessões Contextuais”</a>. Using the <code class="literal">"jta"</code> session context, if there is no Hibernate <code class="literal">Session</code> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <code class="literal">sessionFactory.getCurrentSession()</code>. The <code class="literal">Session</code>s retrieved via <code class="literal">getCurrentSession()</code> in the <code class="literal">"jta"</code> context are set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <code class="literal">Session</code>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <code class="literal">UserTransaction</code>, or (recommended for portable code) use the Hibernate <code class="literal">Transaction</code> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred.</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-jmx"/>3.9.4. implementação JMX </h3></div></div></div><p>A linha <code class="literal">cfg.buildSessionFactory()</code> ainda precisa ser executada em algum local para conseguir uma <code class="literal">SessionFactory</code> em JNDI. Você pode escolher fazer isto em um bloqueio de inicializador <code class="literal">static</code>, como aquele em <code class="literal">HibernateUtil</code>, ou implementar o Hibernate como <span class="emphasis"><em>serviço gerenciado</em></span>.</p><p>O Hibernate é distribuído com o <code class="literal">org.hibernate.jmx.HibernateService</code> para implementação em um servidor de aplicativo com capacidades JMX, tal como o JBoss AS. A implementação atual e configuração é comercial. Segue aqui um exemplo do <code class="literal">jboss-service.xml</code> para o JBoss 4.0.x:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">mbean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">code</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.jmx.HibernateService&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;jboss.jca:service=HibernateFactory,name=HibernateFactory&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Required&nbsp;services&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">jboss.jca:service=RARDeployer</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">jboss.jca:service=LocalTxCM,name=HsqlDS</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Bind&nbsp;the&nbsp;Hibernate&nbsp;service&nbsp;to&nbsp;JNDI&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;JndiName&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:/hibernate/SessionFactory</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Datasource&nbsp;settings&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Datasource&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:HsqlDS</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Dialect&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.hibernate.dialect.HSQLDialect</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Transaction&nbsp;integration&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TransactionStrategy&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.hibernate.transaction.JTATransactionFactory</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TransactionManagerLookupStrategy&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.hibernate.transaction.JBossTransactionManagerLookup</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;FlushBeforeCompletionEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;AutoCloseSessionEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Fetching&nbsp;options&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MaximumFetchDepth&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Second-level&nbsp;caching&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;SecondLevelCacheEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheProviderClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.hibernate.cache.EhCacheProvider</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;QueryCacheEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Logging&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ShowSqlEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Mapping&nbsp;files&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MapResources&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">auction/Item.hbm.xml,auction/Category.hbm.xml</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">mbean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>Este arquivo é implementado em um diretório chamado <code class="literal">META-INF</code> e envolto em um arquivo JAR com a extensão <code class="literal">.sar</code> (arquivo de serviço). Você também pode precisar envolver o Hibernate, suas bibliotecas de terceiros solicitadas, suas classes persistentes compiladas, assim como seus arquivos de mapeamento no mesmo arquivo. Seus beans de empresa (geralmente beans de sessão) podem ser mantidos em seus próprios arquivos JAR, mas você poderá incluir estes arquivos EJB JAR no arquivo de serviço principal para conseguir uma única unidade de (hot)-deployable. Consulte a documentação do JBoss AS para maiores informações sobre o serviço JMX e implementação EJB.  </p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="architecture.html"><strong>Anterior</strong>Capítulo 2. Arquitetura </a></li><li class="up"><a accesskey="u" href="#"><strong>Acima</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Principal</strong></a></li><li class="next"><a accesskey="n" href="persistent-classes.html"><strong>Próxima</strong>Capítulo 4. Classes Persistentes</a></li></ul></body></html>