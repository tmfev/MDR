<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 13. Transações e Concorrência</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="prev" href="readonly.html" title="Capítulo 12. Read-only entities"/><link rel="next" href="events.html" title="Capítulo 14. Interceptadores e Eventos"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>Próxima</strong></a></li></ul><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>Capítulo 13. Transações e Concorrência </h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="transactions.html#transactions-basics">13.1. Sessão e escopos de transações</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-basics-uow">13.1.1. Unidade de trabalho</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-apptx">13.1.2. Longas conversações</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-identity">13.1.3. Considerando a identidade do objeto</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-issues">13.1.4. Edições comuns</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-demarcation">13.2. Demarcação de transações de bancos de dados</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-demarcation-nonmanaged">13.2.1. Ambiente não gerenciado</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-jta">13.2.2. Usando JTA</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-exceptions">13.2.3. Tratamento de Exceção</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-timeout">13.2.4. Tempo de espera de Transação</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-optimistic">13.3. Controle de concorrência otimista</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-optimistic-manual">13.3.1. Checagem de versão da aplicação</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-longsession">13.3.2. Sessão estendida e versionamento automático</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-detached">13.3.3. Objetos destacados e versionamento automático</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-customizing">13.3.4. Versionamento automático customizado</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-locking">13.4. Bloqueio Pessimista </a></span></dt><dt><span class="section"><a href="transactions.html#transactions-connection-release">13.5. Modos para liberar a conexão</a></span></dt></dl></div><p>O fator mais importante sobre o Hibernate e o controle de concorrência é que é muito fácil de ser compreendido. O Hibernate usa diretamente conexões de JDBC e recursos de JTA sem adicionar nenhum comportamento de bloqueio a mais. Recomendamos que você gaste algum tempo com o JDBC, o ANSI e a especificação de isolamento de transação de seu sistema de gerência da base de dados.  </p><p>O Hibernate não bloqueia objetos na memória. Sua aplicação pode esperar o comportamento tal qual definido de acordo com o nível de isolamento de suas transações de banco de dados. Note que graças ao <code class="literal">Session</code>, que também é um cache de escopo de transação, o Hibernate procura repetidamente por identificadores e consultas de entidade não consultas de relatórios que retornam valores escalares.  </p><p>Além do versionamento para o controle automático de concorrência otimista, o Hibernate oferece também uma API (menor) para bloqueio pessimista de linhas usando a sintáxe <code class="literal">SELECT FOR UPDATE</code>. O controle de concorrência otimista e esta API são discutidos mais tarde neste capítulo.  </p><p>Nós começamos a discussão do controle de concorrência no Hibernate com a granularidade do <code class="literal">Configuration</code>, <code class="literal">SessionFactory</code> e <code class="literal">Session</code>, além de transações de base de dados e conversações longas.  </p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>13.1. Sessão e escopos de transações</h2></div></div></div><p>Um <code class="literal">SessionFactory</code> é objeto threadsafe com um custo alto de criação, compartilhado por todas as threads da aplicação. É criado uma única vez, no início da execução da aplicação, a partir da instância de uma <code class="literal">Configuration</code>.  </p><p>Uma <code class="literal">Session</code> é um objeto de baixo custo de criação, não é threadsafe, deve ser usado uma vez, para uma única requisição, uma conversação, uma única unidade do trabalho e então deve ser descartado. Um <code class="literal">Session</code> não obterá um JDBC <code class="literal">Connection</code>, ou um <code class="literal">Datasource</code>, a menos que necessite. Isto não consome nenhum recurso até ser usado. </p><p>Uma transação precisa ser o mais curta possível, para reduzir a disputa pelo bloqueio na base de dados. Transações longas impedirão que sua aplicação escale a carga altamente concorrente. Por isso, não é bom manter uma transação de base de dados aberta durante o tempo que o usuário pensa, até que a unidade do trabalho esteja completa. </p><p>Qual é o escopo de uma unidade de trabalho? Pode uma única <code class="literal">Session</code> do Hibernate gerenciar diversas transações ou este é um o relacionamento um-para-um dos escopos? Quando você deve abrir e fechar uma <code class="literal">Session</code> e como você demarca os limites da transação? Estas questões estão endereçadas nas seguintes seções. </p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>13.1.1. Unidade de trabalho</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as “<span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span>”[<a class="citation" href="bi01.html#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a class="xref" href="transactions.html#transactions-basics-apptx" title="13.1.2. Longas conversações">Seção 13.1.2, “Longas conversações”</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>Primeiro, não use o antipattern <span class="emphasis"><em>sessão-por-operação</em></span>: isto é, não abra e feche uma <code class="literal">Session</code> para cada simples chamada ao banco de dados em uma única thread. Naturalmente, o mesmo se aplica às transações do banco de dados. As chamadas ao banco de dados em uma aplicação são feitas usando uma seqüência planejada, elas são agrupadas em unidades de trabalho atômicas. Veja que isso também significa que realizar um auto-commit depois de cada instrução SQL é inútil em uma aplicação, esta modalidade é ideal para o trabalho ad hoc do console do SQL. O Hibernate impede, ou espera que o servidor de aplicação impessa isso, aplique a modalidade auto-commit imediatamente. As transações de banco de dados nunca são opcionais, toda a comunicação com um banco de dados tem que ocorrer dentro de uma transação, não importa se você vai ler ou escrever dados. Como explicado, o comportamento auto-commit para leitura de dados deve ser evitado, uma vez que muitas transações pequenas são improváveis de executar melhor do que uma unidade de trabalho claramente definida. A última opção é também muito mais sustentável e expandida. </p><p>O modelo mais comum em uma aplicação de cliente/servidor multi-usuário  é <span class="emphasis"><em>sessão-por-requisição</em></span>. Neste modelo, uma requisição do cliente é enviada ao servidor, onde a camada de persistência do Hibernate é executada. Uma <code class="literal">Session</code> nova do Hibernate é aberta, e todas as operações da base de dados são executadas nesta unidade do trabalho. Logo que o trabalho for completado, e a resposta para o cliente for preparada, a sessão é descarregada e fechada. Você usaria também uma única transação de base de dados para servir às requisições dos clientes, iniciando e submetendo-o ao abrir e fechar da <code class="literal">Session</code>. O relacionamento entre os dois é um-para-um e este modelo é um ajuste perfeito para muitas aplicações. </p><p>O desafio encontra-se na implementação. O Hibernate fornece gerenciamento integrado da "sessão atual" para simplificar este modelo. Tudo que você tem a fazer é iniciar uma transação quando uma requisição precisa ser processada e terminar a transação antes que a resposta seja enviada ao cliente. Você pode fazer onde quiser, soluções comuns são <code class="literal">ServletFilter</code>, interceptador AOP com um pointcut (ponto de corte) nos métodos de serviço ou em um recipiente de proxy/interceptação. Um recipiente de EJB é uma maneira padronizada de implementar aspectos cross-cutting, tais como a demarcação da transação em beans de sessão EJB, declarativamente com CMT. Se você se decidir usar demarcação programática de transação, dê preferência à API <code class="literal">Transaction</code> do Hibernate mostrada mais adiante neste capítulo, para facilidade no uso e portabilidade de código.  </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sessões Contextuais">Seção 2.3, “Sessões Contextuais”</a>. </p><p>Ás vezes, é conveniente estender o escopo de uma <code class="literal">Session</code> e de uma transação do banco de dados até que a "visão esteja renderizada". É especialmente útil em aplicações servlet que utilizam uma fase de renderização separada depois da requisição ter sido processada. Estender a transação até que a renderização da visão esteja completa é fácil de fazer se você implementar seu próprio interceptador. Entretanto, não será fácil se você confiar em EJBs com transações gerenciadas por recipiente, porque uma transação será terminada quando um método de EJB retornar, antes que a renderização de toda visão possa começar. Veja o website e o fórum do Hibernate para dicas e exemplos em torno deste modelo de <span class="emphasis"><em>Sessão Aberta na Visualização</em></span>. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>13.1.2. Longas conversações</h3></div></div></div><p>O modelo sessão-por-requisição não é o único conceito útil que você pode usar ao projetar unidades de trabalho. Muitos processos de negócio requerem uma totalidade de séries de interações com o usuário, intercaladas com acessos a uma base de dados. Em aplicações da web e corporativas não é aceitável que uma transação atrapalhe uma interação do usuário. Considere o seguinte exemplo: </p><div class="itemizedlist"><ul><li><p>A primeira tela de um diálogo se abre e os dados vistos pelo usuário são carregados em uma <code class="literal">Session</code> e transação de banco de dados particulares. O usuário está livre para modificar os objetos.  </p></li><li><p>O usuário clica em "Salvar" após 5 minutos e espera suas modificações serem persistidas. O usuário também espera que ele seja a única pessoa que edita esta informação e que nenhuma modificação conflitante possa ocorrer. </p></li></ul></div><p>Nós chamamos esta unidade de trabalho, do ponto da visão do usuário, uma <span class="emphasis"><em>conversação</em></span> de longa duração (ou <span class="emphasis"><em>transação da aplicação</em></span>). Há muitas maneiras de você implementar em sua aplicação.  </p><p>Uma primeira implementação simples pode manter a <code class="literal">Session</code> e a transação aberta durante o tempo de interação do usuário, com bloqueios na base de dados para impedir a modificação concorrente e para garantir o isolamento e a atomicidade. Esse é naturalmente um anti-pattern, uma vez que a disputa do bloqueio não permitiria o escalonameneto da aplicação com o número de usuários concorrentes. </p><p>Claramente, temos que usar diversas transações para implementar a conversação. Neste caso, manter o isolamento dos processos de negócio, torna-se responsabilidade parcial da camada da aplicação. Uma única conversação geralmente usa diversas transações. Ela será atômica se somente uma destas transações (a última) armazenar os dados atualizados, todas as outras simplesmente leram os dados (por exemplo em um diálogo do estilo wizard que mede diversos ciclos de requisição/resposta). Isto é mais fácil de implementar do parece, especialmente se você usar as características do Hibernate:  </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Versionamento automático</em></span>: o Hibernate pode fazer o controle automático de concorrência otimista para você, ele pode automaticamente detectar se uma modificação concorrente ocorreu durante o tempo de interação do usuário. Geralmente nós verificamos somente no fim da conversação.  </p></li><li><p><span class="emphasis"><em>Objetos Desanexados</em></span>: se você se decidir usar o já discutido pattern <span class="emphasis"><em>sessão-por-solicitação</em></span>, todas as instâncias carregadas estarão no estado destacado durante o tempo em que o usuário estiver pensando. O Hibernate permite que você re-anexe os objetos e persista as modificações, esse pattern é chamado <span class="emphasis"><em>sessão-por-solicitação-com-objetos-desanexados</em></span>. Utiliza-se versionamento automático para isolar as modificações concorrentes. </p></li><li><p><span class="emphasis"><em>Sessão Estendida (ou Longa)</em></span> A <code class="literal">Session</code> do Hibernate pode ser desligada da conexão adjacente do JDBC depois que a transação foi submetida, e ser reconectada quando uma nova requisição do cliente ocorrer. Este pattern é conhecido como <span class="emphasis"><em>sessão-por-conversação</em></span> e faz o reatamento uniforme desnecessário. Versionamento automático é usado para isolar modificações concorrentes e a <span class="emphasis"><em>sessão-por-conversação</em></span> geralmente pode ser nivelada automaticamente, e sim explicitamente.  </p></li></ul></div><p>Tanto a <span class="emphasis"><em>sessão-por-solicitação-com-objetos-desanexados</em></span> quanto a <span class="emphasis"><em>sessão-por-conversação</em></span> possuem vantagens e desvantagens. Estas desvantagens serão discutidas mais tarde neste capítulo no contexto do controle de concorrência otimista.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>13.1.3. Considerando a identidade do objeto</h3></div></div></div><p>Uma aplicação pode acessar concorrentemente o mesmo estado persistente em duas <code class="literal">Session</code>s diferentes. Entretanto, uma instância de uma classe persistente nunca é compartilhada entre duas instâncias <code class="literal">Session</code>. Portanto, há duas noções diferentes da identidade:   </p><div class="variablelist"><dl><dt><span class="term">Identidade da base de dados</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">Identidade da JVM</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>Então para os objetos acoplados a uma <code class="literal">Session</code> <span class="emphasis"><em>específica</em></span> (ex.: isto está no escopo de uma <code class="literal">Session</code>), as duas noções são equivalentes e a identidade da JVM para a identidade da base de dados é garantida pelo Hibernate. Entretanto, embora a aplicação possa acessar concorrentemente o "mesmo" objeto do negócio (identidade persistente) em duas sessões diferentes, as duas instâncias serão realmente "diferentes" (identidade de JVM). Os conflitos são resolvidos usando (versionamento automático) no flush/commit, usando uma abordagem otimista. </p><p>Este caminho deixa o Hibernate e o banco de dados se preocuparem com a concorrência. Ele também fornece uma escalabilidade melhor, garantindo que a identidade em unidades de trabalho single-threaded não necessite de bloqueio dispendioso ou de outros meios de sincronização. A aplicação nunca necessita sincronizar qualquer objeto de negócio tão longo que transpasse uma única thread por <code class="literal">Session</code>. Dentro de uma <code class="literal">Session</code> a aplicação pode usar com segurança o <code class="literal">==</code> para comparar objetos.  </p><p>No entanto, uma aplicação que usa <code class="literal">==</code> fora de uma <code class="literal">Session</code>, pode ver resultados inesperados. Isto pode ocorrer mesmo em alguns lugares inesperados, por exemplo, se você colocar duas instâncias desacopladas em um mesmo <code class="literal">Set</code>. Ambas podem ter a mesma identidade na base de dados (ex.: elas representam a mesma linha), mas a identidade da JVM não é, por definição, garantida para instâncias em estado desacoplado. O desenvolvedor tem que substituir os métodos <code class="literal">equals()</code> e <code class="literal">hashCode()</code> em classes persistentes e implementar sua própria noção da igualdade do objeto. Advertência: nunca use o identificador da base de dados para implementar a igualdade, use atributos de negócio, uma combinação única, geralmente imutável. O identificador da base de dados mudará se um objeto transiente passar para o estado persistente. Se a instância transiente (geralmente junto com instâncias desacopladas) for inserida em um <code class="literal">Set</code>, a mudança do hashcode quebrará o contrato do <code class="literal">Set</code>. As funções para chaves de negócio não têm que ser tão estável quanto às chaves primárias da base de dados, você somente tem que garantir a estabilidade durante o tempo que os objetos estiverem no mesmo <code class="literal">Set</code>. Veja o website do Hibernate para uma discussão mais completa sobre o assunto. Note também que esta não é uma característica do Hibernate, mas simplesmente a maneira como a identidade e a igualdade do objeto de Java têm que ser implementadas.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>13.1.4. Edições comuns</h3></div></div></div><p>Nunca use o anti-patterns <span class="emphasis"><em>sessão-por-usuário-sessão</em></span> ou <span class="emphasis"><em>sessão-por-aplicação</em></span> (naturalmente, existem exceções raras para essa regra). Note que algumas das seguintes edições podem também aparecer com modelos recomendados, certifique-se que tenha compreendido as implicações antes de fazer uma decisão de projeto:  </p><div class="itemizedlist"><ul><li><p>Uma <code class="literal">Session</code> não é threadsafe. As coisas que são supostas para trabalhar concorrentemente, como requisições HTTP, beans de sessão, ou Swing, causarão condições de disputa se uma instância <code class="literal">Session</code> for compartilhada. Se você mantiver sua <code class="literal">Session</code> do Hibernate em seu <code class="literal">HttpSession</code> (discutido mais tarde), você deverá considerar sincronizar o acesso a sua sessão do HTTP. Caso contrário, um usuário que clica em recarga rápido demais, pode usar o mesmo <code class="literal">Session</code> em duas threads executando simultaneamente.  </p></li><li><p>Uma exceção lançada pelo Hibernate significa que você tem que dar rollback na sua transação no banco de dados e fechar a <code class="literal">Session</code> imediatamente (discutido mais tarde em maiores detalhes). Se sua <code class="literal">Session</code> é limitada pela aplicação, você tem que parar a aplicação. Fazer o rollback na transação no banco de dados não retorna seus objetos do negócio ao estado que estavam no início da transação. Isto significa que o estado da base de dados e os objetos de negócio perdem a sincronização. Geralmente, não é um problema porque as exceções não são recuperáveis e você tem que iniciar após o rollback de qualquer maneira.  </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a class="xref" href="batch.html" title="Capítulo 15. Batch processing">Capítulo 15, <i>Batch processing</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>13.2. Demarcação de transações de bancos de dados</h2></div></div></div><p>Os limites de uma transação de banco de dados, ou sistema, são sempre necessários. Nenhuma comunicação com o banco de dados pode ocorrer fora de uma transação de banco de dados (isto parece confundir muitos desenvolvedores que estão acostumados ao modo auto-commit). Sempre use os limites desobstruídos da transação, até mesmo para operações somente leitura. Dependendo de seu nível de isolamento e capacidade da base de dados isto pode não ser requerido, mas não há nenhum aspecto negativo se você sempre demarcar transações explicitamente. Certamente, uma única transação será melhor executada do que muitas transações pequenas, até mesmo para dados de leitura.  </p><p>Uma aplicação do Hibernate pode funcionar em ambientes não gerenciados (isto é, aplicações standalone, Web simples ou Swing) e ambientes gerenciados J2EE. Em um ambiente não gerenciado, o Hibernate é geralmente responsável pelo seu próprio pool de conexões. O desenvolvedor, precisa ajustar manualmente os limites das transaçãos, ou seja, começar, submeter ou efetar rollback nas transações ele mesmo. Um ambiente gerenciado fornece transações gerenciadas por recipiente (CMT), com um conjunto da transações definido declarativamente em descritores de implementação de beans de sessão EJB, por exemplo. A demarcação programática é portanto, não mais necessária. </p><p>Entretanto, é freqüentemente desejável manter sua camada de persistência portável entre ambientes de recurso locais não gerenciados e sistemas que podem confiar em JTA, mas use BMT ao invés de CMT. Em ambos os casos você usaria demarcação de transação programática. O Hibernate oferece uma API chamada Transaction que traduz dentro do sistema de transação nativa de seu ambiente de implementação. Esta API é realmente opcional, mas nós encorajamos fortemente seu uso a menos que você esteja em um bean de sessão CMT.   </p><p>Geralmente, finalizar uma <code class="literal">Session</code> envolve quatro fases distintas: </p><div class="itemizedlist"><ul compact="compact"><li><p>liberar a sessão </p></li><li><p>submeter a transação </p></li><li><p>fechar a sessão </p></li><li><p>tratar as exceções </p></li></ul></div><p>A liberação da sessão já foi bem discutida, agora nós daremos uma olhada na demarcação da transação e na manipulação de exceção em ambientes controlados e não controlados.  </p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>13.2.1. Ambiente não gerenciado</h3></div></div></div><p>Se uma camada de persistência do Hibernate roda em um ambiente não gerenciado, as conexões do banco de dados são geralmente tratadas pelos pools de conexões simples (ex.: não DataSource) dos quais o Hibernate obtém as conexões assim que necessitar. A maneira de se manipular uma sessão/transação é mais ou menos assim: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Você não pode chamar <code class="literal">flush()</code> da <code class="literal">Session()</code> explicitamente. A chamada ao <code class="literal">commit()</code> dispara automaticamente a sincronização para a sessão, dependendo do <a class="xref" href="objectstate.html#objectstate-flushing" title="11.10. Limpando a Sessão">Seção 11.10, “Limpando a Sessão”</a>. Uma chamada ao <code class="literal">close()</code> marca o fim de uma sessão. A principal implicação do <code class="literal">close()</code> é que a conexão JDBC será abandonada pela sessão. Este código Java é portável e funciona em ambientes não gerenciados e de JTA.   </p><p>Uma solução muito mais flexível é o gerenciamento de contexto "sessão atual" da construção interna do Hibernate, como descrito anteriormente:  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Você muito provavelmente nunca verá estes fragmentos de código em uma aplicação regular; as exceções fatais (do sistema) devem sempre ser pegas no "topo". Ou seja, o código que executa chamadas do Hibernate (na camada de persistência) e o código que trata <code class="literal">RuntimeException</code> (e geralmente pode somente limpar acima e na saída) estão em camadas diferentes. O gerenciamento do contexto atual feito pelo Hibernate pode significativamente simplificar este projeto, como tudo que você necessita é do acesso a um <code class="literal">SessionFactory</code>. A manipulação de exceção é discutida mais tarde neste capítulo.  </p><p>Note que você deve selecionar <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code>, que é o padrão, e para o segundo exemplo <code class="literal">"thread"</code> como seu <code class="literal">hibernate.current_session_context_class</code>. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>13.2.2. Usando JTA</h3></div></div></div><p>Se sua camada de persistência funcionar em um servidor de aplicação (por exemplo, dentro dos beans de sessão EJB), cada conexão da fonte de dados obtida pelo Hibernate automaticamente fará parte da transação global de JTA. Você pode também instalar uma implementação standalone de JTA e usá-la sem EJB. O Hibernate oferece duas estratégias para a integração de JTA.  </p><p>Se você usar transações de bean gerenciado (BMT) o Hibernate dirá ao servidor de aplicação para começar e para terminar uma transação de BMT se você usar a <code class="literal">Transaction</code> API. Assim, o código de gerência de transação é idêntico ao ambiente não gerenciado. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Se você quiser usar uma <code class="literal">Session</code> limitada por transação, isto é, a funcionalidade do <code class="literal">getCurrentSession()</code> para a propagação fácil do contexto, você terá que usar diretamente a API JTA <code class="literal">UserTransaction</code>:  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">UserTransaction</span><span class="java_separator">)</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;java:comp/UserTransaction&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Do</span><span class="java_plain">&nbsp;some&nbsp;work&nbsp;on&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;bound&nbsp;to&nbsp;transaction</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">load</span><span class="java_separator">(...);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">persist</span><span class="java_separator">(...);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Com CMT, a demarcação da transação é feita em descritores de implementação de beans de sessão, não programaticamente, conseqüentemente, o código é reduzido a:  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;CMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</pre><p>Em um CMT/EJB, até mesmo um rollback acontece automaticamente, desde que uma exceção <code class="literal">RuntimeException</code> não tratável seja lançada por um método de um bean de sessão que informa ao recipiente ajustar a transação global ao rollback. <span class="emphasis"><em>Isto significa que você não precisa mesmo usar a API <code class="literal">Transaction</code> do Hibernate com BMT ou CMT e você obterá a propagação automática da Sessão "atual" limitada à transação.</em></span>  </p><p>Veja que você deverá escolher <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> se você usar o JTA diretamente (BMT) e <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> em um bean de sessão CMT, quando você configura a fábrica de transação do Hibernate. Lembre-se também de configurar o <code class="literal">hibernate.transaction.manager_lookup_class</code>. Além disso, certifique-se que seu <code class="literal">hibernate.current_session_context_class</code> ou não é configurado (compatibilidade com o legado) ou está definido para <code class="literal">"jta"</code>.  </p><p>A operação <code class="literal">getCurrentSession()</code> tem um aspecto negativo em um ambiente JTA. Há uma advertência para o uso do método liberado de conexão <code class="literal">after_statement</code>, o qual é usado então por padrão. Devido a uma limitação simples da especificação JTA, não é possível para o Hibernate automaticamente limpar quaisquer instâncias <code class="literal">ScrollableResults</code> ou <code class="literal">Iterator</code> abertas retornadas pelo <code class="literal">scroll()</code> ou <code class="literal">iterate()</code>. Você <span class="emphasis"><em>deve</em></span> liberar o cursor subjacente da base de dados chamando <code class="literal">ScrollableResults.close()</code> ou <code class="literal">Hibernate.close(Iterator)</code> explicitamente de um bloco <code class="literal">finally</code>. Claro que a maioria das aplicações podem facilmente evitar o uso do <code class="literal">scroll()</code> ou do <code class="literal">iterate()</code> em todo código provindo do JTA ou do CMT. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>13.2.3. Tratamento de Exceção</h3></div></div></div><p>Se a <code class="literal">Session</code> levantar uma exceção, incluindo qualquer <code class="literal">SQLException</code>, você deverá imediatamente dar um rollback na transação do banco, chamando <code class="literal">Session.close()</code> e descartando a instância da <code class="literal">Session</code>. Certos métodos da <code class="literal">Session</code><code class="literal">não</code> deixarão a sessão em um estado inconsistente. Nenhuma exceção lançada pelo Hibernate pode ser recuperada. Certifique-se que a <code class="literal">Session</code> será fechada chamando <code class="literal">close()</code> no bloco <code class="literal">finally</code>.  </p><p>A exceção <code class="literal">HibernateException</code>, a qual envolve a maioria dos erros que podem ocorrer em uma camada de persistência do Hibernate, é uma exceção não verificada. Ela não constava em versões mais antigas de Hibernate. Em nossa opinião, nós não devemos forçar o desenvolvedor a tratar uma exceção irrecuperável em uma camada mais baixa. Na maioria dos sistemas, as exceções não verificadas e fatais são tratadas em um dos primeiros frames da pilha da chamada do método (isto é, em umas camadas mais elevadas) e uma mensagem de erro é apresentada ao usuário da aplicação (ou alguma outra ação apropriada é feita). Note que Hibernate pode também lançar outras exceções não verificadas que não sejam um <code class="literal">HibernateException</code>. Estas, também são, irrecuperáveis e uma ação apropriada deve ser tomada.  </p><p>O Hibernate envolve <code class="literal">SQLException</code>s lançadas ao interagir com a base de dados em um <code class="literal">JDBCException</code>. Na realidade, o Hibernate tentará converter a exceção em uma subclasse mais significativa da <code class="literal">JDBCException</code>. A <code class="literal">SQLException</code> subjacente está sempre disponível através de <code class="literal">JDBCException.getCause()</code>. O Hibernate converte a <code class="literal">SQLException</code> em uma subclasse <code class="literal">JDBCException</code> apropriada usando <code class="literal">SQLExceptionConverter</code> associado ao <code class="literal">SessionFactory</code>. Por padrão, o <code class="literal">SQLExceptionConverter</code> é definido pelo dialeto configurado. Entretanto, é também possível conectar em uma implementação customizada. Veja o javadoc para mais detalhes da classe <code class="literal">SQLExceptionConverterFactory</code>. Os subtipos padrão de <code class="literal">JDBCException</code> são:  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code>: indica um erro com a comunicação subjacente de JDBC. </p></li><li><p><code class="literal">SQLGrammarException</code>: indica um problema da gramática ou da sintáxe com o SQL emitido. </p></li><li><p><code class="literal">ConstraintViolationException</code>: indica algum forma de violação de confinamento de integridade. </p></li><li><p><code class="literal">LockAcquisitionException</code>: indica um erro ao adquirir um nível de bloqueio necessário para realizar a operação de requisição. </p></li><li><p><code class="literal">GenericJDBCException</code>: uma exceção genérica que não está inclusa em nenhuma das outras categorias. </p></li></ul></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>13.2.4. Tempo de espera de Transação</h3></div></div></div><p>O tempo de espera de transação é uma característica extremamente importante fornecida por um ambiente gerenciado como EJB e que nunca é fornecido pelo código não gerenciado. Os tempos de espera de transação asseguram que nenhuma transação retenha indefinidamente recursos enquanto não retornar nenhuma resposta ao usuário. Fora de um ambiente controlado (JTA), o Hibernate não pode fornecer inteiramente esta funcionalidade. Entretanto, o Hibernate pode afinal controlar as operações do acesso a dados, assegurando que o nível de deadlocks e consultas do banco de dados com imensos resultados definidos sejam limitados pelo tempo de espera. Em um ambiente gerenciado, o Hibernate pode delegar o tempo de espera da transação ao JTA. Esta funcionalidade é abstraída pelo objeto <code class="literal">Transaction</code> do Hibernate.  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">set&nbsp;transaction&nbsp;timeout&nbsp;to&nbsp;</span><span class="java_literal">3</span><span class="java_plain">&nbsp;seconds</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">setTimeout</span><span class="java_separator">(</span><span class="java_literal">3</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Veja que <code class="literal">setTimeout()</code> não pode ser chamado em um bean CMT, onde o tempo de espera das transações deve ser definido declaradamente.  </p></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>13.3. Controle de concorrência otimista</h2></div></div></div><p>O único caminho que é consistente com a elevada concorrência e escalabilidade é o controle de concorrência otimista com versionamento. A checagem de versão usa número de versão, ou carimbo de hora (timestamp), para detectar conflitos de atualizações (e para impedir atualizações perdidas). O Hibernate fornece três caminhos possíveis para escrever aplicações que usam concorrência otimista. Os casos de uso que nós mostramos estão no contexto de conversações longas, mas a checagem de versão também tem o benefício de impedir atualizações perdidas em únicas transações.  </p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>13.3.1. Checagem de versão da aplicação</h3></div></div></div><p>Em uma implementação sem muita ajuda do Hibernate, cada interação com o banco de dados ocorre em uma nova <code class="literal">Session</code> e o desenvolvedor é responsável por recarregar todas as instâncias persistentes da base de dados antes de manipulá-las. Este caminho força a aplicação a realizar sua própria checagem de versão para assegurar a conversação do isolamento da transação. Este caminho é menos eficiente em termos de acesso ao banco de dados. É o caminho mais similar à entidade EJBs. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">int</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">,</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getKey</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;load&nbsp;the&nbsp;current&nbsp;state</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StaleObjectStateException</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>A propriedade <code class="literal">version</code> é mapeada usando <code class="literal">&lt;version&gt;</code>, e o Hibernate vai incrementá-lá automaticamente durante a liberação se a entidade estiver alterada. </p><p>Claro, se você estiver operando em um ambiente de baixa concorrência de dados e não precisar da checagem de versão, você pode usar este caminho e apenas pular a checagem de versão. Nesse caso, o <span class="emphasis"><em>último commit realizado</em></span> é a estratégia padrão para suas conversações longas. Tenha em mente que isto pode confundir os usuários da aplicação, como também poderão ter atualizações perdidas sem mensagens de erro ou uma possibilidade de ajustar mudanças conflitantes. </p><p>Claro que, a checagem manual da versão é somente possível em circunstâncias triviais e não para a maioria de aplicações. Freqüentemente, os gráficoscompletos de objetos modificados têm que ser verificados, não somente únicas instâncias. O Hibernate oferece checagem de versão automática com uma <code class="literal">Session</code> estendida ou instâncias desatachadas como o paradigma do projeto.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>13.3.2. Sessão estendida e versionamento automático</h3></div></div></div><p>Uma única instância de <code class="literal">Session</code> e suas instâncias persistentes são usadas para a conversação inteira, isto é conhecido como <span class="emphasis"><em>sessão-por-conversação</em></span>. O Hibernate verifica versões da instância no momento da liberação, lançando uma exceção se a modificação concorrente for detectada. Até o desenvolvedor pegar e tratar essa exceção. As opções comuns são a oportunidade para que o usuário intercale as mudanças ou reinicie a conversação do negócio com dados não antigos. </p><p>A <code class="literal">Session</code> é desconectada de toda a conexão JDBC adjacente enquanto espera a interação do usuário. Este caminho é o mais eficiente em termos de acesso a bancos de dados. A aplicação não precisa se preocupar com a checagem de versão ou com as instâncias destacadas reatadas, nem precisa recarregar instâncias a cada transação. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;earlier&nbsp;by&nbsp;the&nbsp;old&nbsp;session</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Obtain</span><span class="java_plain">&nbsp;a&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;start&nbsp;transaction</span>
</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Also</span><span class="java_plain">&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span></pre><p>O objeto <code class="literal">foo</code> sabe que a <code class="literal">Session</code> já foi carregada. Ao começar uma nova transação ou uma sessão velha, você obterá uma conexão nova e reiniciará a sessão. Submeter uma transação implica em desconectar uma sessão da conexão JDBC e retornar à conexão ao pool. Após a reconexão, para forçar uma checagem de versão em dados que você não esteja atualizando, você poderá chamar <code class="literal">Session.lock()</code> com o <code class="literal">LockMode.READ</code> em todos os objetos que possam ter sido atualizados por uma outra transação. Você não precisa bloquear nenhum dado que você <span class="emphasis"><em>está</em></span> atualizando. Geralmente, você configuraria <code class="literal">FlushMode.NEVER</code> em uma <code class="literal">Session</code> estendida, de modo que somente o último ciclo da transação tenha permissão de persistir todas as modificações feitas nesta conversação. Por isso, somente esta última transação incluiria a operação <code class="literal">flush()</code> e então também iria <code class="literal">close()</code> a sessão para terminar a conversação.  </p><p>Este modelo é problemático se a <code class="literal">Session</code> for demasiadamente grande para ser armazenada durante o tempo de espera do usuário (por exemplo uma <code class="literal">HttpSession</code> deve ser mantida o menor possível). Como a <code class="literal">Session</code> é também cache de primeiro nível (imperativo) e contém todos os objetos carregados, nós podemos provavelmente usar esta estratégia somente para alguns ciclos de requisição/resposta. Você deve usar a <code class="literal">Session</code> somente para uma única conversação, porque ela logo também estará com dados velhos.  </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>Note que versões mais atuais de Hibernate requerem a desconexão e reconexão explícitas de uma <code class="literal">Session</code>. Estes métodos são desatualizados, pois o início e término de uma transação têm o mesmo efeito. </p></div><p>Note também que você deve manter a <code class="literal">Session</code> desconectada, fechada para a camada de persistência. Ou seja, use um bean de sessão com estado EJB para prender a <code class="literal">Session</code> em um ambiente de três camadas. Não transfira à camada web, ou até serializá-lo para uma camada separada, para armazená-lo no <code class="literal">HttpSession</code>. </p><p>O modelo da sessão estendida, ou <span class="emphasis"><em>sessão-por-conversação</em></span>, é mais difícil de implementar com gerenciamento automático de sessão atual. Você precisa fornecer sua própria implementação do <code class="literal">CurrentSessionContext</code> para isto. Veja o Hibernate Wiki para exemplos. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>13.3.3. Objetos destacados e versionamento automático</h3></div></div></div><p>Cada interação com o armazenamento persistente ocorre em uma <code class="literal">Session</code> nova. Entretanto, as mesmas instâncias persistentes são reusadas para cada interação com o banco de dados. A aplicação manipula o estado das instâncias desatachadas originalmente carregadas em uma outra <code class="literal">Session</code> e as reata então usando <code class="literal">Session.update()</code>, <code class="literal">Session.saveOrUpdate()</code> ou <code class="literal">Session.merge()</code>. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">saveOrUpdate</span><span class="java_separator">(</span><span class="java_plain">foo</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Use</span><span class="java_plain">&nbsp;merge</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;foo&quot;</span><span class="java_plain">&nbsp;might&nbsp;have&nbsp;been&nbsp;loaded&nbsp;already</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>Outra vez, o Hibernate verificará versões da instância durante a liberação, lançando uma exceção se ocorrer conflitos de atualizações.  </p><p>Você pode também chamar o <code class="literal">lock()</code> em vez de <code class="literal">update()</code> e usar <code class="literal">LockMode.READ</code> (executando uma checagem de versão, ignorando todos os caches) se você estiver certo de que o objeto não foi modificado.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>13.3.4. Versionamento automático customizado</h3></div></div></div><p>Você pode desabilitar o incremento da versão automática de Hibernate para propriedades e coleções particulares, configurando a função de mapeamento <code class="literal">optimistic-lock</code> para <code class="literal">false</code>. O Hibernate então, não incrementará mais versões se a propriedade estiver modificada.  </p><p>Os esquemas da base de dados legado são freqüentemente estáticos e não podem ser modificados. Ou então, outras aplicações puderam também acessar a mesma base de dados e não sabem tratar a versão dos números ou carimbos de hora. Em ambos os casos, o versionamento não pode confiar em uma coluna particular em uma tabela. Para forçar uma checagem de versão sem uma versão ou mapeamento da propriedade do carimbo de hora com uma comparação do estado de todos os campos em uma linha, configure <code class="literal">optimistic-lock="all"</code> no mapeamento <code class="literal">&lt;class&gt;</code>. Note que isto conceitualmente é somente feito em trabalhos se o Hibernate puder comparar o estado velho e novo (ex.: se você usar uma única <code class="literal">Session</code> longa e não uma sessão-por-solicitação-com-objetos-desanexados). </p><p>Às vezes a modificação concorrente pode ser permitida, desde que as mudanças realizadas não se sobreponham. Se você configurar <code class="literal">optimistic-lock="dirty"</code> ao mapear o <code class="literal">&lt;class&gt;</code>, o Hibernate comparará somente campos modificados durante a liberação.  </p><p>Em ambos os casos, com as colunas de versão/carimbo de hora dedicados com comparação de campo cheio/sujo, o Hibernate usa uma única instrução <code class="literal">UPDATE</code>, com uma cláusula <code class="literal">WHERE</code> apropriada, por entidade para executar a checagem da versão e atualizar a informação. Se você usar a persistência transitiva para cascatear o reatamento das entidades associadas, o Hibernate pode executar atualizações desnecessárias. Isso não é geralmente um problema, mas os triggers <span class="emphasis"><em>em atualizações</em></span> num banco de dados pode ser executado mesmo quando nenhuma mudança foi feita nas instâncias desanexadas. Você pode customizar este comportamento configurando <code class="literal">selecionar-antes-de atualizar="verdadeiro"</code> no mapeamento <code class="literal">&lt;class&gt;</code>, forçando o Hibernate a fazer um <code class="literal">SELECT</code> nas instâncias para assegurar-se de que as mudanças realmente aconteceram, antes de atualizar a linha.  </p></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>13.4. Bloqueio Pessimista </h2></div></div></div><p>Não ha intenção alguma que usuários gastem muitas horas se preocupando com suas estratégias de bloqueio. Geralmente, é o bastante especificar um nível de isolamento para as conexões JDBC e então deixar simplesmente o banco de dados fazer todo o trabalho. Entretanto, os usuários avançados podem às vezes desejar obter bloqueios pessimistas exclusivos, ou re-obter bloqueios no início de uma nova transação.  </p><p>O Hibernate usará sempre o mecanismo de bloqueio da base de dados, nunca bloquiar objetos na memória. </p><p>A classe <code class="literal">LockMode</code> define os diferentes níveis de bloqueio que o Hibernate pode adquirir. Um bloqueio é obtido pelos seguintes mecanismos:  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode.WRITE</code> é adquirido automaticamente quando o Hibernate atualiza ou insere uma linha. </p></li><li><p><code class="literal">LockMode.UPGRADE</code> pode ser adquirido explicitamente pelo usuário usando <code class="literal">SELECT ... FOR UPDATE</code> em um banco de dados que suporte essa sintáxe.  </p></li><li><p><code class="literal">LockMode.UPGRADE_NOWAIT</code> pode ser adquirido explicitamente pelo usuário usando <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> no Oracle.  </p></li><li><p><code class="literal">LockMode.READ</code> é adquirido automaticamente quando o Hibernate lê dados em um nível de Leitura Repetida ou isolamento Serializável. Pode ser readquirido explicitamente pelo usuário.  </p></li><li><p><code class="literal">LockMode.NONE</code> representa a ausência do bloqueio. Todos os objetos mudam para esse estado de bloqueio no final da <code class="literal">Transaction</code>. Objetos associados com a sessão através do método <code class="literal">update()</code> ou <code class="literal">saveOrUpdate()</code> também são inicializados com esse modo de bloqueio. </p></li></ul></div><p>O bloqueio obtido "explicitamente pelo usuário" se dá nas seguintes formas: </p><div class="itemizedlist"><ul compact="compact"><li><p>Uma chamada a <code class="literal">Session.load()</code>, especificando o <code class="literal">LockMode</code>. </p></li><li><p>Uma chamada à <code class="literal">Session.lock()</code>. </p></li><li><p>Uma chamada à <code class="literal">Query.setLockMode()</code>. </p></li></ul></div><p>Se uma <code class="literal">Session.load()</code> é invocada com <code class="literal">UPGRADE</code> ou <code class="literal">UPGRADE_NOWAIT</code>, e o objeto requisitado ainda não foi carregado pela sessão, o objeto é carregado usando <code class="literal">SELECT ... FOR UPDATE</code>. Se <code class="literal">load()</code> for chamado para um objeto que já foi carregado com um bloqueio menos restritivo que o novo bloqueio solicitado, o Hibernate invoca o método <code class="literal">lock()</code> para aquele objeto. </p><p>O <code class="literal">Session.lock()</code> executa uma verificação no número da versão se o modo de bloqueio especificado for <code class="literal">READ</code>, <code class="literal">UPGRADE</code> ou <code class="literal">UPGRADE_NOWAIT</code>. No caso do <code class="literal">UPGRADE</code> ou <code class="literal">UPGRADE_NOWAIT</code>, é usado <code class="literal">SELECT ... FOR UPDATE</code>. </p><p>Se o banco de dados não suportar o modo de bloqueio solicitado, o Hibernate usará um modo alternativo apropriado, ao invés de lançar uma exceção. Isso garante que a aplicação seja portátil.  </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>13.5. Modos para liberar a conexão</h2></div></div></div><p>O comportamento legado do Hibernate 2.x referente ao gerenciamento da conexão via JDBC era que a <code class="literal">Session</code> precisaria obter uma conexão quando ela precisasse pela primeira vez e depois manteria a conexão enquanto a sessão não fosse fechada. O Hibernate 3.x introduz a idéia de modos para liberar a sessão, para informar a sessão a forma como deve manusear a sua conexão JDBC. Veja que essa discussão só é pertinente para conexões fornecidas com um <code class="literal">ConnectionProvider</code> configurado. As conexões fornecidas pelo usuário estão fora do escopo dessa discussão. Os diferentes modos de liberação estão definidos pelos valores da enumeração <code class="literal">org.hibernate.ConnectionReleaseMode</code>: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code>: é o modo legado descrito acima. A sessão do Hibernate obtém a conexão quando precisar executar alguma operação JDBC pela primeira vez e mantém enquanto a conexão não for fechada. </p></li><li><p><code class="literal">AFTER_TRANSACTION</code>: informa que a conexão deve ser liberada após a conclusão de uma <code class="literal">org.hibernate.Transaction</code>.  </p></li><li><p><code class="literal">AFTER_STATEMENT</code> (também conhecida como liberação agressiva): informa que a conexão deve ser liberada após a execução de cada instrução. A liberação agressiva não ocorre se a instrução deixa pra trás algum recurso aberto associado com a sessão obtida. Atualmente, a única situação em que isto ocorre é com o uso de <code class="literal">org.hibernate.ScrollableResults</code>.  </p></li></ul></div><p>O parâmetro de configuração <code class="literal">hibernate.connection.release_mode</code> é usado para especificar qual modo de liberação deve ser usado. Segue abaixo os valores possíveis: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code> (padrão): essa opção delega ao modo de liberação retornado pelo método <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code>. Para JTATransactionFactory, ele retorna ConnectionReleaseMode.AFTER_STATEMENT; para JDBCTransactionFactory, ele retorna ConnectionReleaseMode.AFTER_TRANSACTION. Raramente, é uma boa idéia alterar padrão, pois ao se fazer isso temos falhas que parecem bugs e/ou suposições inválidas no código do usuário.  </p></li><li><p><code class="literal">on_close</code>: indica o uso da ConnectionReleaseMode.ON_CLOSE. Essa opção foi deixada para manter a compatibilidade, mas seu uso é fortemente desencorajado.  </p></li><li><p><code class="literal">after_transaction</code>: indica o uso da ConnectionReleaseMode.AFTER_TRANSACTION. Essa opção não deve ser usada com ambientes JTA. Também note que no caso da ConnectionReleaseMode.AFTER_TRANSACTION, se a sessão foi colocada no modo auto-commit a conexão vai ser liberada de forma similar ao modo AFTER_STATEMENT.  </p></li><li><p><code class="literal">after_statement</code>: indica o uso ConnectionReleaseMode.AFTER_STATEMENT. Além disso, o <code class="literal">ConnectionProvider</code> configurado é consultado para verificar se suporta essa configuração (<code class="literal">supportsAggressiveRelease()</code>). Se não suportar, o modo de liberação é redefinido como ConnectionRelease-Mode.AFTER_TRANSACTION. Essa configuração só é segura em ambientes onde podemos tanto readquirir a mesma conexão JDBC adjacente todas as vezes que chamarmos <code class="literal">ConnectionProvider.getConnection()</code> quanto em um ambiente auto-commit, onde não importa se voltamos para a mesma conexão.  </p></li></ul></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>Anterior</strong>Capítulo 12. Read-only entities</a></li><li class="up"><a accesskey="u" href="#"><strong>Acima</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Principal</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>Próxima</strong>Capítulo 14. Interceptadores e Eventos</a></li></ul></body></html>