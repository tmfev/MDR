<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 24 章 示例：父子关系（Parent/Child）</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="additionalmodules.html" title="第 23 章 Additional modules"/><link rel="next" href="example-weblog.html" title="第 25 章 示例：Weblog 应用程序"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="additionalmodules.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="example-weblog.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild"/>第 24 章 示例：父子关系（Parent/Child）</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="example-parentchild.html#example-parentchild-collections">24.1. 关于 collections 需要注意的一点</a></span></dt><dt><span class="section"><a href="example-parentchild.html#example-parentchild-bidir">24.2. 双向的一对多关系（Bidirectional one-to-many）</a></span></dt><dt><span class="section"><a href="example-parentchild.html#example-parentchild-cascades">24.3. 级联生命周期（Cascading lifecycle） </a></span></dt><dt><span class="section"><a href="example-parentchild.html#example-parentchild-update">24.4. 级联与未保存值（unsaved-value）</a></span></dt><dt><span class="section"><a href="example-parentchild.html#example-parentchild-conclusion">24.5. 结论</a></span></dt></dl></div><p>刚刚接触 Hibernate 的人大多是从父子关系（parent / child type relationship）的建模入手的。父子关系的建模有两种方法。由于种种原因，最方便的方法是把 <code class="literal">Parent</code> 和 <code class="literal">Child</code> 都建模成实体类，并创建一个从 <code class="literal">Parent</code> 指向 <code class="literal">Child</code> 的 &lt;one-to-many&gt; 关联，对新手来说尤其如此。还有一种方法，就是将 <code class="literal">Child</code> 声明为一个 <code class="literal">&lt;composite-element&gt;</code>（组合元素）。 事实上在 Hibernate 中 one to many 关联的默认语义远没有 composite element 贴近 parent / child 关系的通常语义。下面我们会阐述如何使用<span class="emphasis"><em>带有级联的双向一对多关联（idirectional one to many association with cascades）</em></span>去建立有效、优美的 parent / child 关系。 </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-collections"/>24.1. 关于 collections 需要注意的一点</h2></div></div></div><p>Hibernate collections 被当作其所属实体而不是其包含实体的一个逻辑部分。这非常重要，它主要体现为以下几点： </p><div class="itemizedlist"><ul><li><p>当删除或增加 collection 中对象的时候，collection 所属者的版本值会递增。  </p></li><li><p>如果一个从 collection 中移除的对象是一个值类型（value type）的实例，比如 composite element，那么这个对象的持久化状态将会终止，其在数据库中对应的记录会被删除。同样的，向 collection 增加一个 value type 的实例将会使之立即被持久化。  </p></li><li><p>另一方面，如果从一对多或多对多关联的 collection 中移除一个实体，在缺省情况下这个对象并不会被删除。这个行为是完全合乎逻辑的－－改变一个实体的内部状态不应该使与它关联的实体消失掉。同样的，向 collection 增加一个实体不会使之被持久化。  </p></li></ul></div><p>实际上，向 Collection 增加一个实体的缺省动作只是在两个实体之间创建一个连接而已，同样移除的时候也只是删除连接。这种处理对于所有的情况都是合适的。对于父子关系则是完全不适合的，在这种关系下，子对象的生存绑定于父对象的生存周期。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-bidir"/>24.2. 双向的一对多关系（Bidirectional one-to-many）</h2></div></div></div><p>假设我们要实现一个简单的从 Parent 到 Child 的 &lt;one-to-many&gt; 关联。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>如果我们运行下面的代码： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">.....;</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">save</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>Hibernate 会产生两条 SQL 语句： </p><div class="itemizedlist"><ul><li><p>一条 <code class="literal">INSERT</code> 语句，为 <code class="literal">c</code> 创建一条记录</p></li><li><p>一条 <code class="literal">UPDATE</code> 语句，创建从 <code class="literal">p</code> 到 <code class="literal">c</code> 的连接 </p></li></ul></div><p>这样做不仅效率低，而且违反了 <code class="literal">parent_id</code> 列 <code class="literal">parent_id</code> 非空的限制。我们可以通过在集合类映射上指定 <code class="literal">not-null="true"</code> 来解决违反非空约束的问题： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>然而，这并非是推荐的解决方法。 </p><p>这种现象的根本原因是从 <code class="literal">p</code> 到 <code class="literal">c</code> 的连接（外键 parent_id）没有被当作 <code class="literal">Child</code> 对象状态的一部分，因而没有在 <code class="literal">INSERT</code> 语句中被创建。因此解决的办法就是把这个连接添加到 <code class="literal">Child</code> 的映射中。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>你还需要为类 <code class="literal">Child</code> 添加 <code class="literal">parent</code> 属性。 </p><p>现在实体 <code class="literal">Child</code> 在管理连接的状态，为了使 collection 不更新连接，我们使用 <code class="literal">inverse</code> 属性： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>下面的代码是用来添加一个新的 <code class="literal">Child</code>： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">save</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>现在，只会有一条 <code class="literal">INSERT</code> 语句被执行。 </p><p>为了让事情变得井井有条，可以为 <code class="literal">Parent</code> 加一个 <code class="literal">addChild()</code> 方法。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">void</span><!-- <br/> --><span class="java_plain">&nbsp;addChild</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Child</span><!-- <br/> --><span class="java_plain">&nbsp;c</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_keyword">this</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;children</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>现在，添加 <code class="literal">Child</code> 的代码就是这样： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">save</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-cascades"/>24.3. 级联生命周期（Cascading lifecycle） </h2></div></div></div><p>需要显式调用 <code class="literal">save()</code> 仍然很麻烦，我们可以用级联来解决这个问题。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">cascade</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;all&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>这样上面的代码可以简化为：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>同样的，保存或删除 <code class="literal">Parent</code> 对象的时候并不需要遍历其子对象。下面的代码会删除对象 <code class="literal">p</code> 及其所有子对象对应的数据库记录。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">delete</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>然而，这段代码： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Child</span><span class="java_separator">)</span><span class="java_plain">&nbsp;p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">iterator</span><span class="java_separator">().</span><span class="java_plain">next</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">remove</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_literal">null</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>不会从数据库删除<code class="literal">c</code>；它只会删除与 <code class="literal">p</code> 之间的连接（并且会导致违反 <code class="literal">NOT NULL</code> 约束，在这个例子中）。你需要显式调用 <code class="literal">delete()</code> 来删除 <code class="literal">Child</code>。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;pid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Child</span><span class="java_separator">)</span><span class="java_plain">&nbsp;p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">iterator</span><span class="java_separator">().</span><span class="java_plain">next</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">remove</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">delete</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>在我们的例子中，如果没有父对象，子对象就不应该存在，如果将子对象从 collection 中移除，实际上我们是想删除它。要实现这种要求，就必须使用 <code class="literal">cascade="all-delete-orphan"</code>。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;children&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">cascade</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;all-delete-orphan&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;parent_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Child&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>注意：即使在 collection 一方的映射中指定 <code class="literal">inverse="true"</code>，级联仍然是通过遍历 collection 中的元素来处理的。如果你想要通过级联进行子对象的插入、删除、更新操作，就必须把它加到 collection 中，只调用 <code class="literal">setParent()</code> 是不够的。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-update"/>24.4. 级联与未保存值（<code class="literal">unsaved-value</code>）</h2></div></div></div><p>Suppose we loaded up a <code class="literal">Parent</code> in one <code class="literal">Session</code>, made some changes in a UI action and wanted to persist these changes in a new session by calling <code class="literal">update()</code>. The <code class="literal">Parent</code> will contain a collection of children and, since the cascading update is enabled, Hibernate needs to know which children are newly instantiated and which represent existing rows in the database. We will also assume that both <code class="literal">Parent</code> and <code class="literal">Child</code> have generated identifier properties of type <code class="literal">Long</code>. Hibernate will use the identifier and version/timestamp property value to determine which of the children are new. (See <a class="xref" href="objectstate.html#objectstate-saveorupdate" title="11.7. 自动状态检测">第 11.7 节 “自动状态检测”</a>.) <span class="emphasis"><em>In Hibernate3, it is no longer necessary to specify an <code class="literal">unsaved-value</code> explicitly.</em></span> </p><p>下面的代码会更新 <code class="literal">parent</code> 和 <code class="literal">child</code> 对象，并且插入 <code class="literal">newChild</code> 对象。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">parent&nbsp;and&nbsp;child&nbsp;were&nbsp;both&nbsp;loaded&nbsp;in&nbsp;a&nbsp;previous&nbsp;session</span>
<!--  --><br/><span class="java_plain">parent</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">child</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;newChild&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">parent</span><span class="java_separator">.</span><span class="java_plain">addChild</span><span class="java_separator">(</span><span class="java_plain">newChild</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">update</span><span class="java_separator">(</span><span class="java_plain">parent</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre><p>这对于自动生成标识的情况是非常好的，但是自分配的标识和复合标识怎么办呢？这是有点麻烦，因为 Hibernate 没有办法区分新实例化的对象（标识被用户指定了）和前一个 Session 装入的对象。在这种情况下，Hibernate 会使用 timestamp 或 version 属性，或者查询第二级缓存，或者最坏的情况，查询数据库，来确认是否此行存在。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-conclusion"/>24.5. 结论</h2></div></div></div><p>这里有不少东西需要融会贯通，可能会让新手感到迷惑。但是在实践中它们都工作地非常好。大部分 Hibernate 应用程序都会经常用到父子对象模式。  </p><p>在第一段中我们曾经提到另一个方案。上面的这些问题都不会出现在 <code class="literal">&lt;composite-element&gt;</code> 映射中，它准确地表达了父子关系的语义。很不幸复合元素还有两个重大限制：复合元素不能拥有 collections，并且，除了用于惟一的父对象外，它们不能再作为其它任何实体的子对象。  </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="additionalmodules.html"><strong>上一页</strong>第 23 章 Additional modules</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="example-weblog.html"><strong>下一页</strong>第 25 章 示例：Weblog 应用程序 </a></li></ul></body></html>