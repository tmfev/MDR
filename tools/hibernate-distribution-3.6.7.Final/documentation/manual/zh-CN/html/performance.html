<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 21 章 提升性能</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="xml.html" title="第 20 章 XML 映射"/><link rel="next" href="toolsetguide.html" title="第 22 章 工具箱指南"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>第 21 章 提升性能</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance.html#performance-fetching">21.1. 抓取策略（Fetching strategies）</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-fetching-lazy">21.1.1. 操作延迟加载的关联</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-custom">21.1.2. 调整抓取策略（Tuning fetch strategies）</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-proxies">21.1.3. 单端关联代理（Single-ended association proxies）</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-initialization">21.1.4. 实例化集合和代理（Initializing collections and proxies）</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-batch">21.1.5. 使用批量抓取（Using batch fetching）</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-subselect">21.1.6. 使用子查询抓取（Using subselect fetching）</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-profiles">21.1.7. Fetch profile（抓取策略）</a></span></dt><dt><span class="section"><a href="performance.html#performance-fetching-lazyproperties">21.1.8. 使用延迟属性抓取（Using lazy property fetching）</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-cache">21.2. 二级缓存（The Second Level Cache）</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-cache-mapping">21.2.1. 缓存映射（Cache mappings）</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-readonly">21.2.2. 策略：只读缓存（Strategy：read only）</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-readwrite">21.2.3. 策略：读写/缓存（Strategy：read/write）</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-nonstrict">21.2.4. 策略：非严格读/写缓存（Strategy：nonstrict read/write）</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-transactional">21.2.5. 策略：事务缓存（transactional）</a></span></dt><dt><span class="section"><a href="performance.html#performance-cache-compat-matrix">21.2.6. 各种缓存提供商/缓存并发策略的兼容性</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-sessioncache">21.3. 管理缓存（Managing the caches）</a></span></dt><dt><span class="section"><a href="performance.html#performance-querycache">21.4. 查询缓存（The Query Cache）</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-querycache-enable">21.4.1. 启用查询缓存</a></span></dt><dt><span class="section"><a href="performance.html#performance-querycache-regions">21.4.2. 查询缓存区</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-collections">21.5. 理解集合性能（Understanding Collection performance）</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-collections-taxonomy">21.5.1. 分类（Taxonomy）</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-mostefficientupdate">21.5.2. Lists，maps 和 sets 用于更新效率最高</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-mostefficentinverse">21.5.3. Bag 和 list 是反向集合类中效率最高的</a></span></dt><dt><span class="section"><a href="performance.html#performance-collections-oneshotdelete">21.5.4. 一次性删除（One shot delete）</a></span></dt></dl></dd><dt><span class="section"><a href="performance.html#performance-monitoring">21.6. 监测性能（Monitoring performance）</a></span></dt><dd><dl><dt><span class="section"><a href="performance.html#performance-monitoring-sf">21.6.1. 监测 SessionFactory</a></span></dt><dt><span class="section"><a href="performance.html#performance-monitoring-metrics">21.6.2. 数据记录（Metrics）</a></span></dt></dl></dd></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>21.1. 抓取策略（Fetching strategies）</h2></div></div></div><p>当应用程序需要在（Hibernate实体对象图的）关联关系间进行导航的时候，Hibernate 使用 <span class="emphasis"><em>抓取策略（fetching strategy）</em></span> 获取关联对象。抓取策略可以在 O/R 映射的元数据中声明，也可以在特定的 HQL 或<code class="literal">条件查询（Criteria Query）</code>中重载声明。</p><p>Hibernate3 定义了如下几种抓取策略：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>连接抓取（Join fetching）</em></span>：Hibernate 通过在 <code class="literal">SELECT</code>  语句使用 <code class="literal">OUTER JOIN</code>（外连接）来获得对象的关联实例或者关联集合。 </p></li><li><p><span class="emphasis"><em>查询抓取（Select fetching）</em></span>：另外发送一条 <code class="literal">SELECT</code> 语句抓取当前对象的关联实体或集合。除非你显式的指定 <code class="literal">lazy="false"</code> 禁止 延迟抓取（lazy fetching），否则只有当你真正访问关联关系的时候，才会执行第二条 select 语句。</p></li><li><p><span class="emphasis"><em>子查询抓取（Subselect fetching）</em></span>：另外发送一条  <code class="literal">SELECT</code> 语句抓取在前面查询到（或者抓取到）的所有实体对象的关联集合。除非你显式的指定 <code class="literal">lazy="false"</code> 禁止延迟抓取（lazy fetching），否则只有当你真正访问关联关系的时候，才会执行第二条 select 语句。</p></li><li><p><span class="emphasis"><em>批量抓取（Batch fetching）</em></span>：对查询抓取的优化方案，通过指定一个主键或外键列表，Hibernate 使用单条 <code class="literal">SELECT</code> 语句获取一批对象实例或集合。</p></li></ul></div><p>Hibernate 会区分下列各种情况：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Immediate fetching，立即抓取</em></span>：当宿主被加载时，关联、集合或属性被立即抓取。</p></li><li><p><span class="emphasis"><em>Lazy collection fetching，延迟集合抓取</em></span>：直到应用程序对集合进行了一次操作时，集合才被抓取（对集合而言这是默认行为）。</p></li><li><p><span class="emphasis"><em>"Extra-lazy" collection fetching,"Extra-lazy" 集合抓取</em></span>：对集合类中的每个元素而言，都是直到需要时才去访问数据库。除非绝对必要，Hibernate 不会试图去把整个集合都抓取到内存里来（适用于非常大的集合）。</p></li><li><p><span class="emphasis"><em>Proxy fetching，代理抓取</em></span>：对返回单值的关联而言，当其某个方法被调用，而非对其关键字进行 get 操作时才抓取。</p></li><li><p><span class="emphasis"><em>"No-proxy" fetching，非代理抓取</em></span>：对返回单值的关联而言，当实例变量被访问的时候进行抓取。与上面的代理抓取相比，这种方法没有那么“延迟”得厉害（就算只访问标识符，也会导致关联抓取）但是更加透明，因为对应用程序来说，不再看到 proxy。这种方法需要在编译期间进行字节码增强操作，因此很少需要用到。</p></li><li><p><span class="emphasis"><em>Lazy attribute fetching，属性延迟加载</em></span>：对属性或返回单值的关联而言，当其实例变量被访问的时候进行抓取。需要编译期字节码强化，因此这一方法很少是必要的。</p></li></ul></div><p>这里有两个正交的概念：关联<span class="emphasis"><em>何时</em></span>被抓取，以及被<span class="emphasis"><em>如何</em></span>抓取（会采用什么样的 SQL 语句）。注意不要混淆它们。我们使用<code class="literal">抓取</code>来改善性能。我们使用<code class="literal">延迟</code>来定义一些契约，对某特定类的某个脱管的实例，知道有哪些数据是可以使用的。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>21.1.1. 操作延迟加载的关联</h3></div></div></div><p>默认情况下，Hibernate 3 对集合使用延迟 select 抓取，对返回单值的关联使用延迟代理抓取。对几乎是所有的应用而言，其绝大多数的关联，这种策略都是有效的。</p><p>假若你设置了 <code class="literal">hibernate.default_batch_fetch_size</code>，Hibernate 会对延迟加载采取批量抓取优化措施（这种优化也可能会在更细化的级别打开）。</p><p>然而，你必须了解延迟抓取带来的一个问题。在一个打开的 Hibernate session 上下文之外调用延迟集合会导致一次意外。比如： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">s&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessions</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">openSession</span><!-- <br/> --><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_type">User</span><span class="java_plain">&nbsp;u&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">User</span><span class="java_separator">)</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;from&nbsp;User&nbsp;u&nbsp;where&nbsp;u.name=:userName&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setString</span><span class="java_separator">(</span><span class="java_literal">&quot;userName&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;userName</span><span class="java_separator">).</span><span class="java_plain">uniqueResult</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Map</span><span class="java_plain">&nbsp;permissions&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;u</span><span class="java_separator">.</span><span class="java_plain">getPermissions</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">s</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">Integer</span><span class="java_plain">&nbsp;accessLevel&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Integer</span><span class="java_separator">)</span><span class="java_plain">&nbsp;permissions</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">&quot;accounts&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Error</span><span class="java_operator">!</span></pre><p>在 <code class="literal">Session</code> 关闭后，permessions 集合将是未实例化的、不再可用，因此无法正常载入其状态。 <span class="emphasis"><em>Hibernate 对脱管对象不支持延迟实例化</em></span>。这里的修改方法是将 permissions 读取数据的代码移到事务提交之前。</p><p>除此之外，通过对关联映射指定 <code class="literal">lazy="false"</code>，我们也可以使用非延迟的集合或关联。但是，对绝大部分集合来说，更推荐使用延迟方式抓取数据。如果在你的对象模型中定义了太多的非延迟关联，Hibernate 最终几乎需要在每个事务中载入整个数据库到内存中。</p><p>但是，另一方面，在一些特殊的事务中，我们也经常需要使用到连接抓取（它本身上就是非延迟的），以代替查询抓取。 下面我们将会很快明白如何具体的定制 Hibernate 中的抓取策略。在 Hibernate3 中，具体选择哪种抓取策略的机制是和选择 单值关联或集合关联相一致的。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>21.1.2. 调整抓取策略（Tuning fetch strategies）</h3></div></div></div><p>查询抓取（默认的）在 N+1 查询的情况下是极其脆弱的，因此我们可能会要求在映射文档中定义使用连接抓取：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;permissions&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">fetch</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;userId&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Permission&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;mother&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">fetch</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>在映射文档中定义的<code class="literal">抓取</code>策略将会对以下列表条目产生影响：</p><div class="itemizedlist"><ul><li><p>通过 <code class="literal">get()</code> 或 <code class="literal">load()</code> 方法取得数据。</p></li><li><p>只有在关联之间进行导航时，才会隐式的取得数据。</p></li><li><p>条件查询</p></li><li><p>使用了 <code class="literal">subselect</code> 抓取的 HQL 查询</p></li></ul></div><p>不管你使用哪种抓取策略，定义为非延迟的类图会被保证一定装载入内存。注意这可能意味着在一条 HQL 查询后紧跟着一系列的查询。 </p><p>通常情况下，我们并不使用映射文档进行抓取策略的定制。更多的是，保持其默认值，然后在特定的事务中， 使用 HQL 的<code class="literal">左连接抓取（left join fetch）</code> 对其进行重载。这将通知 Hibernate在第一次查询中使用外部关联（outer join），直接得到其关联数据。在<code class="literal">条件查询</code> API 中，应该调用 <code class="literal">setFetchMode（FetchMode.JOIN）</code>语句。 </p><p>也许你喜欢仅仅通过条件查询，就可以改变 <code class="literal">get()</code> 或 <code class="literal">load()</code> 语句中的数据抓取策略。例如： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_plain">&nbsp;user&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createCriteria</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">User</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setFetchMode</span><span class="java_separator">(</span><span class="java_literal">&quot;permissions&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">FetchMode</span><span class="java_separator">.</span><span class="java_plain">JOIN</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Restrictions</span><span class="java_separator">.</span><span class="java_plain">idEq</span><span class="java_separator">(</span><span class="java_plain">userId</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">uniqueResult</span><span class="java_separator">();</span></pre><p>这就是其他 ORM 解决方案的“抓取计划（fetch plan）”在 Hibernate 中的等价物。</p><p>截然不同的一种避免 N+1 次查询的方法是，使用二级缓存。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>21.1.3. 单端关联代理（Single-ended association proxies）</h3></div></div></div><p>在 Hinerbate 中，对集合的延迟抓取的采用了自己的实现方法。但是，对于单端关联的延迟抓取，则需要采用 其他不同的机制。单端关联的目标实体必须使用代理，Hihernate 在运行期二进制级（通过优异的 CGLIB 库）， 为持久对象实现了延迟载入代理。 </p><p>默认的，Hibernate3 将会为所有的持久对象产生代理（在启动阶段），然后使用他们实现 <code class="literal">多对一（many-to-one）</code>关联和<code class="literal">一对一（one-to-one）</code> 关联的延迟抓取。 </p><p>在映射文件中，可以通过设置 <code class="literal">proxy</code> 属性为目标 class 声明一个接口供代理接口使用。 默认的，Hibernate 将会使用该类的一个子类。<span class="emphasis"><em>注意：被代理的类必须实现一个至少包可见的默认构造函数，我们建议所有的持久类都应拥有这样的构造函数。</em></span></p><p>在如此方式定义一个多态类的时候，有许多值得注意的常见性的问题，例如： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>首先，<code class="literal">Cat</code> 实例永远不可以被强制转换为 <code class="literal">DomesticCat</code>，即使它本身就是 <code class="literal">DomesticCat</code> 实例。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;instantiate&nbsp;a&nbsp;proxy&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">does&nbsp;not&nbsp;hit&nbsp;the&nbsp;db</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cat</span><span class="java_separator">.</span><span class="java_plain">isDomesticCat</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;hit&nbsp;the&nbsp;db&nbsp;to&nbsp;initialize&nbsp;the&nbsp;proxy</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;dc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cat</span><span class="java_separator">;</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Error</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">....</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>其次，代理的“<code class="literal">==</code>”可能不再成立。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;instantiate&nbsp;a&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;proxy</span>
<!--  --><br/><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;dc&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_type">DomesticCat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;id</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;acquire&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DomesticCat</span><span class="java_plain">&nbsp;proxy</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_operator">==</span><span class="java_plain">dc</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span></pre><p>虽然如此，但实际情况并没有看上去那么糟糕。虽然我们现在有两个不同的引用，分别指向这两个不同的代理对象，但实际上，其底层应该是同一个实例对象：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">setWeight</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">11.0</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;hit&nbsp;the&nbsp;db&nbsp;to&nbsp;initialize&nbsp;the&nbsp;proxy</span>
<!--  --><br/><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_plain">&nbsp;dc</span><span class="java_separator">.</span><span class="java_plain">getWeight</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_literal">11.0</span></pre><p>第三，你不能对 <code class="literal">final</code> 类或具有 <code class="literal">final</code> 方法的类使用 CGLIB 代理。</p><p>最后，如果你的持久化对象在实例化时需要某些资源（例如，在实例化方法、默认构造方法中），那么代理对象也同样需要使用这些资源。实际上，代理类是持久化类的子类。</p><p>这些问题都源于 Java 的单根继承模型的天生限制。如果你希望避免这些问题，那么你的每个持久化类必须实现一个接口， 在此接口中已经声明了其业务方法。然后，你需要在映射文档中再指定这些接口，如 <code class="literal">CatImpl</code> 实现 <code class="literal">Cat</code> 而 <code class="literal">DomesticCatImpl</code> 实现 <code class="literal">DomesticCat</code> 接口。例如：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CatImpl&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCatImpl&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">proxy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>然后，<code class="literal">load()</code> 和 <code class="literal">iterate()</code> 永远也不会返回 <code class="literal">Cat</code> 和 <code class="literal">DomesticCat</code> 实例的代理。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_plain">&nbsp;cat&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">CatImpl</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catid</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Iterator</span><span class="java_plain">&nbsp;iter&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">createQuery</span><span class="java_separator">(</span><span class="java_literal">&quot;from&nbsp;CatImpl&nbsp;as&nbsp;cat&nbsp;where&nbsp;cat.name='fritz'&quot;</span><span class="java_separator">).</span><span class="java_plain">iterate</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Cat</span><span class="java_plain">&nbsp;fritz&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;iter</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">();</span></pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p><code class="literal">list()</code> 通常不返回代理。</p></div><p>这里，对象之间的关系也将被延迟载入。这就意味着，你应该将属性声明为 <code class="literal">Cat</code>，而不是 <code class="literal">CatImpl</code>。</p><p>有些方法中是<span class="emphasis"><em>不</em></span>需要代理初始化的：</p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code> 方法，如果持久类没有重载 <code class="literal">equals()</code> 方法。</p></li><li><p><code class="literal">hashCode()</code>：如果持久类没有重载 <code class="literal">hashCode()</code> 方法。</p></li><li><p>标志符的 getter 方法。</p></li></ul></div><p>Hibernate 将会识别出那些重载了 <code class="literal">equals()</code>、或 <code class="literal">hashCode()</code> 方法的持久化类。</p><p>若选择 <code class="literal">lazy="no-proxy"</code> 而非默认的 <code class="literal">lazy="proxy"</code>，我们可以避免类型转换带来的问题。然而，这样我们就需要编译期字节码增强，并且所有的操作都会导致立刻进行代理初始化。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>21.1.4. 实例化集合和代理（Initializing collections and proxies）</h3></div></div></div><p>在 <code class="literal">Session</code> 范围之外访问未初始化的集合或代理，Hibernate 将会抛出 <code class="literal">LazyInitializationException</code> 异常。也就是说，在分离状态下，访问一个实体所拥有的集合，或者访问其指向代理的属性时，会引发此异常。 </p><p>有时候我们需要保证某个代理或者集合在 Session 关闭前就已经被初始化了。当然，我们可以通过强行调用 <code class="literal">cat.getSex()</code> 或者 <code class="literal">cat.getKittens().size()</code> 之类的方法来确保这一点。 但是这样的程序会造成读者的疑惑，也不符合通常的代码规范。 </p><p>静态方法 <code class="literal">Hibernate.initialized()</code> 为你的应用程序提供了一个便捷的途径来延迟加载集合或代理。 只要它的 Session 处于 open 状态，<code class="literal">Hibernate.initialize(cat)</code> 将会为 cat 强制对代理实例化。同样，<code class="literal">Hibernate.initialize(cat.getKittens())</code> 对 kittens 的集合具有同样的功能。 </p><p>还有另外一种选择，就是保持 <code class="literal">Session</code> 一直处于 open 状态，直到所有需要的集合或代理都被载入。 在某些应用架构中，特别是对于那些使用 Hibernate 进行数据访问的代码，以及那些在不同应用层和不同物理进程中使用 Hibernate 的代码。 在集合实例化时，如何保证 <code class="literal">Session</code> 处于 open 状态经常会是一个问题。有两种方法可以解决此问题： </p><div class="itemizedlist"><ul><li><p>在一个基于 Web 的应用中，可以利用 servlet 过滤器（filter），在用户请求（request）结束、页面生成 结束时关闭 <code class="literal">Session</code>（这里使用了<span class="emphasis"><em>在展示层保持打开 Session 模式（Open Session in View）</em></span>），当然，这将依赖于应用框架中异常需要被正确的处理。在返回界面给用户之前，乃至在生成界面过程中发生异常的情况下，正确关闭 <code class="literal">Session</code> 和结束事务将是非常重要的， 请参见 Hibernate wiki 上的 "Open Session in View" 模式，你可以找到示例。 </p></li><li><p>在一个拥有单独业务层的应用中，业务层必须在返回之前，为 web 层“准备”好其所需的数据集合。这就意味着 业务层应该载入所有表现层/web 层所需的数据，并将这些已实例化完毕的数据返回。通常，应用程序应该为 web 层所需的每个集合调用 <code class="literal">Hibernate.initialize()</code>（这个调用必须发生咱 session 关闭之前）；或者使用带有 <code class="literal">FETCH</code> 从句，或 <code class="literal">FetchMode.JOIN</code> 的 Hibernate 查询，事先取得所有的数据集合。如果你在应用中使用了 <span class="emphasis"><em>Command</em></span> 模式，代替 <span class="emphasis"><em>Session Facade</em></span>，那么这项任务将会变得简单的多。 </p></li><li><p>你也可以通过 <code class="literal">merge()</code> 或 <code class="literal">lock()</code> 方法，在访问未实例化的集合（或代理）之前，为先前载入的对象绑定一个新的 <code class="literal">Session</code>。显然，Hibernate 将不会，也不<span class="emphasis"><em>应该</em></span>自动完成这些任务，因为这将引入一个特殊的事务语义。 </p></li></ul></div><p>有时候，你并不需要完全实例化整个大的集合，仅需要了解它的部分信息（例如其大小）、或者集合的部分内容。 </p><p>你可以使用集合过滤器得到其集合的大小，而不必实例化整个集合：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">list</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">get</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">0</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p>这里的 <code class="literal">createFilter()</code> 方法也可以被用来有效的抓取集合的部分内容，而无需实例化整个集合：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;lazyCollection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">setFirstResult</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">0</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">setMaxResults</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">10</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">list</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>21.1.5. 使用批量抓取（Using batch fetching）</h3></div></div></div><p>Hibernate 可以充分有效的使用批量抓取，也就是说，如果仅一个访问代理（或集合），那么 Hibernate 将不载入其他未实例化的代理。批量抓取是延迟查询抓取的优化方案，你可以在两种批量抓取方案之间进行选择：在类级别和集合级别。 </p><p>类/实体级别的批量抓取很容易理解。假设你在运行时将需要面对下面的问题：你在一个 <code class="literal">Session</code> 中载入了 25 个 <code class="literal">Cat</code> 实例，每个 <code class="literal">Cat</code> 实例都拥有一个引用成员 <code class="literal">owner</code>，其指向 <code class="literal">Person</code>，而 <code class="literal">Person</code> 类是代理，同时 <code class="literal">lazy="true"</code>。如果你必须遍历整个 cats 集合，对每个元素调用 <code class="literal">getOwner()</code> 方法，Hibernate 将会默认的执行 25 次 <code class="literal">SELECT</code> 查询， 得到其 owner 的代理对象。这时，你可以通过在映射文件的 <code class="literal">Person</code> 属性，显式声明 <code class="literal">batch-size</code>，改变其行为： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">batch-size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;10&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">...</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>随之，Hibernate 将只需要执行三次查询，分别为 10、10、 5。 </p><p>你也可以在集合级别定义批量抓取。例如，如果每个 <code class="literal">Person</code> 都拥有一个延迟载入的 <code class="literal">Cats</code> 集合， 现在，<code class="literal">Sesssion</code> 中载入了 10 个 person 对象，遍历 person 集合将会引起 10 次 <code class="literal">SELECT</code> 查询，每次查询都会调用 <code class="literal">getCats()</code> 方法。如果你在 <code class="literal">Person</code> 的映射定义部分，允许对 <code class="literal">cats</code> 批量抓取，那么，Hibernate 将可以预先抓取整个集合。请看例子： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cats&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">batch-size</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;3&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>如果整个的 <code class="literal">batch-size</code> 是 3，那么 Hibernate 将会分四次执行 <code class="literal">SELECT</code> 查询， 按照 3、3、3、1 的大小分别载入数据。这里的每次载入的数据量还具体依赖于当前 <code class="literal">Session</code> 中未实例化集合的个数。 </p><p>如果你的模型中有嵌套的树状结构，例如典型的帐单－原料结构（bill-of-materials pattern），集合的批量抓取是非常有用的。（尽管在更多情况下对树进行读取时，<span class="emphasis"><em>嵌套集合（nested set）</em></span>或<span class="emphasis"><em>原料路径（materialized path）</em></span>可能是更好的解决方法。）</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>21.1.6. 使用子查询抓取（Using subselect fetching）</h3></div></div></div><p>假若一个延迟集合或单值代理需要抓取，Hibernate 会使用一个 subselect 重新运行原来的查询，一次性读入所有的实例。这和批量抓取的实现方法是一样的，不会有破碎的加载。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-profiles"/>21.1.7. Fetch profile（抓取策略）</h3></div></div></div><p>Another way to affect the fetching strategy for loading associated objects is through something called a fetch profile, which is a named configuration associated with the <code class="interfacename">org.hibernate.SessionFactory</code> but enabled, by name, on the <code class="interfacename">org.hibernate.Session</code>. Once enabled on a <code class="interfacename">org.hibernate.Session</code>, the fetch profile will be in affect for that <code class="interfacename">org.hibernate.Session</code> until it is explicitly disabled.</p><p>So what does that mean? Well lets explain that by way of an example which show the different available approaches to configure a fetch profile:</p><div class="example"><a id="d0e18770"/><p class="title"><b>例 21.1. Specifying a fetch profile using <code class="classname">@FetchProfile</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain">@Entity</span><br />
<span class="xml_plain">@FetchProfile(name&nbsp;=&nbsp;&quot;customer-with-orders&quot;,&nbsp;fetchOverrides&nbsp;=&nbsp;{</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@FetchProfile.FetchOverride(entity&nbsp;=&nbsp;Customer.class,&nbsp;association&nbsp;=&nbsp;&quot;orders&quot;,&nbsp;mode&nbsp;=&nbsp;FetchMode.JOIN)</span><br />
<span class="xml_plain">})</span><br />
<span class="xml_plain">public&nbsp;class&nbsp;Customer&nbsp;{</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@Id</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@GeneratedValue</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;id;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;customerNumber;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;@OneToMany</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;private&nbsp;Set</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">Order</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;orders;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;//&nbsp;standard&nbsp;getter/setter</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">}</span><br />
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e18777"/><p class="title"><b>例 21.2. Specifying a fetch profile using <code class="literal">&lt;fetch-profile&gt;</code> outside <code class="literal">&lt;class&gt;</code> node</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cust_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch-profile</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;customer-with-orders&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">entity</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">association</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">style</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetch-profile</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><div class="example"><a id="d0e18788"/><p class="title"><b>例 21.3. Specifying a fetch profile using <code class="literal">&lt;fetch-profile&gt;</code> inside <code class="literal">&lt;class&gt;</code> node</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Customer&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cust_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch-profile</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;customer-with-orders&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fetch</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">association</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;orders&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">style</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;join&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fetch-profile</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Order&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>Now normally when you get a reference to a particular customer, that customer's set of orders will be lazy meaning we will not yet have loaded those orders from the database. Normally this is a good thing. Now lets say that you have a certain use case where it is more efficient to load the customer and their orders together. One way certainly is to use "dynamic fetching" strategies via an HQL or criteria queries. But another option is to use a fetch profile to achieve that. The following code will load both the customer <span class="emphasis"><em>and</em></span>their orders:</p><div class="example"><a id="d0e18804"/><p class="title"><b>例 21.4. Activating a fetch profile for a given <code class="classname">Session</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Session</span><!-- <br/> --><span class="java_plain">&nbsp;session&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">...;</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">enableFetchProfile</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;customer-with-orders&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;name&nbsp;matches&nbsp;from&nbsp;mapping</span>
<!--  --><br/><span class="java_type">Customer</span><span class="java_plain">&nbsp;customer&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Customer</span><span class="java_separator">)</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Customer</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">,</span><span class="java_plain">&nbsp;customerId&nbsp;</span><span class="java_separator">);</span>
</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p><code class="classname">@FetchProfile </code>definitions are global and it does not matter on which class you place them. You can place the <code class="classname">@FetchProfile</code> annotation either onto a class or package (package-info.java). In order to define multiple fetch profiles for the same class or package <code class="classname">@FetchProfiles</code> can be used.</p></div><p>目前只有 join 风格的抓取策略被支持，但其他风格也将被支持。更多细节请参考 <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-3414">HHH-3414</a>。</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>21.1.8. 使用延迟属性抓取（Using lazy property fetching）</h3></div></div></div><p>Hibernate3 对单独的属性支持延迟抓取，这项优化技术也被称为<span class="emphasis"><em>组抓取（fetch groups）</em></span>。 请注意，该技术更多的属于市场特性。在实际应用中，优化行读取比优化列读取更重要。但是，仅载入类的部分属性在某些特定情况下会有用，例如在原有表中拥有几百列数据、数据模型无法改动的情况下。 </p><p>可以在映射文件中对特定的属性设置 <code class="literal">lazy</code>，定义该属性为延迟载入。</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Document&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;native&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;50&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;summary&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;200&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">lazy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;text&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;2000&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">lazy</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>属性的延迟载入要求在其代码构建时加入二进制指示指令（bytecode instrumentation），如果你的持久类代码中未含有这些指令， Hibernate 将会忽略这些属性的延迟设置，仍然将其直接载入。 </p><p>你可以在 Ant 的 Task 中，进行如下定义，对持久类代码加入“二进制指令。”</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">target</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;instrument&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">depends</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;compile&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">taskdef</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;instrument&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">classname</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.tool.instrument.InstrumentTask&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">path</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${jar.path}&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">path</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${classes.dir}&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">classpath</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">refid</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;lib.class.path&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">taskdef</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">instrument</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">verbose</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">fileset</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">dir</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;${testclasses.dir}/org/hibernate/auction/model&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">include</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;*.class&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">fileset</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">instrument</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">target</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>还有一种可以优化的方法，它使用 HQL 或条件查询的投影（projection）特性，可以避免读取非必要的列， 这一点至少对只读事务是非常有用的。它无需在代码构建时“二进制指令”处理，因此是一个更加值得选择的解决方法。 </p><p>有时你需要在 HQL 中通过<code class="literal">抓取所有属性</code>，强行抓取所有内容。 </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>21.2. 二级缓存（The Second Level Cache）</h2></div></div></div><p>Hibernate 的 <code class="literal">Session</code> 在事务级别进行持久化数据的缓存操作。 当然，也有可能分别为每个类（或集合），配置集群、或 JVM 级别（<code class="literal">SessionFactory 级别</code>）的缓存。你甚至可以为之插入一个集群的缓存。注意，缓存永远不知道其他应用程序对持久化仓库（数据库）可能进行的修改 （即使可以将缓存数据设定为定期失效）。 </p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed in <a class="xref" href="performance.html#cacheproviders" title="表 21.1. 缓存策略提供商（Cache Providers）">表 21.1 “缓存策略提供商（Cache Providers）”</a>. You can also implement your own and plug it in as outlined above. Note that versions prior to Hibernate 3.2 use EhCache as the default cache provider.</p><div class="table"><a id="cacheproviders"/><p class="title"><b>表 21.1. 缓存策略提供商（Cache Providers）</b></p><div class="table-contents"><table summary="缓存策略提供商（Cache Providers）" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable （not intended for production use）</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">memory</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">memory, disk, transactional, clustered</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">memory，disk</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">yes (clock sync req.)</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc.JBossCacheRegionFactory</code></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication or invalidation)</td><td align="left">yes (clock sync req.)</td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>21.2.1. 缓存映射（Cache mappings）</h3></div></div></div><p>As we have done in previous chapters we are looking at the two different possibiltites to configure caching. First configuration via annotations and then via Hibernate mapping files.</p><p>By default, entities are not part of the second level cache and we recommend you to stick to this setting. However, you can override this by setting the <code class="literal">shared-cache-mode</code> element in your <code class="filename">persistence.xml</code> file or by using the <code class="literal">javax.persistence.sharedCache.mode </code>property in your configuration. The following values are possible:</p><div class="itemizedlist"><ul><li><p><code class="literal">ENABLE_SELECTIVE</code> (Default and recommended value): entities are not cached unless explicitly marked as cacheable.</p></li><li><p><code class="literal">DISABLE_SELECTIVE</code>: entities are cached unless explicitly marked as not cacheable.</p></li><li><p><code class="literal">ALL</code>: all entities are always cached even if marked as non cacheable.</p></li><li><p><code class="literal">NONE</code>: no entity are cached even if marked as cacheable. This option can make sense to disable second-level cache altogether.</p></li></ul></div><p>The cache concurrency strategy used by default can be set globaly via the <code class="literal">hibernate.cache.default_cache_concurrency_strategy</code> configuration property. The values for this property are:</p><div class="itemizedlist"><ul><li><p><code class="literal">read-only</code></p></li><li><p><code class="literal">read-write</code></p></li><li><p><code class="literal">nonstrict-read-write</code></p></li><li><p><code class="literal">transactional</code></p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>It is recommended to define the cache concurrency strategy per entity rather than using a global one. Use the <code class="classname">@org.hibernate.annotations.Cache</code> annotation for that.</p></div><div class="example"><a id="example-cache-concurrency-with-cache-annotation"/><p class="title"><b>例 21.5. Definition of cache concurrency strategy via <code class="classname">@Cache</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Entity</span><!-- <br/> --><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cacheable</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">Forest</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">...</span><span class="java_plain">&nbsp;</span><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>Hibernate also let's you cache the content of a collection or the identifiers if the collection contains other entities. Use the <code class="classname">@Cache</code> annotation on the collection property.</p><div class="example"><a id="d0e19044"/><p class="title"><b>例 21.6. Caching collections using annotations</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">OneToMany</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">cascade</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">CascadeType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">ALL</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;fetch</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_type">FetchType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">EAGER</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">JoinColumn</span><span class="java_separator">(</span><span class="java_plain">name</span><span class="java_operator">=</span><span class="java_literal">&quot;CUST_ID&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Cache</span><span class="java_separator">(</span><span class="java_plain">usage&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">CacheConcurrencyStrategy</span><span class="java_separator">.</span><span class="java_plain">NONSTRICT_READ_WRITE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">SortedSet</span><span class="java_operator">&lt;</span><span class="java_type">Ticket</span><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;getTickets</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;tickets</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p><a class="xref" href="performance.html#example-cache-annotation-with-attributes" title="例 21.7. @Cache annotation with attributes">例 21.7 “@Cache annotation with attributes”</a>shows the<code class="literal"> @org.hibernate.annotations.Cache</code> annotations with its attributes. It allows you to define the caching strategy and region of a given second level cache.</p><div class="example"><a id="example-cache-annotation-with-attributes"/><p class="title"><b>例 21.7. <code class="classname">@Cache</code> annotation with attributes</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">@Cache(
    CacheConcu<span xmlns="" class="co" id="cache-hm1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>rrencyStrategy usage();
    String reg<span xmlns="" class="co" id="cache-hm2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>ion() default "";
    String inc<span xmlns="" class="co" id="cache-hm3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>lude() default "all";
)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>usage: the given cache concurrency strategy (NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p>region (optional): the cache region (default to the fqcn of the class or the fq role name of the collection)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code> (optional): all to include all properties, non-lazy to only include non lazy properties (default all).</p></td></tr></table></div></div></div></div><br class="example-break"/><p>Let's now take a look at Hibernate mapping files. There the <code class="literal">&lt;cache&gt;</code> element of a class or collection mapping is used to configure the second level cache. Looking at <a class="xref" href="performance.html#example-hibernate-cache-mapping-element" title="例 21.8. The Hibernate &lt;cache&gt; mapping element">例 21.8 “The Hibernate &lt;cache&gt; mapping element”</a> the parallels to anotations is obvious.</p><div class="example"><a id="example-hibernate-cache-mapping-element"/><p class="title"><b>例 21.8. The Hibernate <code class="literal">&lt;cache&gt;</code> mapping element</b></p><div class="example-contents"><div class="programlistingco"><pre class="programlisting">&lt;cache
    usage="tra<span xmlns="" class="co" id="cache1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>nsactional|read-write|nonstrict-read-write|read-only"
    region="Re<span xmlns="" class="co" id="cache2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>gionName"
    include="a<span xmlns="" class="co" id="cache3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>ll|non-lazy"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">usage</code>（必须）说明了缓存的策略：<code class="literal">transactional</code>、 <code class="literal">read-write</code>、<code class="literal">nonstrict-read-write</code> 或 <code class="literal">read-only</code>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">region</code> （可选，默认为类或者集合的名字（class or collection role name）） 指定第二级缓存的区域名（name of the second level cache region） </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">include</code>（可选,默认为 <code class="literal">all</code>） <code class="literal">non-lazy</code> 当属性级延迟抓取打开时，标记为 <code class="literal">lazy="true"</code> 的实体的属性可能无法被缓存 </p></td></tr></table></div></div></div></div><br class="example-break"/><p>Alternatively to <code class="literal">&lt;cache&gt;</code>, you can use <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>.</p><p>Let's now have a closer look at the different usage strategies</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>21.2.2. 策略：只读缓存（Strategy：read only）</h3></div></div></div><p>如果你的应用程序只需读取一个持久化类的实例，而无需对其修改， 那么就可以对其进行<code class="literal">只读</code> 缓存。这是最简单，也是实用性最好的方法。甚至在集群中，它也能完美地运作。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>21.2.3. 策略：读写/缓存（Strategy：read/write）</h3></div></div></div><p>如果应用程序需要更新数据，那么使用<code class="literal">读/写缓存</code> 比较合适。 如果应用程序要求“序列化事务”的隔离级别（serializable transaction isolation level），那么就决不能使用这种缓存策略。 如果在 JTA 环境中使用缓存，你必须指定 <code class="literal">hibernate.transaction.manager_lookup_class</code> 属性的值， 通过它，Hibernate 才能知道该应用程序中 JTA 的<code class="literal">TransactionManager</code>的具体策略。 在其它环境中，你必须保证在 <code class="literal">Session.close()</code>、或 <code class="literal">Session.disconnect()</code> 调用前， 整个事务已经结束。 如果你想在集群环境中使用此策略，你必须保证底层的缓存实现支持锁定（locking）。Hibernate 内置的缓存策略并不支持锁定功能。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>21.2.4. 策略：非严格读/写缓存（Strategy：nonstrict read/write）</h3></div></div></div><p>如果应用程序只偶尔需要更新数据（也就是说，两个事务同时更新同一记录的情况很不常见），也不需要十分严格的事务隔离，那么比较适合使用<code class="literal">非严格读/写缓存</code>策略。如果在 JTA 环境中使用该策略，你必须为其指定 <code class="literal">hibernate.transaction.manager_lookup_class</code> 属性的值，在其它环境中，你必须保证在<code class="literal">Session.close()</code>、或 <code class="literal">Session.disconnect()</code> 调用前，整个事务已经结束。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>21.2.5. 策略：事务缓存（transactional）</h3></div></div></div><p>Hibernate 的<code class="literal">事务缓存</code>策略提供了全事务的缓存支持，例如对 JBoss TreeCache 的支持。这样的缓存只能用于 JTA 环境中，你必须指定为其  <code class="literal">hibernate.transaction.manager_lookup_class</code> 属性。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>21.2.6. 各种缓存提供商/缓存并发策略的兼容性</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>没有一种缓存提供商能够支持上列的所有缓存并发策略。下表中列出了各种提供器、及其各自适用的并发策略。 </p></div><p>没有一种缓存提供商能够支持上列的所有缓存并发策略。下表中列出了各种提供器、及其各自适用的并发策略。 </p><div class="table"><a id="d0e19216"/><p class="title"><b>表 21.2. 各种缓存提供商对缓存并发策略的支持情况（Cache Concurrency Strategy Support）</b></p><div class="table-contents"><table summary="各种缓存提供商对缓存并发策略的支持情况（Cache Concurrency Strategy Support）" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable （not intended for production use）</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>21.3. 管理缓存（Managing the caches）</h2></div></div></div><p>无论何时，当你给 <code class="literal">save()</code>、<code class="literal">update()</code> 或  <code class="literal">saveOrUpdate()</code> 方法传递一个对象时，或使用 <code class="literal">load()</code>、<code class="literal">get()</code>、<code class="literal">list()</code>、<code class="literal">iterate()</code> 或 <code class="literal">scroll()</code> 方法获得一个对象时，该对象都将被加入到 <code class="literal">Session</code> 的内部缓存中。 </p><p>当随后 flush() 方法被调用时，对象的状态会和数据库取得同步。如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用 <code class="literal">evict()</code> 方法，从一级缓存中去掉这些对象及其集合。 </p><div class="example"><a id="d0e19333"/><p class="title"><b>例 21.9. Explcitly evicting a cached instance from the first level cache using <code class="methodname">Session.evict()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">ScrollableResult</span><!-- <br/> --><span class="java_plain">&nbsp;cats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Cat&nbsp;as&nbsp;cat&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">scroll</span><!-- <br/> --><span class="java_separator">();</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">a&nbsp;huge&nbsp;result&nbsp;set</span>
<!--  --><br/><span class="java_keyword">while</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">next</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;cat&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">)</span><span class="java_plain">&nbsp;cats</span><span class="java_separator">.</span><span class="java_plain">get</span><span class="java_separator">(</span><span class="java_literal">0</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWithACat</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_plain">cat</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>Session 还提供了一个 <code class="literal">contains()</code> 方法，用来判断某个实例是否处于当前 session 的缓存中。</p><p>如若要把所有的对象从 session 缓存中彻底清除，则需要调用 <code class="literal">Session.clear()</code>。 </p><p>对于二级缓存来说，在 <code class="literal">SessionFactory</code> 中定义了许多方法，清除缓存中实例、整个类、集合实例或者整个集合。</p><div class="example"><a id="d0e19355"/><p class="title"><b>例 21.10. Second-level cache eviction via <code class="methodname">SessionFactoty.evict() </code>and <code class="methodname">SessionFacyory.evictCollection()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">evict</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Cat</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;catId</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;</span><!-- <br/> --><span class="java_type">Cat</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evict</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;</span><span class="java_type">Cats</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;catId</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;a&nbsp;particular&nbsp;collection&nbsp;of&nbsp;kittens</span>
<!--  --><br/><span class="java_plain">sessionFactory</span><span class="java_separator">.</span><span class="java_plain">evictCollection</span><span class="java_separator">(</span><span class="java_literal">&quot;Cat.kittens&quot;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">evict&nbsp;all&nbsp;kitten&nbsp;collections</span></pre></div></div><br class="example-break"/><p><code class="literal">CacheMode</code> 参数用于控制具体的 Session 如何与二级缓存进行交互。 </p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code>：从二级缓存中读、写数据。</p></li><li><p><code class="literal">CacheMode.GET</code>：从二级缓存中读取数据，仅在数据更新时对二级缓存写数据。</p></li><li><p><code class="literal">CacheMode.PUT</code>：仅向二级缓存写数据，但不从二级缓存中读数据。</p></li><li><p><code class="literal">CacheMode.REFRESH</code>：仅向二级缓存写数据，但不从二级缓存中读数据。通过 <code class="literal">hibernate.cache.use_minimal_puts</code> 的设置，强制二级缓存从数据库中读取数据，刷新缓存内容。</p></li></ul></div><p>如若需要查看二级缓存或查询缓存区域的内容，你可以使用<code class="literal">统计（Statistics）</code> API。</p><div class="example"><a id="d0e19398"/><p class="title"><b>例 21.11. Browsing the second-level cache entries via the <code class="classname">Statistics</code> API</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Map</span><!-- <br/> --><span class="java_plain">&nbsp;cacheEntries&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getSecondLevelCacheStatistics</span><span class="java_separator">(</span><span class="java_plain">regionName</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">getEntries</span><span class="java_separator">();</span></pre></div></div><br class="example-break"/><p>此时，你必须手工打开统计选项。可选的，你可以让 Hibernate 更人工可读的方式维护缓存内容。 </p><div class="example"><a id="d0e19408"/><p class="title"><b>例 21.12. Enabling Hibernate statistics</b></p><div class="example-contents"><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div></div><br class="example-break"/></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>21.4. 查询缓存（The Query Cache）</h2></div></div></div><p>查询的结果集也可以被缓存。只有当经常使用同样的参数进行查询时，这才会有些用处。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-enable"/>21.4.1. 启用查询缓存</h3></div></div></div><p>按照应用程序的事务性处理过程，查询结果的缓存将产生一些负荷。例如，如果缓存针对 Person 的查询结果，在 Person 发生了修改时，Hibernate 将需要跟踪这些结果什么时候失效。因为大多数应用程序不会从缓存查询结果中受益，所以 Hibernate 在缺省情况下将禁用缓存。要使用查询缓存，你首先需要启用查询缓存：</p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>这个设置创建了两个新的缓存 region： </p><div class="itemizedlist"><ul><li><p><code class="classname">org.hibernate.cache.StandardQueryCache</code>，保存缓存的查询结果</p></li><li><p><code class="classname">org.hibernate.cache.UpdateTimestampsCache</code>，保存对可查询表的最近更新的时间戳。它们用于检验查询结果。</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>If you configure your underlying cache implementation to use expiry or timeouts is very important that the cache timeout of the underlying cache region for the UpdateTimestampsCache be set to a higher value than the timeouts of any of the query caches. In fact, we recommend that the the UpdateTimestampsCache region not be configured for expiry at all. Note, in particular, that an LRU cache expiry policy is never appropriate.</p></div><p>如上面所提及的，绝大多数的查询并不能从查询缓存中受益，所以 Hibernate 默认是不进行查询缓存的。如若需要进行缓存，请调用 <code class="literal">org.hibernate.Query.setCacheable（true）</code>方法。这个调用会让查询在执行过程中时先从缓存中查找结果，并将自己的结果集放到缓存中去。 </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>查询缓存不会缓存缓存中实际实体的状态；它只缓存标识符值和值类型的结果。出于这个原因，对于那些作为查询结果缓存的一部分（和集合缓存一样）进行缓存的实体，查询缓存应该和二级缓存一起使用。</p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-querycache-regions"/>21.4.2. 查询缓存区</h3></div></div></div><p>如果你要对查询缓存的失效政策进行精确的控制，你必须调用 <code class="literal">Query.setCacheRegion()</code> 方法，为每个查询指定其命名的缓存区域。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">List</span><!-- <br/> --><span class="java_plain">&nbsp;blogs&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;Blog&nbsp;blog&nbsp;where&nbsp;blog.blogger&nbsp;=&nbsp;:blogger&quot;</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setEntity</span><span class="java_separator">(</span><span class="java_literal">&quot;blogger&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;blogger</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_literal">15</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheable</span><span class="java_separator">(</span><span class="java_literal">true</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setCacheRegion</span><span class="java_separator">(</span><span class="java_literal">&quot;frontpages&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>如果查询需要强行刷新其查询缓存区域，那么你应该调用 <code class="literal">org.hibernate.Query.setCacheMode（CacheMode.REFRESH）</code>方法。 这对在其他进程中修改底层数据（例如，不通过Hibernate修改数据），或对那些需要选择性更新特定查询结果集的情况特别有用。这是对 <code class="literal">org.hibernate.SessionFactory.evictQueries()</code> 的更为有效的替代方案，同样可以清除查询缓存区域。</p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>21.5. 理解集合性能（Understanding Collection performance）</h2></div></div></div><p>在前面的章节里我们已经讨论了集合和相关应用程序。在本节我么将探索运行时集合的更多问题。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>21.5.1. 分类（Taxonomy）</h3></div></div></div><p>Hibernate 定义了三种基本类型的集合：</p><div class="itemizedlist"><ul><li><p>值数据集合</p></li><li><p>一对多关联（One-to-many Associations） </p></li><li><p>多对多关联 </p></li></ul></div><p>这个分类是区分了不同的表和外键关系类型，但是它没有告诉我们关系模型的所有内容。 要完全理解他们的关系结构和性能特点，我们必须同时考虑“用于 Hibernate 更新或删除集合行数据的主键的结构”。因此得到了如下的分类：</p><div class="itemizedlist"><ul><li><p>有序集合类</p></li><li><p>集合（sets）</p></li><li><p>包（bags）</p></li></ul></div><p>所有的有序集合类（maps，lists，arrays）都拥有一个由 <code class="literal">&lt;key&gt;</code> 和 <code class="literal">&lt;index&gt;</code> 组成的主键。这种情况下集合类的更新是非常高效的 — 主键已经被有效的索引，因此当 Hibernate 试图更新或删除一行时，可以迅速找到该行数据。 </p><p>集合（sets）的主键由 <code class="literal">&lt;key&gt;</code> 和其他元素字段构成。对于有些元素类型来说，这很低效，特别是组合元素或者大文本、大二进制字段；数据库可能无法有效的对复杂的主键进行索引。另一方面，对于一对多、多对多关联，特别是合成的标识符来说，集合也可以达到同样的高效性能。（ 附注：如果你希望 <code class="literal">SchemaExport</code> 为你的 <code class="literal">&lt;set&gt;</code> 创建主键，你必须把所有的字段都声明为 <code class="literal">not-null="true"</code>。） </p><p><code class="literal">&lt;idbag&gt;</code> 映射定义了代理键，因此它总是可以很高效的被更新。事实上，<code class="literal">&lt;idbag&gt;</code> 拥有着最好的性能表现。 </p><p>Bag 是最差的。因为 bag 允许重复的元素值，也没有索引字段，因此不可能定义主键。 Hibernate 无法判断出重复的行。当这种集合被更改时，Hibernate 将会先完整地移除 （通过一个（in a single <code class="literal">DELETE</code>））整个集合，然后再重新创建整个集合。因此 Bag 是非常低效的。 </p><p>请注意：对于一对多关联来说，“主键”很可能并不是数据库表的物理主键。但就算在此情况下，上面的分类仍然是有用的。（它仍然反映了 Hibernate 在集合的各数据行中是如何进行“定位”的。） </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>21.5.2. Lists，maps 和 sets 用于更新效率最高</h3></div></div></div><p>根据我们上面的讨论，显然有序集合类型和大多数 set 都可以在增加、删除、修改元素中拥有最好的性能。 </p><p>可论证的是对于多对多关联、值数据集合而言，有序集合类比集合（set）有一个好处。因为 <code class="literal">Set</code> 的内在结构， 如果“改变”了一个元素，Hibernate 并不会<code class="literal">更新（UPDATE）</code>这一行。对于 <code class="literal">Set</code> 来说，只有在<code class="literal">插入（INSERT）</code>和<code class="literal">删除（DELETE）</code> 操作时“改变”才有效。再次强调：这段讨论对“一对多关联”并不适用。 </p><p>注意到数组无法延迟载入，我们可以得出结论，list，map 和 idbags 是最高效的（非反向）集合类型，set 则紧随其后。 在 Hibernate 中，set 应该时最通用的集合类型，这时因为“set”的语义在关系模型中是最自然的。 </p><p>但是，在设计良好的 Hibernate 领域模型中，我们通常可以看到更多的集合事实上是带有  <code class="literal">inverse="true"</code> 的一对多的关联。对于这些关联，更新操作将会在多对一的这一端进行处理。因此对于此类情况，无需考虑其集合的更新性能。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>21.5.3. Bag 和 list 是反向集合类中效率最高的</h3></div></div></div><p>在把 bag 扔进水沟之前，你必须了解，在一种情况下，bag 的性能（包括list）要比 set 高得多：对于指明了 <code class="literal">inverse="true"</code> 的集合类（比如说，标准的双向的一对多关联），我们可以在未初始化（fetch）包元素的情况下直接向 bag 或 list 添加新元素！ 这是因为 <code class="literal">Collection.add()</code>）或者 <code class="literal">Collection.addAll()</code> 方法对 bag 或者 List 总是返回 true（这点与与 Set 不同）。因此对于下面的相同代码来说，速度会快得多。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_plain">&nbsp;p&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;sess</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">load</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Parent</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;id</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Child</span><span class="java_plain">&nbsp;c&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Child</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">c</span><span class="java_separator">.</span><span class="java_plain">setParent</span><span class="java_separator">(</span><span class="java_plain">p</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">p</span><span class="java_separator">.</span><span class="java_plain">getChildren</span><span class="java_separator">().</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">c</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">no&nbsp;need&nbsp;to&nbsp;fetch&nbsp;the&nbsp;collection</span><span class="java_operator">!</span>
<!--  --><br/><span class="java_plain">sess</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>21.5.4. 一次性删除（One shot delete）</h3></div></div></div><p>偶尔的，逐个删除集合类中的元素是相当低效的。Hibernate 并没那么笨，如果你想要把整个集合都删除（比如说调用 list.clear()），Hibernate 只需要一个 DELETE 就搞定了。 </p><p>假设我们在一个长度为20的集合类中新增加了一个元素，然后再删除两个。Hibernate 会安排一条 <code class="literal">INSERT</code> 语句和两条 <code class="literal">DELETE</code> 语句（除非集合类是一个 bag）。这当然是令人满意的。 </p><p>但是，假设我们删除了 18 个数据，只剩下 2 个，然后新增 3 个。则有两种处理方式：</p><div class="itemizedlist"><ul><li><p>逐一的删除这 18 个数据，再新增三个；</p></li><li><p>删除整个集合类（只用一句 DELETE 语句），然后逐一添加 5 个数据。</p></li></ul></div><p>Hibernate 还没那么聪明，知道第二种选择可能会比较快。（也许让 Hibernate 不这么聪明也是好事，否则可能会引发意外的“数据库触发器”之类的问题。）</p><p>幸运的是，你可以强制使用第二种策略。你需要取消原来的整个集合类（解除其引用），然后再返回一个新的实例化的集合类，只包含需要的元素。有些时候这是非常有用的。 </p><p>显然，一次性删除并不适用于被映射为 <code class="literal">inverse="true"</code> 的集合。 </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>21.6. 监测性能（Monitoring performance）</h2></div></div></div><p>没有监测和性能参数而进行优化是毫无意义的。Hibernate 为其内部操作提供了一系列的示意图，因此可以从 每个 <code class="literal">SessionFactory</code> 抓取其统计数据。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>21.6.1. 监测 SessionFactory</h3></div></div></div><p>你可以有两种方式访问 <code class="literal">SessionFactory</code> 的数据记录，第一种就是自己直接调用 <code class="literal">sessionFactory.getStatistics()</code> 方法读取、显示<code class="literal">统计</code>数据。</p><p>此外，如果你打开 <code class="literal">StatisticsService</code> MBean 选项，那么 Hibernate 则可以使用 JMX 技术 发布其数据记录。你可以让应用中所有的 <code class="literal">SessionFactory</code> 同时共享一个 MBean，也可以每个 SessionFactory 分配一个 MBean。下面的代码即是其演示代码： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;a&nbsp;specific&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;sessionFactory&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;myFinancialApp&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;tb</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;object&nbsp;name</span>
</span>
<!--  --><br/><span class="java_type">StatisticsService</span><span class="java_plain">&nbsp;stats&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StatisticsService</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">stats</span><span class="java_separator">.</span><span class="java_plain">setSessionFactory</span><span class="java_separator">(</span><span class="java_plain">sessionFactory</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Bind</span><span class="java_plain">&nbsp;the&nbsp;stats&nbsp;to&nbsp;a&nbsp;</span><span class="java_type">SessionFactory</span>
<!--  --><br/><span class="java_plain">server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">stats</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Register</span><span class="java_plain">&nbsp;the&nbsp;</span><span class="java_type">Mbean</span><span class="java_plain">&nbsp;on&nbsp;the&nbsp;server</span></pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">MBean</span><!-- <br/> --><span class="java_plain">&nbsp;service&nbsp;registration&nbsp;</span><!-- <br/> --><span class="java_keyword">for</span><!-- <br/> --><span class="java_plain">&nbsp;all&nbsp;</span><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">'s</span>
<!--  --><br/><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;tb&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">Hashtable</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;type&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;statistics&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">tb</span><span class="java_separator">.</span><span class="java_plain">put</span><span class="java_separator">(</span><span class="java_literal">&quot;sessionFactory&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;all&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">ObjectName</span><span class="java_plain">&nbsp;on&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectName</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;tb</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;object&nbsp;name</span>
</span>
<!--  --><br/><span class="java_type">StatisticsService</span><span class="java_plain">&nbsp;stats&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StatisticsService</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;implementation</span>
<!--  --><br/><span class="java_plain">server</span><span class="java_separator">.</span><span class="java_plain">registerMBean</span><span class="java_separator">(</span><span class="java_plain">stats</span><span class="java_separator">,</span><span class="java_plain">&nbsp;on</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Register</span><span class="java_plain">&nbsp;the&nbsp;</span><span class="java_type">MBean</span><span class="java_plain">&nbsp;on&nbsp;the&nbsp;server</span></pre><p>你可以通过以下方法打开或关闭 <code class="literal">SessionFactory</code> 的监测功能： </p><div class="itemizedlist"><ul><li><p>在配置期间，将 <code class="literal">hibernate.generate_statistics</code> 设置为 <code class="literal">true</code> 或 <code class="literal">false</code>；</p></li></ul></div><div class="itemizedlist"><ul><li><p>在运行期间，则可以可以通过 <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> 或 <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code></p></li></ul></div><p>你也可以在程序中调用 <code class="literal">clear()</code> 方法重置统计数据，调用 <code class="literal">logSummary()</code> 在日志中记录（info 级别）其总结。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>21.6.2. 数据记录（Metrics）</h3></div></div></div><p>Hibernate 提供了一系列数据记录，其记录的内容包括从最基本的信息到与具体场景的特殊信息。所有的测量值都可以由 <code class="literal">Statistics</code> 接口 API 进行访问，主要分为三类：</p><div class="itemizedlist"><ul><li><p>使用 <code class="literal">Session</code> 的普通数据记录，例如打开的 Session 的个数、取得的 JDBC 的连接数等；</p></li><li><p>实体、集合、查询、缓存等内容的统一数据记录。</p></li><li><p>和具体实体、集合、查询、缓存相关的详细数据记录</p></li></ul></div><p>例如：你可以检查缓存的命中成功次数，缓存的命中失败次数，实体、集合和查询的使用概率，查询的平均时间等。请注意 Java 中时间的近似精度是毫秒。Hibernate 的数据精度和具体的 JVM 有关，在有些平台上其精度甚至只能精确到 10 秒。 </p><p>你可以直接使用 getter 方法得到全局数据记录（例如，和具体的实体、集合、缓存区无关的数据），你也可以在具体查询中通过标记实体名、 或 HQL、SQL 语句得到某实体的数据记录。请参考 <code class="literal">Statistics</code>、<code class="literal">EntityStatistics</code>、<code class="literal">CollectionStatistics</code>、<code class="literal">SecondLevelCacheStatistics</code> 和 <code class="literal">QueryStatistics</code> 的 API 文档以抓取更多信息。下面的代码则是个简单的例子： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Statistics</span><!-- <br/> --><span class="java_plain">&nbsp;stats&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">HibernateUtil</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">sessionFactory</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getStatistics</span><!-- <br/> --><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheHitCount&nbsp;&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getQueryCacheHitCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheMissCount&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getQueryCacheMissCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">double</span><span class="java_plain">&nbsp;queryCacheHitRatio&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;queryCacheHitCount&nbsp;</span><span class="java_operator">/</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">queryCacheHitCount&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;queryCacheMissCount</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">log</span><span class="java_separator">.</span><span class="java_plain">info</span><span class="java_separator">(</span><span class="java_literal">&quot;Query&nbsp;Hit&nbsp;ratio:&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;queryCacheHitRatio</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_type">EntityStatistics</span><span class="java_plain">&nbsp;entityStats&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;stats</span><span class="java_separator">.</span><span class="java_plain">getEntityStatistics</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">long</span><span class="java_plain">&nbsp;changes&nbsp;</span><span class="java_operator">=</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getInsertCount</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getUpdateCount</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;entityStats</span><span class="java_separator">.</span><span class="java_plain">getDeleteCount</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">log</span><span class="java_separator">.</span><span class="java_plain">info</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">.</span><span class="java_plain">getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;&nbsp;changed&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;changes&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;times&quot;</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">);</span></pre><p>如果你想得到所有实体、集合、查询和缓存区的数据，你可以通过以下方法获得实体、集合、查询和缓存区列表：<code class="literal">getQueries()</code>、<code class="literal">getEntityNames()</code>、<code class="literal">getCollectionRoleNames()</code> 和 <code class="literal">getSecondLevelCacheRegionNames()</code>。</p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>上一页</strong>第 20 章 XML 映射</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>下一页</strong>第 22 章 工具箱指南</a></li></ul></body></html>