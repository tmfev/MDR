<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 28 章 数据库移植性考量</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="best-practices.html" title="第 27 章 最佳实践（Best Practices）"/><link rel="next" href="bi01.html" title="参考资料"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>第 28 章 数据库移植性考量</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="portability.html#portability-basics">28.1. 移植性基础</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialect">28.2. Dialect</a></span></dt><dt><span class="section"><a href="portability.html#portability-dialectresolver">28.3. 方言的使用</a></span></dt><dt><span class="section"><a href="portability.html#portability-idgen">28.4. 标识符的生成</a></span></dt><dt><span class="section"><a href="portability.html#portability-functions">28.5. 数据库函数</a></span></dt><dt><span class="section"><a href="portability.html#portability-types">28.6. 类型映射</a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>28.1. 移植性基础</h2></div></div></div><p>Hibernate（实际上是整个 Object/Relational Mapping）的一个卖点是数据库的移植性。这意味着内部的 IT 用户可以改变数据库供应商，或者可部署的应用程序/框架使用 Hibernate 来同时使用多个数据库产品。不考虑具体的应用情景，这里的基本概念是 Hibernate 可帮助你运行多种数据库而无需修改你的代码，理想情况下甚至不用修改映射元数据。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>28.2. Dialect</h2></div></div></div><p>Hibernate 的移植性的首要问题是方言（dialect），也就是 <code class="classname">org.hibernate.dialect.Dialect</code> 合约的具体实例。方言封装了 Hibernate 和特定数据库通讯以完成某些任务如获取序列值或构建 SELECT 查询等的所有差异。Hibernate 捆绑了用于许多最常用的数据库的方言。如果你发现自己使用的数据库不在其中，编写自定义的方言也不是很困难的事情。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>28.3. 方言的使用</h2></div></div></div><p>最开始，Hibernate 总是要求用户指定所使用的方言（dialect）。在用户希望同时使用多个数据库时就会出现问题。通常这要求用户配置 Hibernate 方言或者定义自己设置这个值的方法。 </p><p>从版本 3.2 开始，Hibernate 引入了方言的自动检测，它基于从该数据库的 <code class="interfacename">java.sql.Connection</code> 上获得的 <code class="interfacename">java.sql.DatabaseMetaData</code>。这是一个更好的方案，但它局限于 Hibernate 已知的数据库且无法进行配置和覆盖。 </p><p>Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Dialect</span><!-- <br/> --><span class="java_plain">&nbsp;resolveDialect</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">DatabaseMetaData</span><!-- <br/> --><span class="java_plain">&nbsp;metaData</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">throws</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">JDBCConnectionException</span></pre><p>The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver. </p><p>这些解析者最棒的功能是用户也可以注册自定义的解析者，它们将在内置的解析者之前被调用。在许多情况下这可能很有用：它可以轻易地集成内置方言之外的方言的自动检测；它让你可以使用自定义的方言等。要注册一个或多个解析者，只要用 'hibernate.dialect_resolvers' 配置设置指定它们（由逗号、制表符或空格隔开）就可以了（请参考 <code class="classname">org.hibernate.cfg.Environment</code> 上的 <code class="constant">DIALECT_RESOLVERS</code>）。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>28.4. 标识符的生成</h2></div></div></div><p>When considering portability between databases, another important decision is selecting the identifier generation stratagy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy becauase the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entitiy be associated with the session (like via save() e.g.) regardless of current transactional semantics. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p> Hibernate was changed slightly once the implication of this was better understood so that the insert is delayed in cases where that is feasible. </p></div><p> The underlying issue is that the actual semanctics of the application itself changes in these cases. </p><p>Starting with version 3.2.3, Hibernate comes with a set of <a class="ulink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting portability in a much different way. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p> There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: </p><div class="itemizedlist"><ul><li><p> <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> </p></li><li><p> <code class="classname">org.hibernate.id.enhanced.TableGenerator</code> </p></li></ul></div><p> </p></div><p> The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table. </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>28.5. 数据库函数</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>警告</h2><p>这是 Hibernate 需要提高的一个领域。从可移植性来说，这个功能可以很好地处理 HQL 的内容，但在其他方面就有所欠缺。 </p></div><p>用户可以以多种方式引用 SQL 函数。然而，不是所有的数据库都支持相同的函数集。Hibernate 提供了一种映射<span class="emphasis"><em>逻辑</em></span>函数名到代理的方法，这个代理知道如何解析特定的函数，甚至可能使用完全不同的物理函数调用。  </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>从技术上来讲，这个函数注册是通过 <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code> 类进行处理的，它的目的是允许用户提供自定义的函数定义而无需提供自定义的方言。这种特殊的行为目前还未全部开发完毕。 </p><p>其中一些功能已经实现，如用户可以在程序里用 <code class="classname">org.hibernate.cfg.Configuration</code> 注册函数且这些函数可被 HQL 识别。 </p></div><p>
        </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>28.6. 类型映射</h2></div></div></div><p>本节内容仍未完成... </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="best-practices.html"><strong>上一页</strong>第 27 章 最佳实践（Best Practices）</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="bi01.html"><strong>下一页</strong>参考资料</a></li></ul></body></html>