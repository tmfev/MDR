<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 16 章 HQL: Hibernate 查询语言</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="batch.html" title="第 15 章 批量处理（Batch processing）"/><link rel="next" href="querycriteria.html" title="第 17 章 条件查询（Criteria Queries）"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>第 16 章 HQL: Hibernate 查询语言</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="queryhql.html#queryhql-casesensitivity">16.1. 大小写敏感性问题</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-from">16.2. from 子句</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins">16.3. 关联（Association）与连接（Join）</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-joins-forms">16.4. join 语法的形式</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-identifier-property">16.5. 引用 identifier 属性 </a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-select">16.6. select 子句</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-aggregation">16.7. 聚集函数</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-polymorphism">16.8. 多态查询</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-where">16.9. where 子句</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-expressions">16.10. 表达式</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-ordering">16.11. order by 子句</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-grouping">16.12. group by 子句</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-subqueries">16.13. 子查询</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-examples">16.14. HQL 示例 </a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-bulk">16.15. 批量的 UPDATE 和 DELETE</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tipstricks">16.16. 小技巧 &amp; 小窍门</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-components">16.17. 组件</a></span></dt><dt><span class="section"><a href="queryhql.html#queryhql-tuple">16.18. Row value 构造函数语法</a></span></dt></dl></div><p>Hibernate 配备了一种非常强大的查询语言，这种语言看上去很像 SQL。但是不要被语法结构上的相似所迷惑，HQL 是非常有意识的被设计为完全面向对象的查询，它可以理解如继承、多态和关联之类的概念。  </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>16.1. 大小写敏感性问题</h2></div></div></div><p>除了 Java 类与属性的名称外，查询语句对大小写并不敏感。 所以 <code class="literal">SeLeCT</code> 与 <code class="literal">sELEct</code> 以及 <code class="literal">SELECT</code> 是相同的，但是 <code class="literal">org.hibernate.eg.FOO</code> 并不等价于 <code class="literal">org.hibernate.eg.Foo</code> 并且 <code class="literal">foo.barSet</code> 也不等价于 <code class="literal">foo.BARSET</code>。  </p><p>本手册中的 HQL 关键字将使用小写字母。很多用户发现使用完全大写的关键字会使查询语句的可读性更强，但我们发现，当把查询语句嵌入到 Java 语句中的时候使用大写关键字比较难看。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>16.2. from 子句</h2></div></div></div><p>Hibernate 中最简单的查询语句的形式如下： </p><pre class="programlisting">from eg.Cat</pre><p>该子句简单的返回 <code class="literal">eg.Cat</code> 类的所有实例。通常我们不需要使用类的全限定名，因为  <code class="literal">auto-import</code>（自动引入）是缺省的情况。所以我们几乎只使用如下的简单写法：  </p><pre class="programlisting">from Cat</pre><p>为了在这个查询的其他部分里引用 <code class="literal">Cat</code>，你将需要分配一个<span class="emphasis"><em>别名</em></span>。例如： </p><pre class="programlisting">from Cat as cat</pre><p>这个语句把别名 <code class="literal">cat</code> 指定给类<code class="literal">Cat</code> 的实例，这样我们就可以在随后的查询中使用此别名了。关键字 <code class="literal">as</code> 是可选的，我们也可以这样写：  </p><pre class="programlisting">from Cat cat</pre><p>子句中可以同时出现多个类，其查询结果是产生一个笛卡儿积或产生跨表的连接。  </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>查询语句中别名的开头部分小写被认为是实践中的好习惯，这样做与 Java 变量的命名标准保持了一致（比如，<code class="literal">domesticCat</code>）。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>16.3. 关联（Association）与连接（Join）</h2></div></div></div><p>我们也可以为相关联的实体甚至是对一个集合中的全部元素指定一个别名，这时要使用关键字 <code class="literal">join</code>。  </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>受支持的连接类型是从 ANSI SQL 中借鉴来的： </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">inner join</code>
                </p></li><li><p>
                    <code class="literal">left outer join</code>
                </p></li><li><p>
                    <code class="literal">right outer join</code>
                </p></li><li><p><code class="literal">full join</code>（全连接，并不常用） </p></li></ul></div><p>语句 <code class="literal">inner join</code>，<code class="literal">left outer join</code> 以及 <code class="literal">right outer join</code> 可以简写。 </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>通过 HQL 的 <code class="literal">with</code> 关键字，你可以提供额外的 join 条件。 </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight 
&gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a class="xref" href="performance.html#performance-fetching" title="21.1. 抓取策略（Fetching strategies）">第 21.1 节 “抓取策略（Fetching strategies）”</a> for more information. </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>一个 fetch 连接通常不需要被指定别名，因为相关联的对象不应当被用在 <code class="literal">where</code> 子句（或其它任何子句）中。同时，相关联的对象并不在查询的结果中直接返回，但可以通过他们的父对象来访问到他们。  </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>假若使用 <code class="literal">iterate()</code> 来调用查询，请注意 <code class="literal">fetch</code> 构造是不能使用的（<code class="literal">scroll()</code> 可以使用）。<code class="literal">fetch</code> 也不应该与 <code class="literal">setMaxResults()</code> 或 <code class="literal">setFirstResult()</code> 共用，这是因为这些操作是基于结果集的，而在预先抓取集合类时可能包含重复的数据，也就是说无法预先知道精确的行数。<code class="literal">fetch</code> 还不能与独立的 <code class="literal">with</code> 条件一起使用。通过在一次查询中 fetch 多个集合，可以制造出笛卡尔积，因此请多加注意。对 bag 映射来说，同时 join fetch 多个集合角色可能在某些情况下给出并非预期的结果，也请小心。最后注意，使用 <code class="literal">full join fetch</code> 与 <code class="literal">right join fetch</code> 是没有意义的。  </p><p>如果你使用属性级别的延迟获取（lazy fetching）（这是通过重新编写字节码实现的），可以使用  <code class="literal">fetch all properties</code> 来强制 Hibernate 立即取得那些原本需要延迟加载的属性（在第一个查询中）。  </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>16.4. join 语法的形式</h2></div></div></div><p>HQL 支持两种关联 join 的形式：<code class="literal">implicit（隐式）</code> 与 <code class="literal">explicit（显式）</code>。 </p><p>上一节中给出的查询都是使用 <code class="literal">explicit（显式）</code>形式的，其中 form 子句中明确给出了 join 关键字。这是建议使用的方式。  </p><p><code class="literal">implicit（隐式）</code>形式不使用 join 关键字。关联使用"点号"来进行“引用”。<code class="literal">implicit</code> join 可以在任何 HQL 子句中出现。<code class="literal">implicit</code> join 在最终的 SQL 语句中以 inner join 的方式出现。 </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>16.5. 引用 identifier 属性 </h2></div></div></div><p>通常有两种方法来引用实体的 identifier 属性：  </p><div class="itemizedlist"><ul compact="compact"><li><p>特殊属性（lowercase）<code class="literal">id</code> 可以用来引用实体的 identifier 属性 <span class="emphasis"><em>假设这个实体没有定义用 non-identifier 属性命名的 id</em></span>。  </p></li><li><p>如果这个实体定义了 identifier 属性，你可以使用属性名。  </p></li></ul></div><p>对组合 identifier 属性的引用遵循相同的命名规则。如果实体有一个 non-identifier 属性命名的 id，这个组合 identifier 属性只能用自己定义的名字来引用；否则，特殊 <code class="literal">id</code> 属性可以用来引用 identifier 属性。  </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>注意：从 3.2.2 版本开始，这已经改变了很多。在前面的版本里，不管实际的名字，<code class="literal">id</code> <span class="emphasis"><em>总是</em></span>指向 identifier 属性；而用 non-identifier 属性命名的 <code class="literal">id</code> 就从来不在 Hibernate 查询里引用。   </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>16.6. select 子句</h2></div></div></div><p><code class="literal">select</code> 子句选择将哪些对象与属性返回到查询结果集中。考虑如下情况： </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>该语句将选择其它 <code class="literal">Cat</code> 的 <code class="literal">mate</code>（其他猫的配偶）。实际上，你可以更简洁的用以下的查询语句表达相同的含义：  </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>查询语句可以返回值为任何类型的属性，包括返回类型为某种组件（Component）的属性：  </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>查询语句可以返回多个对象和（或）属性，存放在 <code class="literal">Object[]</code> 队列中，  </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>或存放在一个 <code class="literal">List</code> 对象中： </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>假设类 <code class="literal">Family</code> 有一个合适的构造函数 - 作为实际的类型安全的 Java 对象： </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>你可以使用关键字 <code class="literal">as</code> 给“被选择了的表达式”指派别名：  </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>这种做法在与子句 <code class="literal">select new map</code> 一起使用时最有用： </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>该查询返回了一个 <code class="literal">Map</code> 的对象，内容是别名与被选择的值组成的名-值映射。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>16.7. 聚集函数</h2></div></div></div><p>HQL 查询甚至可以返回作用于属性之上的聚集函数的计算结果：  </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>受支持的聚集函数如下：  </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>你可以在选择子句中使用数学操作符、连接以及经过验证的 SQL 函数：  </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>关键字 <code class="literal">distinct</code> 与 <code class="literal">all</code> 也可以使用，它们具有与 SQL 相同的语义。  </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>16.8. 多态查询</h2></div></div></div><p>一个如下的查询语句： </p><pre class="programlisting">from Cat as cat</pre><p>不仅返回 <code class="literal">Cat</code> 类的实例，也同时返回子类 <code class="literal">DomesticCat</code> 的实例。Hibernate 可以在 <code class="literal">from</code> 子句中指定<span class="emphasis"><em>任何</em></span> Java 类或接口。查询会返回继承了该类的所有持久化子类的实例或返回声明了该接口的所有持久化类的实例。下面的查询语句返回所有的被持久化的对象：  </p><pre class="programlisting">from java.lang.Object o</pre><p>接口 <code class="literal">Named</code> 可能被各种各样的持久化类声明： </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>注意，最后的两个查询将需要超过一个的 SQL <code class="literal">SELECT</code>。这表明 <code class="literal">order by</code> 子句没有对整个结果集进行正确的排序。（这也说明你不能对这样的查询使用 <code class="literal">Query.scroll()</code> 方法。） </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>16.9. where 子句</h2></div></div></div><p><code class="literal">where</code> 子句允许你将返回的实例列表的范围缩小。如果没有指定别名，你可以使用属性名来直接引用属性：  </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>如果指派了别名，需要使用完整的属性名： </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>返回名为（属性 name 等于）'Fritz' 的 <code class="literal">Cat</code> 类的实例。  </p><p>下面的查询： </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p>将返回所有满足下面条件的 <code class="literal">Foo</code> 类的实例： 存在如下的 <code class="literal">bar</code> 的一个实例，其 <code class="literal">date</code> 属性等于 <code class="literal">Foo</code> 的 <code class="literal">startDate</code> 属性。复合路径表达式使得 <code class="literal">where</code> 子句非常的强大，考虑如下情况：  </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>该查询将被翻译成为一个含有表连接（内连接）的 SQL 查询。如果你打算写像这样的查询语句： </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>在 SQL 中，你为达此目的将需要进行一个四表连接的查询。  </p><p><code class="literal">=</code> 运算符不仅可以被用来比较属性的值，也可以用来比较实例：  </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. 引用 identifier 属性">第 16.5 节 “引用 identifier 属性 ”</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>第二个查询是有效的。此时不需要进行表连接。 </p><p>同样也可以使用复合标识符。比如 <code class="literal">Person</code> 类有一个复合标识符，它由 <code class="literal">country</code> 属性与 <code class="literal">medicareNumber</code> 属性组成： </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>第二个查询也不需要进行表连接。  </p><p>See <a class="xref" href="queryhql.html#queryhql-identifier-property" title="16.5. 引用 identifier 属性">第 16.5 节 “引用 identifier 属性 ”</a> for more information regarding referencing identifier properties) </p><p>同样的，特殊属性 <code class="literal">class</code> 在进行多态持久化的情况下被用来存取一个实例的鉴别值（discriminator value）。一个嵌入到 where 子句中的 Java 类的名字将被转换为该类的鉴别值。  </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a class="xref" href="queryhql.html#queryhql-components" title="16.17. 组件">第 16.17 节 “组件”</a> for more information. </p><p>一个“任意”类型有两个特殊的属性 <code class="literal">id</code> 和 <code class="literal">class</code>，来允许我们按照下面的方式表达一个连接（<code class="literal">AuditLog.item</code> 是一个属性，该属性被映射为 <code class="literal">&lt;any&gt;</code>）。  </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>注意，在上面的查询与句中，<code class="literal">log.item.class</code> 和 <code class="literal">payment.class</code> 将涉及到完全不同的数据库中的列。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>16.10. 表达式</h2></div></div></div><p>在 <code class="literal">where</code> 子句中允许使用的表达式包括 大多数你可以在 SQL 使用的表达式种类：  </p><div class="itemizedlist"><ul compact="compact"><li><p>数学运算符 <code class="literal">+，-，*，/</code>  </p></li><li><p>二进制比较运算符 <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code>  </p></li><li><p>逻辑运算符 <code class="literal">and，or，not</code> </p></li><li><p>括号 <code class="literal">( )</code>，表示分组  </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> and <code class="literal">not member of</code> </p></li><li><p>"Simple" case, <code class="literal">case ... when ... then ... else ... end</code>, and "searched" case, <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>字符串连接符 <code class="literal">...||...</code> or <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code>, and <code class="literal">current_timestamp()</code> </p></li><li><p><code class="literal">second(...)</code>、<code class="literal">minute(...)</code>、<code class="literal">hour(...)</code>、<code class="literal">day(...)</code>、<code class="literal">month(...)</code> 和 <code class="literal">year(...)</code> </p></li><li><p>EJB-QL 3.0 定义的任何功能或操作符：<code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</code> </p></li><li><p><code class="literal">coalesce()</code> 和 <code class="literal">nullif()</code> </p></li><li><p><code class="literal">str()</code> 把数字或者时间值转换为可读的字符串 </p></li><li><p><code class="literal">cast(... as ...)</code>，其第二个参数是某 Hibernate 类型的名字，以及 <code class="literal">extract(... from ...)</code>，只要 ANSI <code class="literal">cast()</code> 和  <code class="literal">extract()</code> 被底层数据库支持 </p></li><li><p>HQL <code class="literal">index()</code> 函数，作用于 join 的有序集合的别名。 </p></li><li><p>HQL 函数，把集合作为参数：<code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>，还有特别的 <code class="literal">elements()</code> 和 <code class="literal">indices</code> 函数，可以与数量词加以限定：<code class="literal">some, all, exists, any, in</code>。  </p></li><li><p>任何数据库支持的 SQL 标量函数，比如 <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code>, <code class="literal">sin()</code>  </p></li><li><p>JDBC 风格的参数传入 <code class="literal">?</code> </p></li><li><p>命名参数 <code class="literal">:name</code>，<code class="literal">:start_date</code>，<code class="literal">:x1</code>  </p></li><li><p>SQL 直接常量 <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">6.66E+2</code>, <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>Java <code class="literal">public static final</code> 类型的常量 <code class="literal">eg.Color.TABBY</code> </p></li></ul></div><p>关键字 <code class="literal">in</code> 与 <code class="literal">between</code> 可按如下方法使用：  </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>而且否定的格式也可以如下书写：  </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>同样，子句 <code class="literal">is null</code> 与 <code class="literal">is not null</code> 可以被用来测试空值（null）。  </p><p>在 Hibernate 配置文件中声明 HQL“查询替代（query substitutions）”之后，布尔表达式（Booleans）可以在其他表达式中轻松的使用：  </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"
&gt;true 1, false 0&lt;/property
&gt;</pre><p>系统将该 HQL 转换为 SQL 语句时，该设置表明将用字符 <code class="literal">1</code> 和  <code class="literal">0</code> 来取代关键字 <code class="literal">true</code> 和 <code class="literal">false</code>： </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>你可以用特殊属性 <code class="literal">size</code>，或是特殊函数 <code class="literal">size()</code> 测试一个集合的大小。  </p><pre class="programlisting">from Cat cat where cat.kittens.size 
&gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) 
&gt; 0</pre><p>对于索引了（有序）的集合，你可以使用 <code class="literal">minindex</code> 与  <code class="literal">maxindex</code> 函数来引用到最小与最大的索引序数。同理，你可以使用 <code class="literal">minelement</code> 与 <code class="literal">maxelement</code> 函数来引用到一个基本数据类型的集合中最小与最大的元素。例如： </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) 
&gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) 
&gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) 
&gt; 10000</pre><p>在传递一个集合的索引集或者是元素集（<code class="literal">elements</code> 与 <code class="literal">indices</code> 函数）或者传递一个子查询的结果的时候，可以使用 SQL 函数 <code class="literal">any, some，all, exists, in</code>： </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 
&gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>注意，在 Hibernate3 中，这些结构变量 —  <code class="literal">size</code>，<code class="literal">elements</code>，<code class="literal">indices</code>，<code class="literal">minindex</code>，<code class="literal">maxindex</code>，<code class="literal">minelement</code>，<code class="literal">maxelement</code> — 只能在 where 子句中使用。  </p><p>一个被索引过的（有序的）集合的元素（arrays，lists，maps）可以在其他索引中被引用（只能在 where 子句中）：  </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>在 <code class="literal">[]</code> 中的表达式甚至可以是一个算数表达式： </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>对于一个一对多的关联（one-to-many association）或是值的集合中的元素，HQL 也提供内建的 <code class="literal">index()</code> 函数。 </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>如果底层数据库支持标量的 SQL 函数，它们也可以被使用： </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>如果你还不能对所有的这些深信不疑，想想下面的查询。如果使用 SQL，语句长度会增长多少，可读性会下降多少：  </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>提示：</em></span> 会像如下的语句 </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>16.11. order by 子句</h2></div></div></div><p>查询返回的列表（list）可以按照一个返回的类或组件（components）中的任何属性（property）进行排序：  </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>可选的 <code class="literal">asc</code> 或 <code class="literal">desc</code> 关键字指明了按照升序或降序进行排序。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>16.12. group by 子句</h2></div></div></div><p>一个返回聚集值（aggregate values）的查询可以按照一个返回的类或组件（components）中的任何属性（property）进行分组：  </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p><code class="literal">having</code> 子句在这里也允许使用。 </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>如果底层的数据库支持的话（例如不能在 MySQL 中使用），SQL 的一般函数与聚集函数也可以出现在 <code class="literal">having</code> 与 <code class="literal">order by</code> 子句中。  </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.name, cat.other, cat.properties
having avg(kitten.weight) 
&gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>注意 <code class="literal">group by</code> 子句与 <code class="literal">order by</code> 子句中都不能包含算术表达式（arithmetic expressions）。也要注意 Hibernate 目前不会扩展 group 的实体，因此你不能写 <code class="literal">group by cat</code>，除非 <code class="literal">cat</code> 的所有属性都不是聚集的（non-aggregated）。你必须明确的列出所有的非聚集属性。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>16.13. 子查询</h2></div></div></div><p>对于支持子查询的数据库，Hibernate 支持在查询中使用子查询。一个子查询必须被圆括号包围起来（经常是 SQL 聚集函数的圆括号）。甚至相互关联的子查询（引用到外部查询中的别名的子查询）也是允许的。 </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight 
&gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>注意，HQL 自查询只可以在 select 或者 where 子句中出现。  </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a class="xref" href="queryhql.html#queryhql-tuple" title="16.18. Row value 构造函数语法">第 16.18 节 “Row value 构造函数语法”</a> for more information. </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>16.14. HQL 示例 </h2></div></div></div><p>Hibernate 查询可以非常的强大与复杂。实际上，Hibernate 的一个主要卖点就是查询语句的威力。这里有一些例子，它们与我在最近的一个项目中使用的查询非常相似。注意你能用到的大多数查询比这些要简单的多。 </p><p>下面的查询对于某个特定的客户的所有未支付的账单，在给定给最小总价值的情况下，返回订单的 id，条目的数量和总价值，返回值按照总价值的结果进行排序。为了决定价格，查询使用了当前目录。作为转换结果的 SQL 查询，使用了<code class="literal">ORDER</code>，<code class="literal">ORDER_LINE</code>，<code class="literal">PRODUCT</code>，<code class="literal">CATALOG</code> 和 <code class="literal">PRICE</code> 库表。 </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate 
&gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>这简直是一个怪物！实际上，在现实生活中，我并不热衷于子查询，所以我的查询语句看起来更像这个： </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>下面一个查询计算每一种状态下的支付的数目，除去所有处于 <code class="literal">AWAITING_APPROVAL</code> 状态的支付，因为在该状态下 当前的用户作出了状态的最新改变。该查询被转换成含有两个内连接以及一个相关联的子选择的 SQL 查询，该查询使用了表 <code class="literal">PAYMENT</code>，<code class="literal">PAYMENT_STATUS</code> 以及  <code class="literal">PAYMENT_STATUS_CHANGE</code>。 </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;
&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>如果我把 <code class="literal">statusChanges</code> 实例集映射为一个列表（list）而不是一个集合（set），书写查询语句将更加简单。  </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;
&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>下面一个查询使用了 MS SQL Server 的 <code class="literal">isNull()</code> 函数用以返回当前用户所属组织的组织帐号及组织未支付的账。它被转换成一个对表 <code class="literal">ACCOUNT</code>，<code class="literal">PAYMENT</code>，<code class="literal">PAYMENT_STATUS</code>，<code class="literal">ACCOUNT_TYPE</code>，<code class="literal">ORGANIZATION</code>  以及 <code class="literal">ORG_USER</code> 进行的三个内连接，一个外连接和一个子选择的 SQL 查询。 </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>对于一些数据库，我们需要弃用（相关的）子选择。 </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>16.15. 批量的 UPDATE 和 DELETE</h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a class="xref" href="batch.html#batch-direct" title="15.4. DML（数据操作语言）风格的操作（DML-style operations）">第 15.4 节 “DML（数据操作语言）风格的操作（DML-style operations）”</a> for more information. </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>16.16. 小技巧 &amp; 小窍门</h2></div></div></div><p>你可以统计查询结果的数目而不必实际的返回他们：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">()</span></pre><p>若想根据一个集合的大小来进行排序，可以使用如下的语句： </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>如果你的数据库支持子选择，你可以在你的查询的 where 子句中为选择的大小（selection size）指定一个条件： </p><pre class="programlisting">from User usr where size(usr.messages) 
&gt;= 1</pre><p>如果你的数据库不支持子选择语句，使用下面的查询：  </p><pre class="programlisting">select usr.id, usr.name
from User usr
    join usr.messages msg
group by usr.id, usr.name
having count(msg) 
&gt;= 1</pre><p>因为内连接（inner join）的原因，这个解决方案不能返回含有零个信息的 <code class="literal">User</code> 类的实例，所以这种情况下使用下面的格式将是有帮助的：  </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>JavaBean 的属性可以被绑定到一个命名查询（named query）的参数上： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;from&nbsp;foo&nbsp;Foo&nbsp;as&nbsp;foo&nbsp;where&nbsp;foo.name=:name&nbsp;and&nbsp;foo.size=:size&quot;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setProperties</span><span class="java_separator">(</span><span class="java_plain">fooBean</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;fooBean&nbsp;has&nbsp;getName</span><span class="java_separator">()</span><span class="java_plain">&nbsp;and&nbsp;getSize</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;foos&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>通过将接口 <code class="literal">Query</code> 与一个过滤器（filter）一起使用，集合（Collections）是可以分页的： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Query</span><!-- <br/> --><span class="java_plain">&nbsp;q&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createFilter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;the&nbsp;trivial&nbsp;filter</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setMaxResults</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">q</span><span class="java_separator">.</span><span class="java_plain">setFirstResult</span><span class="java_separator">(</span><span class="java_plain">PAGE_SIZE&nbsp;</span><span class="java_operator">*</span><span class="java_plain">&nbsp;pageNumber</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">List</span><span class="java_plain">&nbsp;page&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;q</span><span class="java_separator">.</span><span class="java_plain">list</span><span class="java_separator">();</span></pre><p>通过使用查询过滤器（query filter）可以将集合（Collection）的元素分组或排序：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Collection</span><!-- <br/> --><span class="java_plain">&nbsp;orderedCollection&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;s</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">filter</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;collection</span><!-- <br/> --><span class="java_separator">,</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_literal">&quot;order&nbsp;by&nbsp;this.amount&quot;</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">);</span>
<!--  --><br/><span class="java_type">Collection</span><span class="java_plain">&nbsp;counts&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;s</span><span class="java_separator">.</span><span class="java_plain">filter</span><span class="java_separator">(</span><span class="java_plain">&nbsp;collection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;select&nbsp;this.type,&nbsp;count(this)&nbsp;group&nbsp;by&nbsp;this.type&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span></pre><p>不用通过初始化，你就可以知道一个集合（Collection）的大小： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_type">Integer</span><!-- <br/> --><span class="java_separator">)</span><!-- <br/> --><span class="java_plain">&nbsp;session</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">createQuery</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_literal">&quot;select&nbsp;count(*)&nbsp;from&nbsp;....&quot;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">iterate</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">next</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">).</span><!-- <br/> --><span class="java_plain">intValue</span><!-- <br/> --><span class="java_separator">();</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>16.17. 组件</h2></div></div></div><p>在 HQL 查询里，组件可以和简单值类型一样使用。它们可以出现在 <code class="literal">select</code> 子句里：  </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>在这里，Person 的 name 属性是一个组件。组件也可以用在 <code class="literal">where</code> 子句里： </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>组件也可以用在 <code class="literal">order by</code> 子句里： </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>组件的另外一个常见用法是在 <a class="xref" href="queryhql.html#queryhql-tuple" title="16.18. Row value 构造函数语法">第 16.18 节 “Row value 构造函数语法”</a> 行值（row value）构造函数里。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>16.18. Row value 构造函数语法</h2></div></div></div><p>HQL 支持 ANSI SQL <code class="literal">row value constructor</code> 语法（有时也叫作 <code class="literal">tuple</code> 语法），即使底层数据库可能不支持这个概念。在这里我们通常指的是多值（multi-valued）的比较，典型地是和组件相关联。来看看一个定义了 name 组件的实体 Person： </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>那是有效的语法，虽然有点冗长。我们可以使它更加简洁一点，并使用 <code class="literal">row value constructor</code> 语法：  </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p>在 <code class="literal">select</code> 子句里指定这个也是很有用的： </p><pre class="programlisting">select p.name from Person p</pre><p>当使用需要比较多个值的子查询时，采用 <code class="literal">row value constructor</code> 语法也很有用处：  </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>决定是否使用这个语法的一件因素就是：这个查询将依赖于元数据里的组件子属性（sub-properties）的顺序。  </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="batch.html"><strong>上一页</strong>第 15 章 批量处理（Batch processing）</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="querycriteria.html"><strong>下一页</strong>第 17 章 条件查询（Criteria Queries）</a></li></ul></body></html>