<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 3 章 配置</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="architecture.html" title="第 2 章 体系结构（Architecture）"/><link rel="next" href="persistent-classes.html" title="第 4 章 持久化类（Persistent Classes）"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="architecture.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="persistent-classes.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="session-configuration"/>第 3 章 配置</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="session-configuration.html#configuration-programmatic">3.1. 可编程的配置方式</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-sessionfactory">3.2. 获得 SessionFactory</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-hibernatejdbc">3.3. JDBC 连接</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional">3.4. 可选的配置属性</a></span></dt><dd><dl><dt><span class="section"><a href="session-configuration.html#configuration-optional-dialects">3.4.1. SQL 方言</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-outerjoin">3.4.2. 外连接抓取（Outer Join Fetching）</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-binarystreams">3.4.3. 二进制流（Binary Streams）</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-cacheprovider">3.4.4. 二级缓存与查询缓存</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-querysubstitution">3.4.5. 查询语言中的替换</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-statistics">3.4.6. Hibernate 的统计（statistics）机制</a></span></dt></dl></dd><dt><span class="section"><a href="session-configuration.html#configuration-logging">3.5. 日志</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-namingstrategy">3.6. 实现 NamingStrategy</a></span></dt><dt><span class="section"><a href="session-configuration.html#d0e3307">3.7. Implementing a PersisterClassProvider</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-xmlconfig">3.8. XML 配置文件</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-j2ee">3.9. Java EE Application Server integration</a></span></dt><dd><dl><dt><span class="section"><a href="session-configuration.html#configuration-optional-transactionstrategy">3.9.1. 事务策略配置</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-optional-jndi">3.9.2. JNDI 绑定的 SessionFactory</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-j2ee-currentsession">3.9.3. 在 JTA 环境下使用 Current Session context（当前 session 上下文）管理</a></span></dt><dt><span class="section"><a href="session-configuration.html#configuration-j2ee-jmx">3.9.4. JMX 部署</a></span></dt></dl></dd></dl></div><p>由于 Hibernate 是为了能在各种不同环境下工作而设计的，因此存在着大量的配置参数。幸运的是多数配置参数都有比较直观的默认值，并有随 Hibernate 一同分发的配置样例 <code class="literal">hibernate.properties</code>（位于 <code class="literal">etc/</code>）来展示各种配置选项。所需做的仅仅是将这个样例文件复制到类路径（classpath）下并进行定制。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-programmatic"/>3.1. 可编程的配置方式</h2></div></div></div><p><code class="literal">org.hibernate.cfg.Configuration</code> 实例代表了一个应用程序中 Java 类型到SQL数据库映射的完整集合。<code class="classname">org.hibernate.cfg.Configuration</code> 被用来构建一个（不可变的（immutable））<code class="interfacename">org.hibernate.SessionFactory</code>。映射定义则由不同的 XML 映射定义文件编译而来。</p><p>你可以直接实例化 <code class="classname">org.hibernate.cfg.Configuration</code> 来获取一个实例，并为它指定 XML 映射定义文件。如果映射定义文件在类路径（classpath）中，请使用 <code class="literal">addResource（)</code>。例如：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_plain">&nbsp;cfg&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addResource</span><span class="java_separator">(</span><span class="java_literal">&quot;Item.hbm.xml&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addResource</span><span class="java_separator">(</span><span class="java_literal">&quot;Bid.hbm.xml&quot;</span><span class="java_separator">);</span></pre><p>一个替代方法（有时是更好的选择）是，指定被映射的类，让 Hibernate 帮你寻找映射定义文件： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_plain">&nbsp;cfg&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addClass</span><span class="java_separator">(</span><span class="java_plain">org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">auction</span><span class="java_separator">.</span><span class="java_type">Item</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addClass</span><span class="java_separator">(</span><span class="java_plain">org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">auction</span><span class="java_separator">.</span><span class="java_type">Bid</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">);</span></pre><p>Hibernate 将会在类路径（classpath）中寻找名字为 <code class="filename">/org/hibernate/auction/Item.hbm.xml</code> 和 <code class="filename">/org/hibernate/auction/Bid.hbm.xml</code> 映射定义文件。这种方式消除了任何对文件名的硬编码（hardcoded）。</p><p><code class="classname">org.hibernate.cfg.Configuration</code>
&gt; 也允许你指定配置属性。例如：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_plain">&nbsp;cfg&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addClass</span><span class="java_separator">(</span><span class="java_plain">org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">auction</span><span class="java_separator">.</span><span class="java_type">Item</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addClass</span><span class="java_separator">(</span><span class="java_plain">org</span><span class="java_separator">.</span><span class="java_plain">hibernate</span><span class="java_separator">.</span><span class="java_plain">auction</span><span class="java_separator">.</span><span class="java_type">Bid</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate.dialect&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;org.hibernate.dialect.MySQLInnoDBDialect&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate.connection.datasource&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;java:comp/env/jdbc/test&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;hibernate.order_updates&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;true&quot;</span><span class="java_separator">);</span></pre><p>当然这不是唯一的传递 Hibernate 配置属性的方式，其他可选方式还包括： </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>传一个 <code class="classname">java.util.Properties</code> 实例给 <code class="literal">Configuration.setProperties()</code>。</p></li><li><p>将 <code class="filename">hibernate.properties</code> 放置在类路径（classpath）的根目录下（root directory）。</p></li><li><p>通过 <code class="literal">java -Dproperty=value</code> 来设置系统（<code class="literal">System</code>）属性。</p></li><li><p>在 <code class="literal">hibernate.cfg.xml</code> 中加入元素 <code class="literal">&lt;property&gt;</code>（稍后讨论）。 </p></li></ol></div><p>如果你想快速上路，<code class="filename">hibernate.properties</code> 就是最容易的途径。</p><p><code class="classname">org.hibernate.cfg.Configuration</code> 实例被设计成启动期间（startup-time）对象，一旦 <code class="literal">SessionFactory</code> 创建完成它就被丢弃了。</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-sessionfactory"/>3.2. 获得 SessionFactory</h2></div></div></div><p>当所有映射定义被 <code class="classname">org.hibernate.cfg.Configuration</code> 解析后，应用程序必须获得一个用于构造 <code class="interfacename">org.hibernate.Session</code> 实例的工厂。这个工厂将被应用程序的所有线程共享：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sessions&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;cfg</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">buildSessionFactory</span><!-- <br/> --><span class="java_separator">();</span></pre><p>Hibernate 允许你的应用程序创建多个 <code class="interfacename">org.hibernate.SessionFactory</code> 实例。这对 使用多个数据库的应用来说很有用。</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-hibernatejdbc"/>3.3. JDBC 连接</h2></div></div></div><p>通常你希望  <code class="interfacename">org.hibernate.SessionFactory</code> 来为你创建和缓存（pool）JDBC 连接。如果你采用这种方式，只需要如下例所示那样，打开一个 <code class="interfacename">org.hibernate.Session</code>：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">Session</span><!-- <br/> --><span class="java_plain">&nbsp;session&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;sessions</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">openSession</span><!-- <br/> --><span class="java_separator">();</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;open&nbsp;a&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Session</span></pre><p>一旦你需要进行数据访问时，就会从连接池（connection pool）获得一个 JDBC 连接。 </p><p>为了使这种方式工作起来，我们需要向 Hibernate 传递一些 JDBC 连接的属性。所有 Hibernate 属性的名字和语义都在 <code class="classname">org.hibernate.cfg.Environment</code> 中定义。我们现在将描述 JDBC 连接配置中最重要的设置。</p><p>如果你设置如下属性，Hibernate 将使用 <code class="classname">java.sql.DriverManager</code> 来获得（和缓存）JDBC 连接：</p><div class="table"><a id="d0e1774"/><p class="title"><b>表 3.1. Hibernate JDBC 属性</b></p><div class="table-contents"><table summary="Hibernate JDBC 属性" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>属性名</th><th>用途</th></tr></thead><tbody><tr><td><span class="property">hibernate.connection.driver_class</span></td><td><span class="emphasis"><em>JDBC driver class</em></span></td></tr><tr><td><span class="property">hibernate.connection.url</span></td><td><span class="emphasis"><em>JDBC URL</em></span></td></tr><tr><td><span class="property">hibernate.connection.username</span></td><td><span class="emphasis"><em>database user</em></span></td></tr><tr><td><span class="property">hibernate.connection.password</span></td><td><span class="emphasis"><em>数据库用户密码</em></span></td></tr><tr><td><span class="property">hibernate.connection.pool_size</span></td><td><span class="emphasis"><em>maximum number of pooled connections</em></span></td></tr></tbody></table></div></div><br class="table-break"/><p>但 Hibernate 自带的连接池算法相当不成熟。它只是为了让你快些上手<span class="emphasis"><em>，并不适合用于产品系统</em></span>或性能测试中。 出于最佳性能和稳定性考虑你应该使用第三方的连接池。只需要用特定连接池的设置替换 <code class="literal">hibernate.connection.pool_size</code> 即可。这将关闭 Hibernate 自带的连接池。例如，你可能会想用 C3P0。  </p><p>C3P0 是一个随 Hibernate 一同分发的开源的 JDBC 连接池，它位于 <code class="literal">lib</code>目录下。 如果你设置了 <code class="literal">hibernate.c3p0.*</code> 相关的属性，Hibernate将使用 <code class="literal">C3P0ConnectionProvider</code> 来缓存 JDBC 连接。如果你更原意使用 Proxool，请参考发行包中的 <code class="literal">hibernate.properties</code> 并到 Hibernate 网站获取更多的信息。 </p><p>这是一个使用 C3P0 的 <code class="literal">hibernate.properties</code> 样例文件： </p><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>为了能在应用程序服务器（application server）中使用 Hibernate，应当总是将 Hibernate 配置成从注册在 JNDI 中的 <code class="literal">Datasource</code> 处获得连接，你至少需要设置下列属性中的一个： </p><div class="table"><a id="d0e1856"/><p class="title"><b>表 3.2. Hibernate 数据源属性</b></p><div class="table-contents"><table summary="Hibernate 数据源属性" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>属性名</th><th>用途</th></tr></thead><tbody><tr><td><span class="property">hibernate.connection.datasource</span></td><td><span class="emphasis"><em>数据源 JNDI 名字</em></span></td></tr><tr><td><span class="property">hibernate.jndi.url</span></td><td><span class="emphasis"><em>JNDI 提供者的 URL</em></span>（可选）</td></tr><tr><td><span class="property">hibernate.jndi.class</span></td><td><span class="emphasis"><em>JNDI <code class="literal">InitialContextFactory</code> 类</em></span>（可选）</td></tr><tr><td><span class="property">hibernate.connection.username</span></td><td><span class="emphasis"><em>数据库用户</em></span>（可选）</td></tr><tr><td><span class="property">hibernate.connection.password</span></td><td><span class="emphasis"><em>数据库密码</em></span>（可选）</td></tr></tbody></table></div></div><br class="table-break"/><p>这是一个使用应用程序服务器提供的 JNDI 数据源的 <code class="literal">hibernate.properties</code> 样例文件： </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>从 JNDI 数据源获得的 JDBC 连接将自动参与到应用程序服务器中容器管理的事务（container-managed transactions）中去。</p><p>任何连接（connection）属性的属性名都要以 "<code class="literal">hibernate.connnection</code>" 开头。例如，你可能会使用 <code class="literal">hibernate.connection.charSet</code> 来指定 <span class="property">charSet</span> 连接属性。 </p><p>通过实现 <code class="literal">org.hibernate.connection.ConnectionProvider</code> 接口，你可以定义属于你自己的获得JDBC连接的插件策略。通过设置<code class="literal">hibernate.connection.provider_class</code>，你可以选择一个自定义的实现。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-optional"/>3.4. 可选的配置属性</h2></div></div></div><p>有大量属性能用来控制 Hibernate 在运行期的行为。它们都是可选的，并拥有适当的默认值。 </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>警告</h2><p><span class="emphasis"><em>其中一些属性是"系统级（system-level）的"</em></span>。系统级属性只能通过<code class="literal">java -Dproperty=value</code> 或 <code class="literal">hibernate.properties</code> 来设置，而<span class="emphasis"><em>不能</em></span>用上面描述的其他方法来设置。</p></div><div class="table"><a id="configuration-optional-properties"/><p class="title"><b>表 3.3. Hibernate 配置属性</b></p><div class="table-contents"><table summary="Hibernate 配置属性" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>属性名</th><th>用途</th></tr></thead><tbody><tr><td><span class="property">hibernate.dialect</span></td><td>允许 Hibernate 针对特定的关系数据库生成优化的 SQL 的 <code class="classname">org.hibernate.dialect.Dialect</code> 的类名。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">full.classname.of.Dialect</code>  </p> <p>在大多数情况下，Hibernate 可以根据 JDBC 驱动返回的 <code class="literal">JDBC metadata</code> 选择正确的 <code class="classname">org.hibernate.dialect.Dialect</code> 实现。 </p></td></tr><tr><td><span class="property">hibernate.show_sql</span></td><td>输出所有 SQL 语句到控制台。有一个另外的选择是把 <code class="literal">org.hibernate.SQL</code> 这个 log category设为 <code class="literal">debug</code>。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.format_sql</span></td><td>在 log 和 console 中打印出更漂亮的 SQL。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.default_schema</span></td><td>在生成的 SQL 中，将给定的 schema/tablespace 附加于非全限定名的表名上。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">SCHEMA_NAME</code>  </p></td></tr><tr><td><span class="property">hibernate.default_catalog</span></td><td>在生成的 SQL 中，将给定的 catalog 附加于非全限定名的表名上。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">CATALOG_NAME</code>  </p></td></tr><tr><td><span class="property">hibernate.session_factory_name</span></td><td><code class="interfacename">org.hibernate.SessionFactory</code> 创建后，将自动使用这个名字绑定到 JNDI 中。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">jndi/composite/name</code>  </p></td></tr><tr><td><span class="property">hibernate.max_fetch_depth</span></td><td>为单向关联（一对一，多对一）的外连接抓取（outer join fetch）树设置最大深度。值为 <code class="literal">0</code> 意味着将关闭默认的外连接抓取。  <p><span class="strong"><strong>例如：</strong></span> 建议在 <code class="literal">0</code> 到 <code class="literal">3</code> 之间取值  </p></td></tr><tr><td><span class="property">hibernate.default_batch_fetch_size</span></td><td>为 Hibernate 关联的批量抓取设置默认数量。  <p><span class="strong"><strong>例如：</strong></span>建议的取值为 <code class="literal">4</code>，<code class="literal">8</code>，和 <code class="literal">16</code>  </p></td></tr><tr><td><span class="property">hibernate.default_entity_mode</span></td><td>为由这个 <code class="literal">SessionFactory</code> 打开的所有 Session 指定默认的实体表现模式。  <p><span class="strong"><strong>取值</strong></span><code class="literal">dynamic-map</code>，<code class="literal">dom4j</code>，<code class="literal">pojo</code> </p></td></tr><tr><td><span class="property">hibernate.order_updates</span></td><td>强制 Hibernate 按照被更新数据的主键，为 SQL 更新排序。这么做将减少在高并发系统中事务的死锁。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.generate_statistics</span></td><td>如果开启，Hibernate 将收集有助于性能调节的统计数据。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.use_identifier_rollback</span></td><td>如果开启，在对象被删除时生成的标识属性将被重设为默认值。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.use_sql_comments</span></td><td>如果开启，Hibernate 将在 SQL 中生成有助于调试的注释信息，默认值为 <code class="literal">false</code>。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.id.new_generator_mappings</span></td><td>Setting is relevant when using <code class="classname">@GeneratedValue</code>. It indicates whether or not the new <code class="classname">IdentifierGenerator</code> implementations are used for <code class="classname">javax.persistence.GenerationType.AUTO</code>, <code class="classname">javax.persistence.GenerationType.TABLE</code> and <code class="classname">javax.persistence.GenerationType.SEQUENCE</code>. Default to <code class="literal">false</code> to keep backward compatibility. <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>We recommend all new projects which make use of to use <code class="classname">@GeneratedValue</code> to also set <code class="code">hibernate.id.new_generator_mappings=true</code> as the new generators are more efficient and closer to the JPA 2 specification semantic. However they are not backward compatible with existing databases (if a sequence or a table is used for id generation).</p></div><div class="table"><a id="configuration-jdbc-properties"/><p class="title"><b>表 3.4. Hibernate JDBC 和连接（connection）属性</b></p><div class="table-contents"><table summary="Hibernate JDBC 和连接（connection）属性" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>属性名</th><th>用途</th></tr></thead><tbody><tr><td><span class="property">hibernate.jdbc.fetch_size</span></td><td>非零值，指定 JDBC 抓取数量的大小（调用 <code class="literal">Statement.setFetchSize()</code>）。</td></tr><tr><td><span class="property">hibernate.jdbc.batch_size</span></td><td>非零值，允许 Hibernate 使用 JDBC2 的批量更新。 <p><span class="strong"><strong>例如：</strong></span>建议取 <code class="literal">5</code> 到 <code class="literal">30</code> 之间的值  </p></td></tr><tr><td><span class="property">hibernate.jdbc.batch_versioned_data</span></td><td>Set this property to <code class="literal">true</code> if your JDBC driver returns correct row counts from <code class="literal">executeBatch()</code>. It is usually safe to turn this option on. Hibernate will then use batched DML for automatically versioned data. Defaults to <code class="literal">false</code>. <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.jdbc.factory_class</span></td><td>选择一个自定义的 <code class="literal">Batcher</code>。多数应用程序不需要这个配置属性。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">classname.of.Batcher</code>  </p></td></tr><tr><td><span class="property">hibernate.jdbc.use_scrollable_resultset</span></td><td>允许 Hibernate 使用 JDBC2 的可滚动结果集。只有在使用用户提供的 JDBC 连接时，这个选项才是必要的，否则 Hibernate 会使用连接的元数据。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.jdbc.use_streams_for_binary</span></td><td>在 JDBC 读写 <code class="literal">binary</code> 或 <code class="literal">serializable</code> 的类型时使用流（stream）（系统级属性）。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.jdbc.use_get_generated_keys</span></td><td>在数据插入数据库之后，允许使用 JDBC3 <code class="literal">PreparedStatement.getGeneratedKeys()</code> 来获取数据库生成的 key（键）。需要 JDBC3+ 驱动和 JRE1.4+，如果你的数据库驱动在使用 Hibernate 的标识生成器时遇到问题，请将此值设为 false。默认情况下将使用连接的元数据来判定驱动的能力。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">true | false</code>  </p></td></tr><tr><td><span class="property">hibernate.connection.provider_class</span></td><td>自定义 <code class="literal">ConnectionProvider</code> 的类名，此类用来向 Hibernate 提供 JDBC 连接。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">classname.of.ConnectionProvider</code>  </p></td></tr><tr><td><span class="property">hibernate.connection.isolation</span></td><td>设置 JDBC 事务隔离级别。查看 <code class="literal">java.sql.Connection</code> 来了解各个值的具体意义，但请注意多数数据库都不支持所有的隔离级别。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">1, 2, 4, 8</code>  </p></td></tr><tr><td><span class="property">hibernate.connection.autocommit</span></td><td>允许被缓存的 JDBC 连接开启自动提交（autocommit）（不推荐）。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><span class="property">hibernate.connection.release_mode</span></td><td>指定 Hibernate 在何时释放 JDBC 连接。默认情况下,直到 Session 被显式关闭或被断开连接时,才会释放 JDBC 连接。对于应用程序服务器的 JTA 数据源，你应当使用  <code class="literal">after_statement</code>，这样在每次 JDBC 调用后，都会主动的释放连接。对于非 JTA 的连接，使用 <code class="literal">after_transaction</code> 在每个事务结束时释放连接是合理的。<code class="literal">auto</code> 将为 JTA 和 CMT 事务策略选择 <code class="literal">after_statement</code>，为JDBC事务策略选择 <code class="literal">after_transaction</code>。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">auto</code> (默认) | <code class="literal">on_close</code> | <code class="literal">after_transaction</code> | <code class="literal">after_statement</code>  </p> <p>This setting only affects <code class="literal">Session</code>s returned from <code class="literal">SessionFactory.openSession</code>. For <code class="literal">Session</code>s obtained through <code class="literal">SessionFactory.getCurrentSession</code>, the <code class="literal">CurrentSessionContext</code> implementation configured for use controls the connection release mode for those <code class="literal">Session</code>s. See <a class="xref" href="architecture.html#architecture-current-session" title="2.3. 上下文相关的会话（Contextual Session）">第 2.3 节 “上下文相关的会话（Contextual Session）”</a> </p></td></tr><tr><td><span class="property">hibernate.connection.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span></td><td>把 JDBC 属性 <span class="emphasis"><em>&lt;propertyName&gt;</em></span> 传递给 <code class="literal">DriverManager.getConnection()</code>。</td></tr><tr><td><span class="property">hibernate.jndi.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span></td><td>把 <span class="emphasis"><em>&lt;propertyName&gt;</em></span> 属性传递给 JNDI <code class="literal">InitialContextFactory</code>。</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-cache-properties"/><p class="title"><b>表 3.5. Hibernate 缓存属性</b></p><div class="table-contents"><table summary="Hibernate 缓存属性" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>属性名</th><th>用途</th></tr></thead><tbody><tr><td><code class="literal">hibernate.cache.provider_class</code></td><td>自定义的 <code class="literal">CacheProvider</code> 的类名。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">classname.of.CacheProvider</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.use_minimal_puts</code></td><td>以频繁的读操作为代价，优化二级缓存来最小化写操作。在 Hibernate3 中，这个设置对的集群缓存非常有用，对集群缓存的实现而言，默认是开启的。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">true | false</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.use_query_cache</code></td><td>允许查询缓存，个别查询仍然需要被设置为可缓存的。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">true | false</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.use_second_level_cache</code></td><td>能用来完全禁止使用二级缓存。对那些在类的映射定义中指定 <code class="literal">&lt;cache&gt;</code> 的类，会默认开启二级缓存。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">true | false</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.query_cache_factory</code></td><td>自定义实现 <code class="literal">QueryCache</code> 接口的类名，默认为内建的 <code class="literal">StandardQueryCache</code>。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">classname.of.QueryCache</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.region_prefix</code></td><td>二级缓存区域名的前缀。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">prefix</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.use_structured_entries</code></td><td>强制 Hibernate 以更人性化的格式将数据存入二级缓存。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">true | false</code>  </p></td></tr><tr><td><code class="literal">hibernate.cache.default_cache_concurrency_strategy</code></td><td>Setting used to give the name of the default <code class="classname">org.hibernate.annotations.CacheConcurrencyStrategy</code> to use when either <code class="classname">@Cacheable</code> or <code class="classname">@Cache</code> is used. <code class="code">@Cache(strategy="..")</code> is used to override this default.</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-transaction-properties"/><p class="title"><b>表 3.6. Hibernate 事务属性</b></p><div class="table-contents"><table summary="Hibernate 事务属性" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>属性名</th><th>用途</th></tr></thead><tbody><tr><td><code class="literal">hibernate.transaction.factory_class</code></td><td>一个 <code class="literal">TransactionFactory</code> 的类名，用于 Hibernate <code class="literal">Transaction</code> API（默认为 <code class="literal">JDBCTransactionFactory</code>）。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">classname.of.TransactionFactory</code>  </p></td></tr><tr><td><code class="literal">jta.UserTransaction</code></td><td>一个 JNDI 名字，被 <code class="literal">JTATransactionFactory</code> 用来从应用服务器获取 JTA   <code class="literal">UserTransaction</code>。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">jndi/composite/name</code>  </p></td></tr><tr><td><code class="literal">hibernate.transaction.manager_lookup_class</code></td><td>一个 <code class="literal">TransactionManagerLookup</code> 的类名 — 当使用 JVM 级缓存，或在 JTA 环境中使用 hilo 生成器的时候需要该类。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">classname.of.TransactionManagerLookup</code>  </p></td></tr><tr><td><code class="literal">hibernate.transaction.flush_before_completion</code></td><td>If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. 上下文相关的会话（Contextual Session）">第 2.3 节 “上下文相关的会话（Contextual Session）”</a>. <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><code class="literal">hibernate.transaction.auto_close_session</code></td><td>If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and automatic session context management is preferred, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. 上下文相关的会话（Contextual Session）">第 2.3 节 “上下文相关的会话（Contextual Session）”</a>. <p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-misc-properties"/><p class="title"><b>表 3.7. 其他属性</b></p><div class="table-contents"><table summary="其他属性" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>属性名</th><th>用途</th></tr></thead><tbody><tr><td><code class="literal">hibernate.current_session_context_class</code></td><td>Supply a custom strategy for the scoping of the "current" <code class="literal">Session</code>. See <a class="xref" href="architecture.html#architecture-current-session" title="2.3. 上下文相关的会话（Contextual Session）">第 2.3 节 “上下文相关的会话（Contextual Session）”</a> for more information about the built-in strategies. <p><span class="strong"><strong>例如：</strong></span><code class="literal">jta</code> | <code class="literal">thread</code> | <code class="literal">managed</code> | <code class="literal">custom.Class</code>  </p></td></tr><tr><td><code class="literal">hibernate.query.factory_class</code></td><td>选择 HQL 解析器的实现。 <p><span class="strong"><strong>例如：</strong></span><code class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</code> 或 <code class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</code>  </p></td></tr><tr><td><code class="literal">hibernate.query.substitutions</code></td><td>将 Hibernate 查询中的符号映射到 SQL 查询中的符号（符号可能是函数名或常量名字）。   <p><span class="strong"><strong>例如：</strong></span><code class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</code>  </p></td></tr><tr><td><code class="literal">hibernate.hbm2ddl.auto</code></td><td>在 <code class="literal">SessionFactory</code> 创建时，自动检查数据库结构，或者将数据库 schema 的 DDL 导出到数据库。使用 <code class="literal">create-drop</code> 时，在显式关闭 <code class="literal">SessionFactory</code> 时，将删除掉数据库 schema。  <p><span class="strong"><strong>例如：</strong></span><code class="literal">validate</code> | <code class="literal">update</code> | <code class="literal">create</code> | <code class="literal">create-drop</code>  </p></td></tr><tr><td><code class="literal">hibernate.hbm2ddl.import_files</code></td><td><p>Comma-separated names of the optional files containing SQL DML statements executed during the <code class="classname">SessionFactory</code> creation. This is useful for testing or demoing: by adding INSERT statements for example you can populate your database with a minimal set of data when it is deployed.</p><p>File order matters, the statements of a give file are executed before the statements of the following files. These statements are only executed if the schema is created ie if <code class="literal">hibernate.hbm2ddl.auto</code> is set to <code class="literal">create</code> or <code class="literal">create-drop</code>.</p><p><span class="strong"><strong>e.g.</strong></span> <code class="literal">/humans.sql,/dogs.sql</code> </p></td></tr><tr><td><code class="literal">hibernate.bytecode.use_reflection_optimizer</code></td><td><p>Enables the use of bytecode manipulation instead of runtime reflection. This is a System-level property and cannot be set in <code class="literal">hibernate.cfg.xml</code>. Reflection can sometimes be useful when troubleshooting. Hibernate always requires either CGLIB or javassist even if you turn off the optimizer.</p><p><span class="strong"><strong>例如：</strong></span><code class="literal">true</code> | <code class="literal">false</code>  </p></td></tr><tr><td><code class="literal">hibernate.bytecode.provider</code></td><td><p>Both javassist or cglib can be used as byte manipulation engines; the default is <code class="literal">javassist</code>.</p><p><span class="strong"><strong>e.g.</strong></span> <code class="literal">javassist</code> | <code class="literal">cglib</code> </p></td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-dialects"/>3.4.1. SQL 方言</h3></div></div></div><p>你应当总是为你的数据库将 <code class="literal">hibernate.dialect</code> 属性设置成正确的  <code class="literal">org.hibernate.dialect.Dialect</code> 子类。如果你指定一种方言，Hibernate 将为上面列出的一些属性使用合理的默认值，这样你就不用手工指定它们。</p><div class="table"><a id="sql-dialects"/><p class="title"><b>表 3.8. Hibernate SQL 方言（<code class="literal">hibernate.dialect</code>）</b></p><div class="table-contents"><table summary="Hibernate SQL 方言（hibernate.dialect）" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><code class="literal">org.hibernate.dialect.DB2Dialect</code></td></tr><tr><td>DB2 AS/400</td><td><code class="literal">org.hibernate.dialect.DB2400Dialect</code></td></tr><tr><td>DB2 OS390</td><td><code class="literal">org.hibernate.dialect.DB2390Dialect</code></td></tr><tr><td>PostgreSQL</td><td><code class="literal">org.hibernate.dialect.PostgreSQLDialect</code></td></tr><tr><td>MySQL5</td><td><code class="literal">org.hibernate.dialect.MySQL5Dialect</code></td></tr><tr><td>MySQL5 with InnoDB</td><td><code class="literal">org.hibernate.dialect.MySQL5InnoDBDialect</code></td></tr><tr><td>MySQL with MyISAM</td><td><code class="literal">org.hibernate.dialect.MySQLMyISAMDialect</code></td></tr><tr><td>Oracle（any version）</td><td><code class="literal">org.hibernate.dialect.OracleDialect</code></td></tr><tr><td>Oracle 9i</td><td><code class="literal">org.hibernate.dialect.Oracle9iDialect</code></td></tr><tr><td>Oracle 10g</td><td><code class="literal">org.hibernate.dialect.Oracle10gDialect</code></td></tr><tr><td>Oracle 11g</td><td><code class="literal">org.hibernate.dialect.Oracle10gDialect</code></td></tr><tr><td>Sybase</td><td><code class="literal">org.hibernate.dialect.SybaseASE15Dialect</code></td></tr><tr><td>Sybase Anywhere</td><td><code class="literal">org.hibernate.dialect.SybaseAnywhereDialect</code></td></tr><tr><td>Microsoft SQL Server 2000</td><td><code class="literal">org.hibernate.dialect.SQLServerDialect</code></td></tr><tr><td>Microsoft SQL Server 2005</td><td><code class="literal">org.hibernate.dialect.SQLServer2005Dialect</code></td></tr><tr><td>Microsoft SQL Server 2008</td><td><code class="literal">org.hibernate.dialect.SQLServer2008Dialect</code></td></tr><tr><td>SAP DB</td><td><code class="literal">org.hibernate.dialect.SAPDBDialect</code></td></tr><tr><td>Informix</td><td><code class="literal">org.hibernate.dialect.InformixDialect</code></td></tr><tr><td>HypersonicSQL</td><td><code class="literal">org.hibernate.dialect.HSQLDialect</code></td></tr><tr><td>H2 Database</td><td><code class="literal">org.hibernate.dialect.H2Dialect</code></td></tr><tr><td>Ingres</td><td><code class="literal">org.hibernate.dialect.IngresDialect</code></td></tr><tr><td>Progress</td><td><code class="literal">org.hibernate.dialect.ProgressDialect</code></td></tr><tr><td>Mckoi SQL</td><td><code class="literal">org.hibernate.dialect.MckoiDialect</code></td></tr><tr><td>Interbase</td><td><code class="literal">org.hibernate.dialect.InterbaseDialect</code></td></tr><tr><td>Pointbase</td><td><code class="literal">org.hibernate.dialect.PointbaseDialect</code></td></tr><tr><td>FrontBase</td><td><code class="literal">org.hibernate.dialect.FrontbaseDialect</code></td></tr><tr><td>Firebird</td><td><code class="literal">org.hibernate.dialect.FirebirdDialect</code></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-outerjoin"/>3.4.2. 外连接抓取（Outer Join Fetching）</h3></div></div></div><p>如果你的数据库支持 ANSI、Oracle 或 Sybase 风格的外连接，<span class="emphasis"><em>外连接抓取</em></span>通常能通过限制往返数据库次数（更多的工作交由数据库自己来完成）来提高效率。外连接抓取允许在单个 <code class="literal">SELECT</code> SQL 语句中， 通过 many-to-one、one-to-many、many-to-many 和 one-to-one 关联获取连接对象的整个对象图。</p><p>将 <code class="literal">hibernate.max_fetch_depth</code> 设为 <code class="literal">0</code> 能在<span class="emphasis"><em>全局</em></span> 范围内禁止外连接抓取。设为 <code class="literal">1</code> 或更高值能启用 one-to-one 和 many-to-oneouter 关联的外连接抓取，它们通过 <code class="literal">fetch="join"</code> 来映射。 </p><p>See <a class="xref" href="performance.html#performance-fetching" title="21.1. 抓取策略（Fetching strategies）">第 21.1 节 “抓取策略（Fetching strategies）”</a> for more information.</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-binarystreams"/>3.4.3. 二进制流（Binary Streams）</h3></div></div></div><p>Oracle 限制那些通过 JDBC 驱动传输的<code class="literal">字节</code>数组的数目。如果你希望使用<code class="literal">二进值（binary）</code>或 <code class="literal">可序列化的（serializable）</code>类型的大对象，你应该开启 <code class="literal">hibernate.jdbc.use_streams_for_binary</code> 属性。<span class="emphasis"><em>这是系统级属性。</em></span> </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-cacheprovider"/>3.4.4. 二级缓存与查询缓存</h3></div></div></div><p>The properties prefixed by <code class="literal">hibernate.cache</code> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <a class="xref" href="performance.html#performance-cache" title="21.2. 二级缓存（The Second Level Cache）">第 21.2 节 “二级缓存（The Second Level Cache）”</a> for more information.</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-querysubstitution"/>3.4.5. 查询语言中的替换</h3></div></div></div><p>你可以使用 <code class="literal">hibernate.query.substitutions</code> 在 Hibernate 中定义新的查询符号。例如： </p><pre class="programlisting">hibernate.query.substitutions true=1，false=0</pre><p>将导致符号 <code class="literal">true</code> 和 <code class="literal">false</code> 在生成的 SQL 中被翻译成整数常量。</p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>将允许你重命名 SQL 中的 <code class="literal">LOWER</code> 函数。</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-statistics"/>3.4.6. Hibernate 的统计（statistics）机制</h3></div></div></div><p>如果你开启 <code class="literal">hibernate.generate_statistics</code>，那么当你通过  <code class="literal">SessionFactory.getStatistics()</code> 调整正在运行的系统时，Hibernate 将导出大量有用的数据。Hibernate 甚至能被配置成通过 JMX 导出这些统计信息。参考 <code class="literal">org.hibernate.stats</code> 中接口的 Javadoc，以获得更多信息。 </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-logging"/>3.5. 日志</h2></div></div></div><p>Hibernate 利用 <a class="ulink" href="http://www.slf4j.org/">Simple Logging Facade for Java</a> (SLF4J) 来记录不同系统事件的日志。SLF4J 可以根据你选择的绑定把日志输出到几个日志框架（NOP、Simple、log4j version 1.2、JDK 1.4 logging、JCL 或 logback）上。为了设置日志，你需要在 classpath 里加入 <code class="filename">slf4j-api.jar</code> 和你选择的绑定的 JAR 文件（使用 Log4J 时加入 <code class="filename">slf4j-log4j12.jar</code>）。更多的细节请参考 SLF4J <a class="ulink" href="http://www.slf4j.org/manual.html">文档</a>。要使用 Log4j，你也需要在 classpath 里加入 <code class="filename">log4j.properties</code> 文件。Hibernate 里的 <code class="literal">src/</code> 目录里带有一个属性文件的例子。</p><p>我们强烈建议你熟悉一下 Hibernate 的日志消息。在不失可读性的前提下，我们做了很多工作，使 Hibernate 的日志可能地详细。这是必要的查错利器。最令人感兴趣的日志分类有如下这些：</p><div class="table"><a id="log-categories"/><p class="title"><b>表 3.9. Hibernate 日志类别</b></p><div class="table-contents"><table summary="Hibernate 日志类别" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>类别</th><th>功能</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.SQL</code></td><td>在所有 SQL DML 语句被执行时为它们记录日志</td></tr><tr><td><code class="literal">org.hibernate.type</code></td><td>为所有 JDBC 参数记录日志</td></tr><tr><td><code class="literal">org.hibernate.tool.hbm2ddl</code></td><td>在所有 SQL DDL 语句执行时为它们记录日志</td></tr><tr><td><code class="literal">org.hibernate.pretty</code></td><td>在 session 清洗（flush）时，为所有与其关联的实体（最多 20 个）的状态记录日志</td></tr><tr><td><code class="literal">org.hibernate.cache</code></td><td>为所有二级缓存的活动记录日志</td></tr><tr><td><code class="literal">org.hibernate.transaction</code></td><td>为事务相关的活动记录日志</td></tr><tr><td><code class="literal">org.hibernate.jdbc</code></td><td>为所有 JDBC 资源的获取记录日志</td></tr><tr><td><code class="literal">org.hibernate.hql.ast.AST</code></td><td>在解析查询的时候,记录 HQL 和 SQL 的 AST 分析日志</td></tr><tr><td><code class="literal">org.hibernate.secure</code></td><td>为 JAAS 认证请求做日志</td></tr><tr><td><code class="literal">org.hibernate</code></td><td>为任何 Hibernate 相关信息记录日志（信息量较大，但对查错非常有帮助）</td></tr></tbody></table></div></div><br class="table-break"/><p>在使用 Hibernate 开发应用程序时，你应当总是为 <code class="literal">org.hibernate.SQL</code> 开启 <code class="literal">debug</code> 级别的日志记录,或者开启 <code class="literal">hibernate.show_sql</code> 属性。</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-namingstrategy"/>3.6. 实现 <code class="literal">NamingStrategy</code></h2></div></div></div><p><code class="literal">org.hibernate.cfg.NamingStrategy</code> 接口允许你为数据库中的对象和 schema 元素指定一个“命名标准”。</p><p>你可能会提供一些通过 Java 标识生成数据库标识或将映射定义文件中"逻辑"表/列名处理成"物理"表/列名的规则。这个特性有助于减少冗长的映射定义文件，消除重复内容（如 <code class="literal">TBL_</code> 前缀）。Hibernate 使用的缺省策略是相当精简的。</p><p>在加入映射定义前，你可以调用 <code class="literal">Configuration.setNamingStrategy()</code> 指定一个不同的命名策略： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sf&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setNamingStrategy</span><span class="java_separator">(</span><span class="java_type">ImprovedNamingStrategy</span><span class="java_separator">.</span><span class="java_plain">INSTANCE</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addFile</span><span class="java_separator">(</span><span class="java_literal">&quot;Item.hbm.xml&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addFile</span><span class="java_separator">(</span><span class="java_literal">&quot;Bid.hbm.xml&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">buildSessionFactory</span><span class="java_separator">();</span></pre><p><code class="literal">org.hibernate.cfg.ImprovedNamingStrategy</code> 是一个内建的命名策略，对一些应用程序而言，可能是非常有用的起点。</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3307"/>3.7. Implementing a PersisterClassProvider</h2></div></div></div><p>You can configure the persister implementation used to persist your entities and collections:</p><div class="itemizedlist"><ul><li><p>by default, Hibernate uses persisters that make sense in a relational model and follow Java Persistence's specification</p></li><li><p>you can define a <code class="classname">PersisterClassProvider</code> implementation that provides the persister class used of a given entity or collection</p></li><li><p>finally, you can override them on a per entity and collection basis in the mapping using <code class="classname">@Persister</code> or its XML equivalent</p></li></ul></div><p>The latter in the list the higher in priority.</p><p>You can pass the <code class="classname">PersisterClassProvider</code> instance to the <code class="classname">Configuration</code> object.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sf&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">setPersisterClassProvider</span><span class="java_separator">(</span><span class="java_plain">customPersisterClassProvider</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">addAnnotatedClass</span><span class="java_separator">(</span><span class="java_type">Order</span><span class="java_separator">.</span><span class="java_keyword">class</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">buildSessionFactory</span><span class="java_separator">();</span></pre><p>The persister class provider methods, when returning a non null persister class, override the default Hibernate persisters. The entity name or the collection role are passed to the methods. It is a nice way to centralize the overriding logic of the persisters instead of spreading them on each entity or collection mapping.</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-xmlconfig"/>3.8. XML 配置文件</h2></div></div></div><p>另一个配置方法是在 <code class="literal">hibernate.cfg.xml</code> 文件中指定一套完整的配置。这个文件可以当成 <code class="literal">hibernate.properties</code> 的替代。若两个文件同时存在，它将覆盖前者的属性。</p><p>XML 配置文件被默认是放在 <code class="literal">CLASSPATH</code> 的根目录下。下面是一个例子： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version='1.0'&nbsp;encoding='utf-8'?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">DOCTYPE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">hibernate-configuration</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">PUBLIC</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_value">&quot;-//Hibernate/Hibernate&nbsp;Configuration&nbsp;DTD//EN&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_value">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-configuration</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;a&nbsp;SessionFactory&nbsp;instance&nbsp;listed&nbsp;as&nbsp;/jndi/name&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">session-factory</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;java:hibernate/SessionFactory&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;properties&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;connection.datasource&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:/comp/env/jdbc/MyDB</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;dialect&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.hibernate.dialect.MySQLDialect</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;show_sql&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">false</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;transaction.factory_class&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.hibernate.transaction.JTATransactionFactory</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;jta.UserTransaction&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:comp/UserTransaction</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;mapping&nbsp;files&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">resource</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org/hibernate/auction/Item.hbm.xml&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">resource</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org/hibernate/auction/Bid.hbm.xml&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;cache&nbsp;settings&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class-cache</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.auction.Item&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">usage</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;read-write&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class-cache</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.auction.Bid&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">usage</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;read-only&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">collection-cache</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">collection</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.auction.Item.bids&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">usage</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;read-write&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">session-factory</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-configuration</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>如你所见，这个方法优势在于，在配置文件中指出了映射定义文件的名字。一旦你需要调整 Hibernate 的缓存，<code class="literal">hibernate.cfg.xml</code> 也是更方便。注意，使用 <code class="literal">hibernate.properties</code> 还是 <code class="literal">hibernate.cfg.xml</code> 完全是由你来决定，除了上面提到的 XML 语法的优势之外，两者是等价的。 </p><p>使用 XML 配置，使得启动 Hibernate 变的异常简单：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sf&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">configure</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">buildSessionFactory</span><!-- <br/> --><span class="java_separator">();</span></pre><p>你可以使用如下代码来添加一个不同的 XML 配置文件：</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">SessionFactory</span><!-- <br/> --><span class="java_plain">&nbsp;sf&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">new</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Configuration</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">configure</span><span class="java_separator">(</span><span class="java_literal">&quot;catdb.cfg.xml&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">buildSessionFactory</span><span class="java_separator">();</span></pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-j2ee"/>3.9. Java EE Application Server integration</h2></div></div></div><p>针对 J2EE 体系，Hibernate 有如下几个集成的方面：</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>容器管理的数据源（Container-managed datasources）</em></span>： Hibernate 能使用通过容器管理，并由 JNDI 提供的 JDBC 连接。通常，特别是当处理多个数据源的分布式事务的时候，由一个 JTA 兼容的 <code class="literal">TransactionManager</code> 和一个 <code class="literal">ResourceManager</code> 来处理事务管理（CMT，容器管理的事务）。当然你可以通过 编程方式来划分事务边界（BMT，Bean 管理的事务）。或者为了代码的可移植性，你也也许会想使用可选的 Hibernate <code class="literal">Transaction</code> API。 </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>自动 JNDI 绑定</em></span>：Hibernate 可以在启动后将 <code class="literal">SessionFactory</code> 绑定到 JNDI。</p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JTA Session 绑定：</em></span> Hibernate <code class="literal">Session</code> 可以自动绑定到 JTA 事务作用的范围。只需简单地从 JNDI 查找 <code class="literal">SessionFactory</code> 并获得当前的 <code class="literal">Session</code>。当 JTA 事务完成时，让 Hibernate来处理 <code class="literal">Session</code> 的清洗（flush）与关闭。事务的划分可以是声明式的（CMT）,也可以是编程式的（BMT/UserTransaction）。 </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JMX 部署：</em></span> 如果你使用支持 JMX 应用程序服务器（如，JBoss AS），那么你可以选择将 Hibernate 部署成托管 MBean。这将为你省去一行从<code class="literal">Configuration</code> 构建 <code class="literal">SessionFactory</code> 的启动代码。容器将启动你的 <code class="literal">HibernateService</code>，并完美地处理好服务间的依赖关系（在 Hibernate 启动前，数据源必须是可用的，等等）。 </p></li></ul></div><p>如果应用程序服务器抛出 "connection containment" 异常，根据你的环境，也许该将配置属性 <code class="literal">hibernate.connection.release_mode</code> 设为 <code class="literal">after_statement</code>。</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-transactionstrategy"/>3.9.1. 事务策略配置</h3></div></div></div><p>在你的架构中，Hibernate 的 <code class="literal">Session</code> API 是独立于任何事务分界系统的。如果你让 Hibernate 通过连接池直接使用 JDBC，你需要调用 JDBC API 来打开和关闭你的事务。如果你运行在 J2EE 应用程序服务器中，你也许想用 Bean 管理的事务并在需要的时候调用 JTA API 和 <code class="literal">UserTransaction</code>。 </p><p>为了让你的代码在两种（或其他）环境中可以移植，我们建议使用可选的 Hibernate <code class="literal">Transaction</code> API，它包装并隐藏了底层系统。你必须通过设置 Hibernate 配置属性 <code class="literal">hibernate.transaction.factory_class</code> 来指定一个 <code class="literal">Transaction</code> 实例的工厂类。</p><p>有三个标准（内建）的选择： </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code></span></dt><dd><p>委托给数据库（JDBC）事务（默认）</p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.JTATransactionFactory</code></span></dt><dd><p>如果在上下文环境中存在运行着的事务（如，EJB 会话 Bean 的方法），则委托给容器管理的事务。否则，将启动一个新的事务，并使用 Bean 管理的事务。</p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.CMTTransactionFactory</code></span></dt><dd><p>委托给容器管理的 JTA 事务</p></dd></dl></div><p>你也可以定义属于你自己的事务策略（如，针对 CORBA 的事务服务）。</p><p>Hibernate 的一些特性（比如二级缓存，Contextual Sessions with JTA 等等）需要访问在托管环境中的 JTA <code class="literal">TransactionManager</code>。由于 J2EE 没有标准化一个单一的机制，Hibernate 在应用程序服务器中，你必须指定 Hibernate 如何获得 <code class="literal">TransactionManager</code> 的引用： </p><div class="table"><a id="jtamanagerlookup"/><p class="title"><b>表 3.10. JTA TransactionManagers</b></p><div class="table-contents"><table summary="JTA TransactionManagers" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Transaction 工厂类</th><th align="center">应用程序服务器</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</code></td><td align="center">JBoss AS</td></tr><tr><td><code class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</code></td><td align="center">Weblogic</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</code></td><td align="center">WebSphere</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</code></td><td align="center">WebSphere 6</td></tr><tr><td><code class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</code></td><td align="center">Orion</td></tr><tr><td><code class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</code></td><td align="center">Resin</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</code></td><td align="center">JOTM</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</code></td><td align="center">JOnAS</td></tr><tr><td><code class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</code></td><td align="center">JRun4</td></tr><tr><td><code class="literal">org.hibernate.transaction.BESTransactionManagerLookup</code></td><td align="center">Borland ES</td></tr><tr><td><code class="literal">org.hibernate.transaction.JBossTSStandaloneTransactionManagerLookup</code></td><td align="center">JBoss TS used standalone (ie. outside JBoss AS and a JNDI environment generally). Known to work for <code class="literal">org.jboss.jbossts:jbossjta:4.11.0.Final</code></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-jndi"/>3.9.2. JNDI 绑定的 <code class="literal">SessionFactory</code></h3></div></div></div><p>与 JNDI 绑定的 Hibernate 的 <code class="literal">SessionFactory</code> 能简化工厂的查询，简化创建新的 <code class="literal">Session</code>。需要注意的是这与 JNDI 绑定 <code class="literal">Datasource</code> 没有关系，它们只是恰巧用了相同的注册表。</p><p>如果你希望将 <code class="literal">SessionFactory</code> 绑定到一个 JNDI 的名字空间，用属性 <code class="literal">hibernate.session_factory_name</code> 指定一个名字（如，<code class="literal">java：hibernate/SessionFactory</code>）。如果不设置这个属性，<code class="literal">SessionFactory</code> 将不会被绑定到 JNDI 中（在以只读 JNDI 为默认实现的环境中，这个设置尤其有用，如 Tomcat）。</p><p>在将 <code class="literal">SessionFactory</code> 绑定至 JNDI 时，Hibernate 将使用 <code class="literal">hibernate.jndi.url</code>，和 <code class="literal">hibernate.jndi.class</code> 的值来实例化初始环境（initial context）。如果它们没有被指定，将使用默认的 <code class="literal">InitialContext</code>。</p><p>在你调用 <code class="literal">cfg.buildSessionFactory()</code>后，Hibernate 会自动将 <code class="literal">SessionFactory</code> 注册到 JNDI。这意味这你至少需要在你应用程序的启动代码（或工具类）中完成这个调用，除非你使用 <code class="literal">HibernateService</code> 来做 JMX 部署（见后面讨论）。</p><p>假若你使用 JNDI <code class="literal">SessionFactory</code>，EJB 或者任何其它类都可以从 JNDI 中找到此 <code class="literal">SessionFactory</code>。 </p><p>It is recommended that you bind the <code class="literal">SessionFactory</code> to JNDI in a managed environment and use a <code class="literal">static</code> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <code class="literal">SessionFactory</code> in a helper class, such as <code class="literal">HibernateUtil.getSessionFactory()</code>. Note that such a class is also a convenient way to startup Hibernate—see chapter 1.</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-currentsession"/>3.9.3. 在 JTA 环境下使用 Current Session context（当前 session 上下文）管理</h3></div></div></div><p>The easiest way to handle <code class="literal">Sessions</code> and transactions is Hibernate's automatic "current" <code class="literal">Session</code> management. For a discussion of contextual sessions see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. 上下文相关的会话（Contextual Session）">第 2.3 节 “上下文相关的会话（Contextual Session）”</a>. Using the <code class="literal">"jta"</code> session context, if there is no Hibernate <code class="literal">Session</code> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <code class="literal">sessionFactory.getCurrentSession()</code>. The <code class="literal">Session</code>s retrieved via <code class="literal">getCurrentSession()</code> in the <code class="literal">"jta"</code> context are set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <code class="literal">Session</code>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <code class="literal">UserTransaction</code>, or (recommended for portable code) use the Hibernate <code class="literal">Transaction</code> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred.</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-jmx"/>3.9.4. JMX 部署</h3></div></div></div><p>为了将 <code class="literal">SessionFactory</code> 注册到 JNDI 中，<code class="literal">cfg.buildSessionFactory()</code> 这行代码仍需在某处被执行。你可在一个 <code class="literal">static</code> 初始化块（像 <code class="literal">HibernateUtil</code> 中的那样）中执行它或将 Hibernate 部署为一个<span class="emphasis"><em>托管的服务</em></span>。  </p><p>为了部署在一个支持 JMX 的应用程序服务器上，Hibernate 和 <code class="literal">org.hibernate.jmx.HibernateService</code> 一同分发，如 Jboss AS。 实际的部署和配置是由应用程序服务器提供者指定的。这里是 JBoss 4.0.x 的 <code class="literal">jboss-service.xml</code> 样例： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">mbean</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">code</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.jmx.HibernateService&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;jboss.jca:service=HibernateFactory,name=HibernateFactory&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Required&nbsp;services&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">jboss.jca:service=RARDeployer</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">jboss.jca:service=LocalTxCM,name=HsqlDS</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">depends</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Bind&nbsp;the&nbsp;Hibernate&nbsp;service&nbsp;to&nbsp;JNDI&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;JndiName&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:/hibernate/SessionFactory</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Datasource&nbsp;settings&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Datasource&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:HsqlDS</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Dialect&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.hibernate.dialect.HSQLDialect</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Transaction&nbsp;integration&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TransactionStrategy&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.hibernate.transaction.JTATransactionFactory</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TransactionManagerLookupStrategy&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.hibernate.transaction.JBossTransactionManagerLookup</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;FlushBeforeCompletionEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;AutoCloseSessionEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Fetching&nbsp;options&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MaximumFetchDepth&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">5</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Second-level&nbsp;caching&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;SecondLevelCacheEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CacheProviderClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.hibernate.cache.EhCacheProvider</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;QueryCacheEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Logging&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ShowSqlEnabled&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">true</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;Mapping&nbsp;files&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">attribute</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MapResources&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">auction/Item.hbm.xml,auction/Category.hbm.xml</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">attribute</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">mbean</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>这个文件是部署在 <code class="literal">META-INF</code> 目录下的，并会被打包到以 <code class="literal">.sar</code>（service archive）为扩展名的 JAR 文件中。同时，你需要将 Hibernate、它所需要的第三方库、你编译好的持久化类以及你的映射定义文件打包进同一个文档。你的企业 Bean（一般为会话 Bean）可能会被打包成它们自己的 JAR 文件，但你也许会将 EJB JAR 文件一同包含进能独立（热）部署的主服务文档。参考 JBoss AS 文档以了解更多的 JMX服务与 EJB 部署的信息。 </p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="architecture.html"><strong>上一页</strong>第 2 章 体系结构（Architecture）</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="persistent-classes.html"><strong>下一页</strong>第 4 章 持久化类（Persistent Classes）</a></li></ul></body></html>