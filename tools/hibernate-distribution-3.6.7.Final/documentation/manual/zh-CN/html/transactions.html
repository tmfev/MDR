<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 13 章 事务和并发</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="readonly.html" title="第 12 章 Read-only entities"/><link rel="next" href="events.html" title="第 14 章 拦截器与事件（Interceptors and events）"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>第 13 章 事务和并发 </h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="transactions.html#transactions-basics">13.1. Session 和事务范围（transaction scope）</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-basics-uow">13.1.1. 操作单元（Unit of work）</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-apptx">13.1.2. 长对话</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-identity">13.1.3. 关注对象标识（Considering object identity）</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-issues">13.1.4. 常见问题</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-demarcation">13.2. 数据库事务声明</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-demarcation-nonmanaged">13.2.1. 非托管环境</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-jta">13.2.2. 使用 JTA</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-exceptions">13.2.3. 异常处理</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-timeout">13.2.4. 事务超时</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-optimistic">13.3. 乐观并发控制（Optimistic concurrency control）</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-optimistic-manual">13.3.1. 应用程序级别的版本检查（Application version checking）</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-longsession">13.3.2. 扩展周期的 session 和自动版本化</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-detached">13.3.3. 脱管对象（deatched object）和自动版本化</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-customizing">13.3.4. 定制自动版本化行为</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-locking">13.4. 悲观锁定（Pessimistic Locking） </a></span></dt><dt><span class="section"><a href="transactions.html#transactions-connection-release">13.5. 连接释放模式（Connection Release Modes） </a></span></dt></dl></div><p>Hibernate 的事务和并发控制很容易掌握。Hibernate 直接使用 JDBC 连接和 JTA 资源，不添加任何附加锁定行为。我们强烈推荐你花点时间了解 JDBC 编程，ANSI SQL 查询语言和你使用的数据库系统的事务隔离规范。  </p><p>Hibernate 不锁定内存中的对象。你的应用程序会按照你的数据库事务的隔离级别规定的那样运作。幸亏有了 <code class="literal">Session</code>，使得 Hibernate 通过标识符查找，和实体查询（不是返回标量值的报表查询）提供了可重复的读取（Repeatable reads）功能，<code class="literal">Session</code> 同时也是事务范围内的缓存（cache）。  </p><p>除了对自动乐观并发控制提供版本管理，针对行级悲观锁定，Hibernate 也提供了辅助的（较小的）API，它使用了 <code class="literal">SELECT FOR UPDATE</code> 的 SQL 语法。本章后面会讨论乐观并发控制和这个API。  </p><p>我们从 <code class="literal">Configuration</code>层、<code class="literal">SessionFactory</code> 层，和 <code class="literal">Session</code> 层开始讨论 Hibernate 的并行控制、数据库事务和应用程序的长事务。  </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>13.1. Session 和事务范围（transaction scope）</h2></div></div></div><p><code class="literal">SessionFactory</code> 对象的创建代价很昂贵，它是线程安全的对象，它为所有的应用程序线程所共享。它只创建一次，通常是在应用程序启动的时候，由一个 <code class="literal">Configuraion</code> 的实例来创建。  </p><p><code class="literal">Session</code> 对象的创建代价比较小，是非线程安全的，对于单个请求，单个会话、单个的 工作单元而言，它只被使用一次，然后就丢弃。只有在需要的时候，一个 <code class="literal">Session</code> 对象 才会获取一个 JDBC 的 <code class="literal">Connection</code>（或一个<code class="literal">Datasource</code>）对象，因此假若不使用的时候它不消费任何资源。  </p><p>此外我们还要考虑数据库事务。数据库事务应该尽可能的短，降低数据库中的锁争用。数据库长事务会阻止你的应用程序扩展到高的并发负载。因此，假若在用户思考期间让数据库事务开着，直到整个工作单元完成才关闭这个事务，这绝不是一个好的设计。  </p><p>一个操作单元（Unit of work）的范围是多大？单个的 Hibernate <code class="literal">Session</code> 能跨越多个数据库事务吗？还是一个 <code class="literal">Session</code> 的作用范围对应一个数据库事务的范围？应该何时打开 <code class="literal">Session</code>，何时关闭 <code class="literal">Session</code>，你又如何划分数据库事务的边界呢？我们将在后续章节解决这些问题。 </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>13.1.1. 操作单元（Unit of work）</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as “<span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span>”[<a class="citation" href="bi01.html#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a class="xref" href="transactions.html#transactions-basics-apptx" title="13.1.2. 长对话">第 13.1.2 节 “长对话”</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>首先，别用 <span class="emphasis"><em>session-per-operation</em></span> 这种反模式了，也就是说，在单个线程中， 不要因为一次简单的数据库调用，就打开和关闭一次 <code class="literal">Session</code>！数据库事务也是如此。 应用程序中的数据库调用是按照计划好的次序，分组为原子的操作单元。（注意，这也意味着，应用程 序中，在单个的 SQL 语句发送之后，自动事务提交（auto-commit）模式失效了。这种模式专门为SQL控制台操作设计的。 Hibernate 禁止立即自动事务提交模式，或者期望应用服务器禁止立即自动事务提交模式。）数据库事务绝不是可有可无的，任何与数据库之间的通讯都必须在某个事务中进行，不管你是在读还是在写数据。对读数据而言，应该避免 auto-commit 行为，因为很多小的事务比一个清晰定义的工作单元性能差。后者也更容易维护和扩展。  </p><p>在多用户的 client/server 应用程序中，最常用的模式是 <span class="emphasis"><em>每个请求一个会话（session-per-request）</em></span>。 在这种模式下，来自客户端的请求被发送到服务器端（即 Hibernate 持久化层运行的地方），一个新的 Hibernate <code class="literal">Session</code> 被打开，并且执行这个操作单元中所有的数据库操作。一旦操作完成（同时对客户端的响应也准备就绪），session 被同步，然后关闭。你也可以使用单 个数据库事务来处理客户端请求，在你打开 <code class="literal">Session</code> 之后启动事务，在你关闭 <code class="literal">Session</code> 之前提交事务。会话和请求之间的关系是一对一的关系，这种模式对 于大多数应用程序来说是很棒的。  </p><p>实现才是真正的挑战。Hibernate 内置了对"当前 session（current session）" 的管理，用于简化此模式。你要做的一切就是在服务器端要处理请求的时候，开启事务，在响应发送给客户之前结束事务。你可以用任何方式来完成这一操作，通常的方案有 <code class="literal">ServletFilter</code>，在 service 方法中进行 pointcut 的 AOP 拦截器，或者 proxy/interception 容器。EJB 容器是实现横切诸如 EJB session bean 上的事务分界，用 CMT 对事务进行声明等方面的标准手段。假若你决定使用编程式的事务分界，请参考本章后面讲到的 Hibernate <code class="literal">Transaction</code> API，这对易用性和代码可移植性都有好处。  </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. 上下文相关的会话（Contextual Session）">第 2.3 节 “上下文相关的会话（Contextual Session）”</a>. </p><p>有时，将 <code class="literal">Session</code> 和数据库事务的边界延伸到"展示层被渲染后"会带来便利。有些 serlvet 应用程序在对请求进行处理后，有个单独的渲染期，这种延伸对这种程序特别有用。假若你实现你自己的拦截器，把事务边界延伸到展示层渲染结束后非常容易。然而，假若你依赖有容器管理事务的 EJB，这就不太容易了，因为事务会在 EJB 方法返回后结束，而那是在任何展示层渲染开始之前。请访问  Hibernate 网站和论坛，你可以找到 <span class="emphasis"><em>Open Session in View</em></span> 这一模式的提示和示例。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>13.1.2. 长对话</h3></div></div></div><p>session-per-request 模式不仅仅是一个可以用来设计操作单元的有用概念。很多业务处理都需 要一系列完整的与用户之间的交互，而这些用户是指对数据库有交叉访问的用户。在基于 web 的应用和企业应用中，跨用户交互的数据库事务是无法接受的。考虑下面的例子：  </p><div class="itemizedlist"><ul><li><p>在界面的第一屏，打开对话框，用户所看到的数据是被一个特定的 <code class="literal">Session</code> 和数据 库事务载入（load）的。用户可以随意修改对话框中的数据对象。  </p></li><li><p>5 分钟后，用户点击“保存”，期望所做出的修改被持久化；同时他也期望自己是唯一修改这个信息的人，不会出现修改冲突。  </p></li></ul></div><p>从用户的角度来看，我们把这个操作单元称为长时间运行的<span class="emphasis"><em>对话</em></span>（conversation），或者<span class="emphasis"><em>应用事务</em></span>（application transaction）。在你的应用程序中，可以有很多种方法来实现它。 </p><p>头一个幼稚的做法是，在用户思考的过程中，保持 <code class="literal">Session</code> 和数据库事务是打开的，保持数据库锁定，以阻止并发修改，从而保证数据库事务隔离级别和原子操作。这种方式当然是一个反模式，因为锁争用会导致应用程序无法扩展并发用户的数目。  </p><p>很明显，我们必须使用多个数据库事务来实现这个对话。在这个例子中，维护业务处理的 事务隔离变成了应用程序层的部分责任。一个对话通常跨越多个数据库事务。如果仅仅只有一个数据库事务（最后的那个事务）保存更新过的数据，而所有其他事务只是单纯的读取数据（例如在一个跨越多个请求/响应周期的向导风格的对话框中），那么应用程序事务将保证其原子性。这种方式比听起来还要容易实现，特别是当你使用了 Hibernate 的下述特性的时候：  </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>自动版本化</em></span>：Hibernate 能够自动进行乐观并发控制，如果在用户思考的过程中发生并发修改，Hibernate 能够自动检测到。一般我们只在对话结束时才检查。 </p></li><li><p><span class="emphasis"><em>脱管对象</em></span>（Detached Objects）：如果你决定采用前面已经讨论过的  <span class="emphasis"><em>session-per-request</em></span> 模式，所有载入的实例在用户思考的过程中都处于与 Session 脱离的状态。Hibernate 允许你把与 Session 脱离的对象重新关联到 Session 上，并且对修改进行持久化，这种模式被称为 <span class="emphasis"><em>session-per-request-with-detached-objects</em></span>。自动版本化被用来隔离并发修改。 </p></li><li><p><span class="emphasis"><em>Extended (or Long) Session</em></span>：Hibernate 的 <code class="literal">Session</code> 可以在数据库事务提交之后和底层的 JDBC 连接断开，当一个新的客户端请求到来的时候，它又重新连接上底层的 JDBC 连接。这种模式被称之为<span class="emphasis"><em>session-per-conversation</em></span>，这种情况可 能会造成不必要的 Session 和 JDBC 连接的重新关联。自动版本化被用来隔离并发修改，<code class="literal">Session</code> 通常不允许自动 flush，而是显性地 flush。  </p></li></ul></div><p><span class="emphasis"><em>session-per-request-with-detached-objects</em></span> 和  <span class="emphasis"><em>session-per-conversation</em></span> 各有优缺点，我们在本章后面乐观并发控制那部分再进行讨论。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>13.1.3. 关注对象标识（Considering object identity）</h3></div></div></div><p>应用程序可能在两个不同的 <code class="literal">Session</code> 中并发访问同一持久化状态，但是，一个持久化类的实例无法在两个 <code class="literal">Session</code> 中共享。因此有两种不同的标识语义：  </p><div class="variablelist"><dl><dt><span class="term">数据库标识</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">JVM 标识</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>对于那些关联到 <span class="emphasis"><em>特定</em></span> <code class="literal">Session</code>（也就是在单个 <code class="literal">Session</code> 的范围内）上的对象来说，这两种标识的语义是等价的，与数据库标识对应的 JVM 标识是由 Hibernate 来保证的。不过，当应用程序在两个不同的 session 中并发访问具有同一持久化标识的业务对象实例的时候，这个业务对象的两个实例事实上是不相同的（从 JVM 识别来看）。这种冲突可以通过在同步和提交的时候使用自动版本化和乐观锁定方法来解决。  </p><p>这种方式把关于并发的头疼问题留给了 Hibernate 和数据库；由于在单个线程内，操作单元中的对象识别不 需要代价昂贵的锁定或其他意义上的同步，因此它同时可以提供最好的可伸缩性。只要在单个线程只持有一个 <code class="literal">Session</code>，应用程序就不需要同步任何业务对象。在 <code class="literal">Session</code> 的范围内，应用程序可以放心的使用 <code class="literal">==</code> 进行对象比较。  </p><p>不过，应用程序在 <code class="literal">Session</code> 的外面使用 <code class="literal">==</code> 进行对象比较可能会 导致无法预期的结果。在一些无法预料的场合，例如，如果你把两个脱管对象实例放进同一个  <code class="literal">Set</code> 的时候，就可能发生。这两个对象实例可能有同一个数据库标识（也就是说， 他们代表了表的同一行数据），从 JVM 标识的定义上来说，对脱管的对象而言，Hibernate 无法保证他们 的的 JVM 标识一致。开发人员必须覆盖持久化类的 <code class="literal">equals()</code> 方法和  <code class="literal">hashCode()</code> 方法，从而实现自定义的对象相等语义。警告：不要使用数据库标识来实现对象相等，应该使用业务键值，由唯一的，通常不变的属性组成。当一个瞬时对象被持久化的时候，它的数据库标识会发生改变。如果一个瞬时对象（通常也包括脱管对象实例）被放入一个 <code class="literal">Set</code>，改变它的 hashcode 会导致与这个 <code class="literal">Set</code> 的关系中断。虽 然业务键值的属性不象数据库主键那样稳定不变，但是你只需要保证在同一个 <code class="literal">Set</code> 中的对象属性的稳定性就足够了。请到 Hibernate 网站去寻求这个问题更多的详细的讨论。请注意，这不是一个有关 Hibernate 的问题，而仅仅是一个关于 Java 对象标识和判等行为如何实现的问题。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>13.1.4. 常见问题</h3></div></div></div><p>决不要使用反模式 <span class="emphasis"><em>session-per-user-session</em></span> 或者 <span class="emphasis"><em> session-per-application</em></span>（当然，这个规定几乎没有例外）。请注意，下述一些问题可能也会出现在我们推荐的模式中，在你作出某个设计决定之前，请务必理解该模式的应用前提。  </p><div class="itemizedlist"><ul><li><p><code class="literal">Session</code> 对象是非线程安全的。如果一个 <code class="literal">Session</code> 实例允许共享的话，那些支持并发运行的东东，例如 HTTP request，session beans 或者是 Swing workers，将会导致出现资源争用（race condition）。如果在 <code class="literal">HttpSession</code> 中有 Hibernate 的 <code class="literal">Session</code> 的话（稍后讨论），你应该考虑同步访问你的 Http session。 否则，只要用户足够快的点击浏览器的“刷新”，就会导致两个并发运行线程使用同一个  <code class="literal">Session</code>。  </p></li><li><p>一个由 Hibernate 抛出的异常意味着你必须立即回滚数据库事务，并立即关闭 <code class="literal">Session</code>（稍后会展开讨论）。如果你的 <code class="literal">Session</code> 绑定到一个应用程序上，你必须停止该应用程序。回滚数据库事务并不会把你的业务对象退回到事务启动时候的状态。这意味着数据库状态和业务对象状态不同步。通常情况下，这不是什么问题，因为异常是不可恢复的，你必须在回滚之后重新开始执行。  </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a class="xref" href="batch.html" title="第 15 章 批量处理（Batch processing）">第 15 章 <i>批量处理（Batch processing）</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>13.2. 数据库事务声明</h2></div></div></div><p>数据库（或者系统）事务的声明总是必须的。在数据库事务之外，就无法和数据库通讯（这可能会让那些习惯于自动提交事务模式的开发人员感到迷惑）。永远使用清晰的事务声明，即使只读操作也是如此。进行 显式的事务声明并不总是需要的，这取决于你的事务隔离级别和数据库的能力，但不管怎么说，声明事务总归有益无害。当然，一个单独的数据库事务总是比很多琐碎的事务性能更好，即时对读数据而言也是一样。  </p><p>一个 Hibernate 应用程序可以运行在非托管环境中（也就是独立运行的应用程序，简单 Web 应用程序，或者Swing图形桌面应用程序），也可以运行在托管的 J2EE 环境中。在一个非托管环境中，Hibernate 通常自己负责管理数据库连接池。应用程序开发人员必须手工设置事务声明，换句话说，就是手工启 动，提交，或者回滚数据库事务。一个托管的环境通常提供了容器管理事务（CMT），例如事务装配通过可声明的方式定义在 EJB session beans 的部署描述符中。可编程式事务声明不再需要，即使是 <code class="literal">Session</code> 的同步也可以自动完成。  </p><p>让持久层具备可移植性是人们的理想,这种移植发生在非托管的本地资源环境，与依赖 JTA 但是使用 BMT 而非 CMT 的系统之间。在两种情况下你都可以使用编程式的事务管理。Hibernate 提供了一套称为 <code class="literal">Transaction</code> 的封装 API， 用来把你的部署环境中的本地事务管理系统转换到 Hibernate 事务上。这个 API 是可选的，但是我们强烈推荐你使用，除非你用 CMT session bean。  </p><p>通常情况下，结束 <code class="literal">Session</code> 包含了四个不同的阶段：  </p><div class="itemizedlist"><ul compact="compact"><li><p>同步 session（flush，刷出到磁盘） </p></li><li><p>提交事务 </p></li><li><p>关闭 session </p></li><li><p>处理异常 </p></li></ul></div><p>session 的同步（flush，刷出）前面已经讨论过了，我们现在进一步考察在托管和非托管环境下的事务声明和异常处理。  </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>13.2.1. 非托管环境</h3></div></div></div><p>如果 Hibernat 持久层运行在一个非托管环境中，数据库连接通常由 Hibernate 的简单（即非 DataSource）连接池机制 来处理。session/transaction 处理方式如下所示：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>你不需要显式 <code class="literal">flush()</code> <code class="literal">Session</code> — 对 <code class="literal">commit()</code> 的调用会自动触发 session 的同步（取决于 session 的 <a class="xref" href="objectstate.html#objectstate-flushing" title="11.10. Session 刷出（flush）">第 11.10 节 “Session 刷出（flush）”</a>）。调用 <code class="literal">close()</code> 标志 session 的结束。<code class="literal">close()</code> 方法重要的暗示是，<code class="literal">session</code> 释放了 JDBC 连接。这段 Java 代码在非托管环境下和 JTA 环境下都可以运行。  </p><p>更加灵活的方案是 Hibernate 内置的 "current session" 上下文管理，前文已经讲过：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>你很可能从未在一个通常的应用程序的业务代码中见过这样的代码片断：致命的（系统）异常应该总是 在应用程序“顶层”被捕获。换句话说，执行 Hibernate 调用的代码（在持久层）和处理 <code class="literal">RuntimeException</code> 异常的代码（通常只能清理和退出应用程序）应该在不同 的应用程序逻辑层。Hibernate 的当前上下文管理可以极大地简化这一设计，你所有的一切就是 <code class="literal">SessionFactory</code>。异常处理将在本章稍后进行讨论。  </p><p>请注意，你应该选择 <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code> （这是默认选项），对第二个例子来说，<code class="literal">hibernate.current_session_context_class</code>应该是 <code class="literal">"thread"</code>。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>13.2.2. 使用 JTA</h3></div></div></div><p>如果你的持久层运行在一个应用服务器中（例如，在 EJB session beans 的后面），Hibernate 获取的每个数据源连接将自动成为全局 JTA 事务的一部分。你可以安装一个独立的 JTA 实现，使用它而不使用 EJB。Hibernate 提供了两种策略进行 JTA 集成。  </p><p>如果你使用 bean 管理事务（BMT），可以通过使用 Hibernate 的 <code class="literal">Transaction</code> API 来告诉应用服务器启动和结束 BMT 事务。因此，事务管理代码和在非托管环境下是一样的。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>如果你希望使用与事务绑定的 <code class="literal">Session</code>，也就是使用 <code class="literal">getCurrentSession()</code> 来简化上下文管理，你将不得不直接使用 JTA  <code class="literal">UserTransaction</code> API。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">UserTransaction</span><span class="java_separator">)</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;java:comp/UserTransaction&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Do</span><span class="java_plain">&nbsp;some&nbsp;work&nbsp;on&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;bound&nbsp;to&nbsp;transaction</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">load</span><span class="java_separator">(...);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">persist</span><span class="java_separator">(...);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>在 CMT 方式下，事务声明是在 session bean 的部署描述符中，而不需要编程。因此，代码被简化为： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;CMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</pre><p>在 CMT/EJB 中甚至会自动 rollback，因为假若有未捕获的 <code class="literal">RuntimeException</code> 从 session bean 方法中抛出，这就会通知容器把全局事务回滚。<span class="emphasis"><em>这就意味着，在 BMT 或者 CMT 中，你根本就不需要使用 Hibernate <code class="literal">Transaction</code> API，你自动得到了绑定到事务的“当前” Session。</em></span> </p><p>注意，当你配置 Hibernate 的 transaction factory 的时候，在直接使用 JTA 的时候（BMT），你应该选择 <code class="literal">org.hibernate.transaction.JTATransactionFactory</code>，在 CMT session bean 中选择 <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code>。记得也要设置 <code class="literal">hibernate.transaction.manager_lookup_class</code>。还有，确认你的 <code class="literal">hibernate.current_session_context_class</code> 未设置（为了向下兼容），或者设置为 <code class="literal">"jta"</code>。  </p><p><code class="literal">getCurrentSession()</code>在 JTA 环境中有一个弊端。对 <code class="literal">after_statement</code> 连接释放方式有一个警告，这是被默认使用的。因为 JTA 规范的一个很愚蠢的限制，Hibernate 不可能自动清理任何未关闭的 <code class="literal">ScrollableResults</code> 或者<code class="literal">Iterator</code>，它们是由 <code class="literal">scroll()</code> 或 <code class="literal">iterate()</code> 产生的。你 <span class="emphasis"><em>must</em></span> 通过在 <code class="literal">finally</code> 块中，显式调用 <code class="literal">ScrollableResults.close()</code> 或者 <code class="literal">Hibernate.close(Iterator)</code> 方法来释放底层数据库游标。（当然，大部分程序完全可以很容易的避免在 JTA 或 CMT 代码中出现 <code class="literal">scroll()</code> 或 <code class="literal">iterate()</code>。）  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>13.2.3. 异常处理</h3></div></div></div><p>如果 <code class="literal">Session</code> 抛出异常（包括任何 <code class="literal">SQLException</code>），你应该立即回滚数据库事务，调用 <code class="literal">Session.close()</code> ，丢弃该  <code class="literal">Session</code> 实例。<code class="literal">Session</code> 的某些方法可能会导致 session 处于不一致的状态。所有由 Hibernate 抛出的异常都视为不可以恢复的。确保在  <code class="literal">finally</code> 代码块中调用 <code class="literal">close()</code> 方法，以关闭掉  <code class="literal">Session</code>。 </p><p><code class="literal">HibernateException</code> 是一个非检查期异常（这不同于 Hibernate 老的版本），它封装了 Hibernate 持久层可能出现的大多数错误。我们的观点是，不应该强迫应用程序开发人员 在底层捕获无法恢复的异常。在大多数软件系统中，非检查期异常和致命异常都是在相应方法调用 的堆栈的顶层被处理的（也就是说，在软件上面的逻辑层），并且提供一个错误信息给应用软件的用户 （或者采取其他某些相应的操作）。请注意，Hibernate 也有可能抛出其他并不属于 <code class="literal">HibernateException</code> 的非检查期异常。这些异常同样也是无法恢复的，应该 采取某些相应的操作去处理。 </p><p>在和数据库进行交互时，Hibernate 把捕获的 <code class="literal">SQLException</code> 封装为 Hibernate 的  <code class="literal">JDBCException</code>。事实上，Hibernate 尝试把异常转换为更有实际含义的 <code class="literal">JDBCException</code> 异常的子类。底层的 <code class="literal">SQLException</code> 可以通过 <code class="literal">JDBCException.getCause()</code> 来得到。Hibernate 通过使用关联到  <code class="literal">SessionFactory</code> 上的 <code class="literal">SQLExceptionConverter</code> 来把 <code class="literal">SQLException</code> 转换为一个对应的 <code class="literal">JDBCException</code> 异常的子类。默认情况下，<code class="literal">SQLExceptionConverter</code> 可以通过配置 dialect 选项指定；此外，也可以使用用户自定义的实现类（参考 javadocs <code class="literal">SQLExceptionConverterFactory</code> 类来了解详情）。标准的 <code class="literal">JDBCException</code> 子类型是：  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code>：指明底层的 JDBC 通讯出现错误。 </p></li><li><p><code class="literal">SQLGrammarException</code>：指明发送的 SQL 语句的语法或者格式错误。 </p></li><li><p><code class="literal">ConstraintViolationException</code>：指明某种类型的约束违例错误 </p></li><li><p><code class="literal">LockAcquisitionException</code>：指明了在执行请求操作时，获取所需的锁级别时出现的错误。 </p></li><li><p><code class="literal">GenericJDBCException</code>：不属于任何其他种类的原生异常。 </p></li></ul></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>13.2.4. 事务超时</h3></div></div></div><p>EJB 这样的托管环境有一项极为重要的特性，而它从未在非托管环境中提供过，那就是事务超时。在出现错误的事务行为的时候，超时可以确保不会无限挂起资源、对用户没有交代。在托管（JTA）环境之外，Hibernate 无法完全提供这一功能。但是，Hiberante 至少可以控制数据访问，确保数据库级别的死锁，和返回巨大结果集的查询被限定在一个规定的时间内。在托管环境中，Hibernate 会把事务超时转交给 JTA。这一功能通过 Hibernate <code class="literal">Transaction</code> 对象进行抽象。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">set&nbsp;transaction&nbsp;timeout&nbsp;to&nbsp;</span><span class="java_literal">3</span><span class="java_plain">&nbsp;seconds</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">setTimeout</span><span class="java_separator">(</span><span class="java_literal">3</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>注意 <code class="literal">setTimeout()</code> 不应该在 CMT bean 中调用，此时事务超时值应该是被声明式定义的。  </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>13.3. 乐观并发控制（Optimistic concurrency control）</h2></div></div></div><p>唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本化的乐观并发控制。版本检查使用版本号、 或者时间戳来检测更新冲突（并且防止更新丢失）。Hibernate 为使用乐观并发控制的代码提供了三种可 能的方法，应用程序在编写这些代码时，可以采用它们。我们已经在前面应用程序对话那部分展示了 乐观并发控制的应用场景，此外，在单个数据库事务范围内，版本检查也提供了防止更新丢失的好处。  </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>13.3.1. 应用程序级别的版本检查（Application version checking）</h3></div></div></div><p>未能充分利用 Hibernate 功能的实现代码中，每次和数据库交互都需要一个新的  <code class="literal">Session</code>，而且开发人员必须在显示数据之前从数据库中重新载入所有的持久化对象实例。这种方式迫使应用程序自己实现版本检查来确保对话事务的隔离，从数据访问的角度来说是最低效的。这种使用方式和 entity EJB 最相似。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_type">int</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">load</span><span class="java_separator">(</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">,</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getKey</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;load&nbsp;the&nbsp;current&nbsp;state</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StaleObjectStateException</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p><code class="literal">version</code> 属性使用 <code class="literal">&lt;version&gt;</code> 来映射，如果对象是脏数据，在同步的时候，Hibernate 会自动增加版本号。 </p><p>当然，如果你的应用是在一个低数据并发环境下，并不需要版本检查的话，你照样可以使用这种方式，只不过跳过版本检查就是了。在这种情况下，<span class="emphasis"><em>最晚提交生效</em></span> （<span class="emphasis"><em>last commit wins</em></span>）就是你的长对话的默认处理策略。请记住这种策略可能会让应用软件的用户感到困惑，因为他们有可能会碰上更新丢失掉却没有出错信息，或者需要合并更改冲突的情况。  </p><p>很明显，手工进行版本检查只适合于某些软件规模非常小的应用场景，对于大多数软件应用场景来说并不现实。通常情况下，不仅是单个对象实例需要进行版本检查，整个被修改过的关联对象图也都需要进行版本检查。作为标准设计范例，Hibernate 使用扩展周期的 <code class="literal">Session</code> 的方式，或者脱管对象实例的方式来提供自动版本检查。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>13.3.2. 扩展周期的 session 和自动版本化</h3></div></div></div><p>单个 <code class="literal">Session</code> 实例和它所关联的所有持久化对象实例都被用于整个对话，这被称为 <span class="emphasis"><em>session-per-conversation</em></span>。Hibernate 在同步的时候进行对象实例的版本检查，如果检测到并发修改则抛出异常。由开发人员来决定是否需要捕获和处理这个异常（通常的抉择是给用户 提供一个合并更改，或者在无脏数据情况下重新进行业务对话的机会）。  </p><p>在等待用户交互的时候， <code class="literal">Session</code> 断开底层的 JDBC 连接。这种方式以数据库访问的角度来说是最高效的方式。应用程序不需要关心版本检查或脱管对象实例的重新关联，在每个数据库事务中，应用程序也不需要载入读取对象实例。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;earlier&nbsp;by&nbsp;the&nbsp;old&nbsp;session</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Obtain</span><span class="java_plain">&nbsp;a&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span><span class="java_separator">,</span><span class="java_plain">&nbsp;start&nbsp;transaction</span>
</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">flush</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Also</span><span class="java_plain">&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;JDBC&nbsp;connection</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Only</span><span class="java_plain">&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;last&nbsp;transaction&nbsp;in&nbsp;conversation</span></pre><p><code class="literal">foo</code> 对象知道它是在哪个 <code class="literal">Session</code> 中被装入的。在一个旧 session 中开启一个新的数据库事务，会导致 session 获取一个新的连接，并恢复 session 的功能。将数据库事务提交，使得 session 从 JDBC 连接断开，并将此连接交还给连接池。在重新连接之后，要强制对你没有更新的数据进行一次版本检查，你可以对所有可能被其他事务修改过的对象，使用参数 <code class="literal">LockMode.READ</code> 来调用 <code class="literal">Session.lock()</code>。你不用 lock 任何你<span class="emphasis"><em>正在</em></span>更新的数据。一般你会在扩展的 <code class="literal">Session</code> 上设置 <code class="literal">FlushMode.NEVER</code>，因此只有最后一个数据库事务循环才会真正的把整个对话中发生的修改发送到数据库。因此，只有这最后一次数据库事务才会包含 <code class="literal">flush()</code> 操作，然后在整个对话结束后，还要 <code class="literal">close()</code> 这个 session。  </p><p>如果在用户思考的过程中，<code class="literal">Session</code> 因为太大了而不能保存，那么这种模式是有问题的。举例来说，一个 <code class="literal">HttpSession</code> 应该尽可能的小。由于  <code class="literal">Session</code> 是一级缓存，并且保持了所有被载入过的对象，因此我们只应该在那些少量的 request/response 情况下使用这种策略。你应该只把一个 <code class="literal">Session</code> 用于单个对话，因为它很快就会出现脏数据。  </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>注意，早期的 Hibernate 版本需要明确的对 <code class="literal">Session</code> 进行 disconnect 和 reconnect。这些方法现在已经过时了，打开事务和关闭事务会起到同样的效果。 </p></div><p>此外，也请注意，你应该让与数据库连接断开的 <code class="literal">Session</code> 对持久层保持关闭状态。换句话说，在三层环境中，使用有状态的 EJB session bean 来持 有<code class="literal">Session</code>， 而不要把它传递到 web 层（甚至把它序列化到一个单独的层），保存在 <code class="literal">HttpSession</code> 中。  </p><p>扩展 session 模式，或者被称为<span class="emphasis"><em>每次对话一个session（session-per-conversation）</em></span>，自动管理当前 session 上下文联用的时候会更困难。你需要提供你自己的 <code class="literal">CurrentSessionContext</code> 实现。请参阅 Hibernate Wiki 以获得示例。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>13.3.3. 脱管对象（deatched object）和自动版本化</h3></div></div></div><p>这种方式下，与持久化存储的每次交互都发生在一个新的 <code class="literal">Session</code> 中。然而，同一持久化对象实例可以在多次与数据库的交互中重用。应用程序操纵脱管对象实例 的状态，这个脱管对象实例最初是在另一个 <code class="literal">Session</code> 中载入的，然后调用 <code class="literal">Session.update()</code>，<code class="literal">Session.saveOrUpdate()</code>，或者  <code class="literal">Session.merge()</code> 来重新关联该对象实例。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;</span><!-- <br/> --><span class="java_type">Session</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">session&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">saveOrUpdate</span><span class="java_separator">(</span><span class="java_plain">foo</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Use</span><span class="java_plain">&nbsp;merge</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;foo&quot;</span><span class="java_plain">&nbsp;might&nbsp;have&nbsp;been&nbsp;loaded&nbsp;already</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">session</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>Hibernate 会再一次在同步的时候检查对象实例的版本，如果发生更新冲突，就抛出异常。  </p><p>如果你确信对象没有被修改过，你也可以调用 <code class="literal">lock()</code> 来设置  <code class="literal">LockMode.READ</code>（绕过所有的缓存，执行版本检查），从而取代  <code class="literal">update()</code> 操作。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>13.3.4. 定制自动版本化行为</h3></div></div></div><p>对于特定的属性和集合，通过为它们设置映射属性 <code class="literal">optimistic-lock</code> 的值为 <code class="literal">false</code>，来禁止 Hibernate 的版本自动增加。这样的话，如果该属性脏数据，Hibernate 将不再增加版本号。  </p><p>遗留系统的数据库 Schema 通常是静态的，不可修改的。或者，其他应用程序也可能访问同一数据库，根本无法得知如何处理版本号，甚至时间戳。在以上的所有场景中，实现版本化不能依靠数据库表的某个特定列。在 <code class="literal">&lt;class&gt;</code> 的映射中设置  <code class="literal">optimistic-lock="all"</code> 可以在没有版本或者时间戳属性映射的情况下实现版本检查，此时 Hibernate 将比较一行记录的每个字段的状态。请注意，只有当 Hibernate 能够比较新旧状态的情况下，这种方式才能生效，也就是说，你必须使用单个长生命周期 <code class="literal">Session</code> 模式，而不能使用 session-per-request-with-detached-objects 模式。  </p><p>有些情况下，只要更改不发生交错，并发修改也是允许的。当你在 <code class="literal">&lt;class&gt;</code> 的映射中设置 <code class="literal">optimistic-lock="dirty"</code>，Hibernate 在同步的时候将只比较有脏数据的字段。  </p><p>在以上所有场景中，不管是专门设置一个版本/时间戳列，还是进行全部字段/脏数据字段比较，Hibernate 都会针对每个实体对象发送一条 <code class="literal">UPDATE</code>（带有相应的 <code class="literal">WHERE</code> 语句 ）的 SQL 语句来执行版本检查和数据更新。如果你对关联实体 设置级联关系使用传播性持久化（transitive persistence），那么 Hibernate 可能会执行不必 要的update语句。这通常不是个问题，但是数据库里面对 <span class="emphasis"><em>on update</em></span> 点火 的触发器可能在脱管对象没有任何更改的情况下被触发。因此，你可以在 <code class="literal">&lt;class&gt;</code> 的映射中，通过设置<code class="literal">select-before-update="true"</code> 来定制这一行为，强制 Hibernate  <code class="literal">SELECT</code> 这个对象实例，从而保证，在更新记录之前，对象的确是被修改过。  </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>13.4. 悲观锁定（Pessimistic Locking） </h2></div></div></div><p>用户其实并不需要花很多精力去担心锁定策略的问题。通常情况下，只要为 JDBC 连接指定一下隔离级别，然后让数据库去搞定一切就够了。然而，高级用户有时候希望进行一个排它的悲观锁定，或者在一个新的事务启动的时候，重新进行锁定。  </p><p>Hibernate 总是使用数据库的锁定机制，从不在内存中锁定对象。 </p><p>类 <code class="literal">LockMode</code> 定义了 Hibernate 所需的不同的锁定级别。一个锁定可以通过以下的机制来设置： </p><div class="itemizedlist"><ul compact="compact"><li><p>当 Hibernate 更新或者插入一行记录的时候，锁定级别自动设置为 <code class="literal">LockMode.WRITE</code>。 </p></li><li><p>当用户显式的使用数据库支持的 SQL 格式 <code class="literal">SELECT ... FOR UPDATE</code> 发送 SQL 的时候，锁定级别设置为 <code class="literal">LockMode.UPGRADE</code>。  </p></li><li><p>当用户显式的使用 Oracle 数据库的 SQL 语句 <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> 的时候，锁定级别设置 <code class="literal">LockMode.UPGRADE_NOWAIT</code>。  </p></li><li><p>当 Hibernate 在“可重复读”或者是“序列化”数据库隔离级别下读取数据的时候，锁定模式自动设置为 <code class="literal">LockMode.READ</code>。这种模式也可以通过用户显式指定进行设置。  </p></li><li><p><code class="literal">LockMode.NONE</code> 代表无需锁定。在 <code class="literal">Transaction</code> 结束时， 所有的对象都切换到该模式上来。与 session 相关联的对象通过调用 <code class="literal">update()</code> 或者 <code class="literal">saveOrUpdate()</code> 脱离该模式。 </p></li></ul></div><p>"显式的用户指定"可以通过以下几种方式之一来表示： </p><div class="itemizedlist"><ul compact="compact"><li><p>调用 <code class="literal">Session.load()</code> 的时候指定<code class="literal">锁定模式（LockMode）</code>。 </p></li><li><p>调用 <code class="literal">Session.lock()</code>。 </p></li><li><p>调用 <code class="literal">Query.setLockMode()</code>。 </p></li></ul></div><p>如果在 <code class="literal">UPGRADE</code> 或者 <code class="literal">UPGRADE_NOWAIT</code> 锁定模式下调用 <code class="literal">Session.load()</code>，并且要读取的对象尚未被 session 载入过，那么对象通过 <code class="literal">SELECT ... FOR UPDATE</code> 这样的 SQL 语句被载入。如果为一个对象调用  <code class="literal">load()</code> 方法时，该对象已经在另一个较少限制的锁定模式下被载入了，那么  Hibernate 就对该对象调用 <code class="literal">lock()</code> 方法。 </p><p>如果指定的锁定模式是 <code class="literal">READ</code>，<code class="literal">UPGRADE</code> 或  <code class="literal">UPGRADE_NOWAIT</code>，那么 <code class="literal">Session.lock()</code> 就执行版本号检查。（在 <code class="literal">UPGRADE</code> 或者 <code class="literal">UPGRADE_NOWAIT</code> 锁定模式下，执行 <code class="literal">SELECT ... FOR UPDATE</code>这样的SQL语句。） </p><p>如果数据库不支持用户设置的锁定模式，Hibernate 将使用适当的替代模式（而不是扔出异常）。这一点可以确保应用程序的可移植性。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>13.5. 连接释放模式（Connection Release Modes） </h2></div></div></div><p>Hibernate 关于 JDBC 连接管理的旧（2.x）行为是，<code class="literal">Session</code> 在第一次需要的时候获取一个连接，在 session 关闭之前一直会持有这个连接。Hibernate 引入了连接释放的概念，来告诉 session 如何处理它的 JDBC 连接。注意，下面的讨论只适用于采用配置 <code class="literal">ConnectionProvider</code> 来提供连接的情况，用户自己提供的连接与这里的讨论无关。通过 <code class="literal">org.hibernate.ConnectionReleaseMode</code> 的不同枚举值来使用不用的释放模式： </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code>：基本上就是上面提到的老式行为。Hibernate session 在第一次需要进行 JDBC 操作的时候获取连接，然后持有它，直到 session 关闭。 </p></li><li><p><code class="literal">AFTER_TRANSACTION</code>：在 <code class="literal">org.hibernate.Transaction</code> 结束后释放连接。 </p></li><li><p><code class="literal">AFTER_STATEMENT</code>（也被称做积极释放）：在每一条语句被执行后就释放连接。但假若语句留下了与 session 相关的资源，那就不会被释放。目前唯一的这种情形就是使用 <code class="literal">org.hibernate.ScrollableResults</code>。 </p></li></ul></div><p><code class="literal">hibernate.connection.release_mode</code> 配置参数用来指定使用哪一种释放模式。可能的值有：  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code>（默认）：这一选择把释放模式委派给 <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code> 方法。对 JTATransactionFactory 来说，它会返回 ConnectionReleaseMode.AFTER_STATEMENT；对　JDBCTransactionFactory　来说，则是ConnectionReleaseMode.AFTER_TRANSACTION。很少需要修改这一默认行为，因为假若设置不当，就会带来 bug，或者给用户代码带来误导。 </p></li><li><p><code class="literal">on_close</code>：使用 ConnectionReleaseMode.ON_CLOSE。这种方式是为了向下兼容的,但是已经完全不被鼓励使用了。 </p></li><li><p><code class="literal">after_transaction</code>：使用 ConnectionReleaseMode.AFTER_TRANSACTION。这一设置不应该在 JTA 环境下使用。也要注意，使用 ConnectionReleaseMode.AFTER_TRANSACTION 的时候，假若session 处于 auto-commit 状态，连接会像 AFTER_STATEMENT 那样被释放。 </p></li><li><p><code class="literal">after_statement</code>：使用 ConnectionReleaseMode.AFTER_STATEMENT。除此之外，会查询配置的 <code class="literal">ConnectionProvider</code>，是否它支持这一设置（<code class="literal">supportsAggressiveRelease()</code>）。假若不支持，释放模式会被设置为  ConnectionReleaseMode.AFTER_TRANSACTION。只有在你每次调用  <code class="literal">ConnectionProvider.getConnection()</code> 获取底层 JDBC 连接的时候，都可以确信获得同一个连接的时候，这一设置才是安全的；或者在 auto-commit 环境中，你可以不管是否每次都获得同一个连接的时候，这才是安全的。 </p></li></ul></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>上一页</strong>第 12 章 Read-only entities</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>下一页</strong>第 14 章 拦截器与事件（Interceptors and events）</a></li></ul></body></html>